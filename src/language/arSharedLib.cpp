//********************************************************
// Syzygy source code is licensed under the GNU LGPL
// see the file SZG_CREDITS for details
//********************************************************

// precompiled header include MUST appear as the first non-comment line
#include "arPrecompiled.h"
#include "arSharedLib.h"
#include "arDataUtilities.h"
#include <stdio.h>
#include <errno.h>
#include <iostream>
using namespace std;

arSharedLib::arSharedLib() :
  _h(NULL){
}

arSharedLib::~arSharedLib(){
}

/// Given a shared library name (WITHOUT the .dll or .so suffix that varies
/// by operating system), search the given path (which is a
/// semicolon-delimited string) for the library and attempt to load it,
/// returning true upon success and false upon failure.
bool arSharedLib::open(const string& sharedLibName, const string& path){
  string libName = sharedLibName;
  // Adds .dll or .so depending upon the platform.
  ar_addSharedLibExtension(libName);
  // Only try to produce an absolute file name if the path is specified.
  if (path != ""){
    // We want to use an absolute path name, if possible, to avoid the
    // unpredictability of the OS's internal shared library searching.
    libName = ar_fileFind(libName,"",path);
    if (libName == "NULL"){
      cout << "arSharedLib error: could not find named shared lib on given "
	   << "path.\n";
      return false;
    }
  }
  // Next there is a Win32 way and a Unix way...
#ifdef AR_USE_WIN_32
  // The Win32 way...
  _h = LoadLibrary(libName.c_str());
  return _h != NULL;
#else
  // The Unix way...
  _h = dlopen(libName.c_str(), RTLD_NOW);
  return _h != NULL;
#endif
}

/// Unmap the already loaded library from the shared memory space, returning
/// true for success and false for error.
bool arSharedLib::close(){
#ifdef AR_USE_WIN_32
  // The Win32 way..
  return FreeLibrary(_h) != 0;
#else
  // The Unix way...
  return dlclose(_h) == 0;
#endif
}

/// Try to return a pointer to the named function in the shared library.
/// Some name-mangling might occur (for instance, Mac OS X appends a "_"
/// to the front of function names. Returns NULL on error.
/// NOTE: This function uses the literal name provided. See szg_sym for
/// a variation.
/// This function is used in syzygy's plug-in architecture. There, each shared
/// library contains the code for a single C++ object. Information about this
/// object can be gleaned (and instances of the object created) by 3 well
/// known functions contained in each shared lib (which are accessed via sym):
///
/// extern "C"{
///   base_class_pointer* factory();
///   void                baseType(char* buffer, int bufferSize);
/// }
///
/// Here, the factory returns instances of the object and baseType fills the
/// passed buffer with the base class type (i.e. arIOFilter, arInputSource,
/// etc.). The baseType function is needed for type-checking.
void* arSharedLib::sym(const string& functionName){
#ifdef AR_USE_WIN_32
  // The Windows way
  return GetProcAddress(_h, functionName.c_str());
#else
  // The Unix way
  string name;
#ifdef AR_USE_DARWIN
  // Specifically for Mac OS X, we need to add a leading "_"
  name = "_" + functionName;
#else
  // Linux and Irix do not seem to have this property.
  name = functionName;
#endif
  return dlsym(_h, name.c_str());
#endif
}

/// If an error has occured, this will a string containing the last
/// error message generated by the loading mechanism.
string arSharedLib::error(){
  string result;
#ifdef AR_USE_WIN_32
  static char buf[80];
  sprintf(buf, "GetLastError() = %d", GetLastError());
  result = string(buf);
#else
  result = string(dlerror());
#endif
  return result;
}

