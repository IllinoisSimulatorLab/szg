<html>
<head>
<title>Phleet Operating System</title>
</head>
<body bgcolor="#ffffff">
<a href="index.html">Documentation Index</a>
<p><font size=+2>Phleet Operating System</font>

<p>The Phleet distributed operating system layer of the 
Syzygy toolkit has a minimal number of features and components.
The group of computers comprising the Phleet
is controlled by an szgserver program, which performs several functions:

<p><ul>
<li> Manages multiple users.
<li> Stores a parameter database for each user, which is used by software components to
obtain configuration information. The parameter database is similar in character to
Unix environment variables.
<li> Maintains a list of the software components registered with the Phleet,
with each component being identified by the computer on which it is running,
a symbolic string (equivalent to executable name), and a unique ID (equivalent
to Unix process ID).
<li> Can route messages from one registered software component to another. These
messages can be used like Unix signals. For instance, to cause a component to
terminate or reload its parameters.
<li> Contains a connection brokering service which deals with multi-homing and
aids in ease of set-up.
<li> Supports named locks that are owned by phleet components. Locks are necessary so
that certain operations, like starting a distributed application, can be performed
atomically. These locks are released when a component dies.
</ul>

<p>The Phleet can be controlled in two basic ways:

<p><ul>
<li> From the command line (or scripts). A complete selection of commands is
provided. This is useful, for instance, in providing GUI front-ends for various
categories of tasks via a scripting language like Python.
<li> Programatically by using the methods of an arSZGClient object. There is almost
a one-to-one mapping between the methods of this object and the command line
executables. This method is used to make launching applications on "virtual computers"
easier.
</ul>

<p>A Phleet is comprised of a set of computers connected by a network. Each Phleet
is controlled by an szgserver program. There is only one instance of this program 
per Phleet instance. The connection to the szgserver is maintained on a 
per-computer basis (for all users of the box), but you can switch a given
computer to a new szgserver using the dconnect command. Furthermore, 
for full operation, each computer in the Phleet
should run a copy of szgd, the remote execution daemon. Like the rest of the Phleet
toolset, szgd is designed to support multiple users. When you try to remotely execute
a program with Phleet identity XXX, the remote program also gets identity XXX.
A Phleet member doesn't <em>have</em> to run szgd, if programs will be executed
manually thereon.

<a name="Contents">
<p><font size=+2>Contents</font>
</a>

<p><ol>
<li> <a href="#ReservedWords">Reserved Words and Characters</a>
<li> <a href="#ReservedPorts">Reserved Ports</a>
<li> <a href="#PhleetConfiguration">Phleet Configuration</a>
<li> <a href="#RunningSzgserver">Running szgserver</a>
<li> <a href="#Connect">How Clients Connect to the szgserver</a>
<li> <a href="#Szgd">szgd</a>
<li> <a href="#Names">Names, According to szgserver</a>
<li> <a href="#User">How Clients Determine the Current User?</a>
<li> <a href="#CommandLine">Command Line Tools, Organized by Functionality</a>
<li> <a href="#Message">How Do Clients Message Each Other (via szgserver)</a>
<li> <a href="#MessageMethod">arSZGClient Methods Associated with Messaging</a>
<li> <a href="#Lock">The Operation of Locks in Phleet</a>
<li> <a href="#LockMethod">arSZGClient Methods Associated with Locks</a>
<li> <a href="#Brokering">Connection Brokering in Phleet</a>
<li> <a href="#BrokeringMethod">arSZGClient Methods Associated with Connection Brokering</a>
</ol>

<a name="ReservedWords">
<p><font size=+2>Reserved Words and Characters</font>
</a>

<p>"NULL" or "*" cannot be user-defined user, computer, group, or 
parameter names. "NULL" internally functions as the indication of an undefined
value, whereas "*" is used in the szgserver discovery process. The characters

<pre>
  :  ;  |  / 
</pre>

should not be used in names. These characters are used for data parsing and 
representation. 

<a name="ReservedPorts">
<p><font size=+2>Reserved Ports</font>
</a>

<p>The Phleet components use UDP on port 4620 to provide automatic discovery of
running szgserver's. Syzygy also needs a block of ports reserved on each machine
in the Phleet, as a Syzygy cluster is called, for connection brokering. By default,
the port block used is 4700-4899, but can be redefined by the user.

<a name="PhleetConfiguration">
<p><font size=+2>Phleet Configuration</font>
</a>

<p>The phleet configuration file, szg.conf, is comprised of several different XML
record types.

  <pre>
  "computer"
    char[] name;
  </pre>

  <pre>
  "interface"
    char[] type;    // only "ip" valid so far
    char[] name;    // a name for the network, like "internet", "wall", or "cube"
    char[] address; // the interface's address, for instance 192.168.0.1
    char[] netmask; // the netmask associated with this interface, assumed to be
                    // 255.255.255.0 if not set.
  </pre>

  <pre>
  "ports"
    int[] first; // the first port in the block to be used by Syzygy on the given computer
    int[] size;  // the number of ports in the block
  </pre>

<p>The szg.conf file contains one "computer" record, giving the computer's syzygy name,
which can be different from any other names the computer has, for instance via DNS. It
then contains several "interface" record, one for each communications interface the
computer has. Finally, the szg.conf file contains one "ports" record, which determines
which ports services running on that computer will use. If no such record is present,
the dname command will write a default record to the file, The default port range is
4700-4899. 

<p>The szg.conf file is found at c:\szg.conf on Win32 systems and
at /etc/szg.conf on Unix systems. To enable non-root users to use syzygy on Unix, if
/etc/szg.conf is not present, /tmp/szg.conf will be used. However, the presence of
/tmp/szg.conf will be ignored if the former file is present.

<p>The user should not have to edit szg.conf by hand. Consequently, several command
line programs are provided. Each of these commands parse the whole szg.conf file, writing
it fresh upon completion, thus eliminating errors that could creep in via editting by
hand. Both the "name" and "ports" record must be present in this file. If they are
not, default values are written. The default "ports" record has already been mentioned.
The default "name" record uses a default name of "NULL".

  <pre>
  dconfig

  Reads the szg.conf file and prints the information contained therein in an easily
  human readable form.
  </pre>

  <pre>
  daddinterface [-t] type name address

  Adds an interface to szg.conf file with the given type/name/address.
  If the "-t" option is present and the command is issued on a Unix system,
  /tmp/szg.conf is altered instead of /etc/szg.conf. Note that the name/address
  pair must be unique among interfaces on the system.
  </pre>

  <pre>
  ddelinterface [-t] name address

  Removes the interface with the given name/address pair from the szg.conf file.
  If the "-t" option is present, /tmp/szg.conf is altered instead of /etc/szg.conf.
  </pre>

  <pre>
  dports [-t] first size

  Changes the "ports" record in the szg.conf file, with "first" giving the number of
  the first port to be used and "size" giving the size of the port window. If the
  "-t" option is present (and the command is issued on a Unix system), /tmp/szg.conf
  is altered instead of /etc/szg.conf.
  </pre>

  <pre>
  dname [-t] name

  Sets the computer's name in the szg.conf file. If no ports information is present,
  it goes ahead and adds a default ports record, reserving the range 4700-4899.
  As before, if the "-t" option is present (and the command is issued on a Unix system),
  /tmp/szg.conf is altered instead of /etc/szg.conf.
  </pre>

<p>The phleet configuration file really just determines the identity of an 
individual computer in the system: its name, its network interfaces, and the ports
it will use to offer services. This information is insufficient to join a phleet.
For that, one also needs to know which szgserver and which phleet user name are
being used. This information is maintained in a phleet login file, per host system
user. The login file is manipulated via the dlogin and dlogout commands. Note that
if the host system user is XXX, the phleet login file will be /tmp/szg_XXX.conf on
Unix systems and c:\szg_XXX.conf on Win32 systems.

  <pre>
  dlogin szgserver_name user_name
  dlogin IP port user_name

  In the first case, the dlogin program attempts to discover the szgserver given
  by szgserver_name by broadcasting a discovery packet on the LAN. If such
  is found, the phleet login file is written, using the given user_name.

  In the second case, the dlogin program attempts to connect to the szgserver
  using the IP/port parameters (much as a standard phleet component would using
  corresponding parameters from the login file). If successful, the phleet
  login file is written, using the given user_name.

  Note that the second case is necessary since the szgserver might not be 
  reachable via broadcast packets from the dlogin program. A good example of
  this occurs when running everything on a computer that is not connected to
  a network. The loopback address 127.0.0.1 may be the only one available in this
  case and it does not allow broadcast traffic.
  </pre>

  <pre>
  dlogout

  This command resets the phleet login file for the particular host system user.
  </pre>

  <pre>
  dwho

  Prints the phleet login file of the particular host system user in a
  human-readable form.
  </pre>

<a name="RunningSzgserver">
<p><font size=+2>Running szgserver</font>
</a>

<p>
To run szgserver, type:

<pre>
  szgserver server_name server_port
</pre>

<p>"server_name" should be a unique alphanumeric tag. "server_port" is the port on which
the szgserver will listen for TCP connection requests. All components in the Phleet
distributed system maintain a TCP connection to the szgserver via this port. This 
information is embedded in a user's login file (see below). While login can involve
explicitly stating the IP address/ port pair of the desired szgserver, there is also
an automated discovery mechanism keyed on the szgserver's name. Clients 
can discover the szgserver
by broadcasting UDP packets to port 4620. When the szgserver receives a packet on this
port containing it's name, it replies with a UDP packet, on port 4621, directed to the
origin address of the discovery packet. The reply contains the IP address and port
of the szgserver. 
<p>Note that the szgserver uses the phleet configuration file on the computer on which
it is running to determine its primary IP address, which is simply the first IP address
listed in the configuration file. This primary IP address is the one sent in 
response to client discovery requests. Consequently, the user should make sure that
this IP address is globally accessible via all computers that will be part of the
distributed system.

<a name="Connect">
<p><font size=+2>How Clients Connect to the szgserver</font>
</a>

<p>When a phleet component starts, it needs to connect to an szgserver. It will
check to see if the current host system user has a phleet login file. If not, the
component will quit, printing a message suggesting that the user must dlogin.
On the other hand, if the phleet login file exists, the phleet component will read
the IP address and port contained therein and attempt to open a TCP connection
to an szgserver using that information.

<p>As has been mentioned previously, the dlogin command creates the phleet login
file. This is either done via explicitly feeding the command an IP address/port
pair or by automatic discovery. In the automatic discovery, we just give dlogin
the szgserver's name and it will broadcast it on the LAN, searching for an 
szgserver with that name. The discovery process is described now.

<p>Broadcast a call to szgserver's out on the
LAN. All szgserver programs listen for UDP packets on port 4620. 
Clients listen for responses on port 4621. The broadcast packet has the 
following format:

   <pre>
   char name[128]  // this is either a server name or a '**', indicating
                   // that every server should respond
   char IP[32]     // unused (backwards compatibility)
   </pre>

<p>When the szgserver receives such a packet and either the name field matches
its name or contains '**', it responds to the sending IP address on port 4621
with the following packet:

   <pre>
   char  name[128]      // name of the szgserver
   char  promiscuity    // unused (backwards compatibility)
   char  IPaddress[32]  // IP address of server, in string format
   char  port[10]       // port of server, in string format
   char  name[128]      // unused (backwards compatibility)
   </pre>

<p>The timeout period during which the client will wait for a response is
2 seconds.

<a name="Szgd">
<p><font size=+2>szgd</font>
</a>

<p>The remote execution daemon szgd should run on every computer in the system for
maximum ease of use. However, as is shown in the 
<a href="QuickStart.html">introduction</a>, this is not necessary.
Only one instance may run on each host. Each instance
of szgd grabs a lock named XXX/szgd, where XXX is the name of the computer on which it
runs. As an szgd instance starts, it attempts to get this lock. If it fails, it quits
immediately.

<p>If user XXX attempts to execute a program on
a computer YYY running szgd, the szgd instance finds the value of YYY/SZG_EXEC/path
in the parameter database of user XXX and uses that as a search path for the
requested executable.

<p>For szgd to run, it is necessary for a user to successfully dlogin first. While the
Phleet identity of the user running szgd is unimportant, the dlogin process also
establishes a connection to a given szgserver, which is important.

<a name="Names">
<p><font size=+2>Names, According to the szgserver</font>
</a>

<p>The szgserver does not do name resolution of any kind. The phleet configuration
files of individual computers determine the name of that computer, as used by
phleet. When a client is communicating with the szgserver, it reads the phleet
configuration file to determine the computer's name, and transmits that to the
szgserver, which trusts the transmission.

<a name="User">
<p><font size=+2>How Do Clients Determine the Current User?</font>
</a>

<p>As the arSZGClient object initializes, it needs to determine the user. Many
communications with the szgserver are stamped with user name. Manipulations
of a parameter database (one of which exists for each user) clearly need this
information. Messages from on arSZGClient to another are also stamped with
user name. This allows, for instance, szgd daemons to execute programs in the 
manner appropriate to the user making the remote execution request, instead of
the manner appropriate to the user who started the szgd program.

<p>Note that the client needs to determine the current user via an environment
variable because of szgd. This program needs to be able to control which
user a program thinks it is executing as. For instance, user A might use
szgd to execute programs at the same time user B is using it.

<p>This is how the client determines the user:
<p><ol>
<li>First, check to see if the environment variable SZGUSER is set. If so, then
   the value is the user name.
<li>If not, determine the current user name as reported by the host system
   (which can be completely different from an Phleet user name). Use this
   user name to load a phleet login file. If the host system user name is
   XXX, then the phleet login file, on a unix system, will be /tmp/szg_XXX.conf.
   The phleet user name is read from this file.
</ol>

<a name="CommandLine">
<p><font size=+2>Command Line Tools, Organized by Functionality</font>
</a>

<p><ul>
<li>Creating and editing the Phleet configuration file
<pre>
   dname [-t] computer_name
     Sets the phleet name of the computer to the value of the computer_name
     parameter. On Win32 systems, the -t option does nothing. In that
     case, the phleet configuration file is always c:\szg.conf if a c:
     drive exists, and d:\szg.conf otherwise. In the Unix case, however,
     there are two possibilities. If -t is present, the file /tmp/szg.conf
     is altered. Otherwise, the file /etc/szg.conf is altered. 

   daddinterface [-t] network_name interface_address
     Adds a network interface to the phleet configuration file. The
     network_name parameter is a dscriptive string that is used
     to differentiate different networks. This is helpful when the
     distributed system contains multiple private networks with
     duplicate IP address ranges. The interface_address parameter is
     the IP address. The meaning of the -t option is the same as in dname.

   ddelinterface [-t] interface_name interface_address
     Deletes the specified interface from the phleet configuration file. The
     meaning of -t is the same as given in the dname section.

   dports [-t] first_port size_of_block
     Connection brokering uses a block of ports on a given machine that is,
     by default, given by 4700-4899. If this default range is unappectable
     for your installation, you can change it, for a particular machine,
     by issuing the dports command on that machine. The first port in the
     block is given by first_port and the size of the block is given by
     size_of_block. The -t option has the same meaning as in dname. 

   dconfig
     Prints the phleet configuration file. Note that, on Unix systems, if 
     /etc/szg.conf and /tmp/szg.conf are both present, the information 
     in /etc/szg.conf will be used.
</pre>
<li>Parameter database management
<pre>
   dbatch batch_file
     Set a group of database parameters at once.
     batch_file is a text file composed of two types of lines:
       i. # comment
       ii. computer_name group_name parameter_name parameter_value
           Each of which is a string. This is the way parameters are
           represented in the database.
     This command looks on a search path given by computer/SZG_SCRIPT/path
     for the batch file (always starting with the current directory).

   dget computer parameter_group parameter_name
     Display the value of the key computer/group_name/parameter_name.

   dget -a search_string
     Display all key/value pairs in the parameter database containing
     string search_string.  (For multiple-key searching, just pipe this
     through grep!)

   dset computer parameter_group parameter_name value
     Assign "value" to the item with key computer/parameter_group/parameter_name.
</pre>
<li>Process management
<pre>
   dex executable_name
   dex computer_name executable_name [args]
     Run "executable_name [args]" on computer_name,
     by requesting an sgzd on that computer to do so.
     computer_name defaults to the local host;  otherwise it is resolved
     through Phleet's internal name resolution.
     If szgd is not found, dex fails.
     On a Windows host, ".exe" is appended to executable_name.

   dkill [-9] [computer_name] executable_label
     Send a "quit" message to the first entry in the Syzygy
     process table matching the inputs.
     Like unix "kill -9", the -9 option forcibly closes sgzserver's connection
     (if a client died without szgserver realizing that its connection
     to the client is gone).

   dmsg ID message_type [message_body]
     Send a message to the process with the specified ID. Phleet messages
     have two text strings, the type (e.g., "exec") and the body (e.g.,
     "/home/randomuser/bin/linux"). The body defaults to the empty string.

   dmsg -p computer_name component_name message_type [message_body]

     Find the component, if such exists, with name component_name that is
     running on computer computer_name. Send it a message with tag 
     message_type and body message_body. If message_body is not present, 
     an empty body is sent.

   dmsg -m virtual_computer message_type [message_body]

     Find the component, if such exists, running on the master screen of
     the given virtual computer. Send it a message with tag message_type 
     and body message_body. If message_body is not present, an empty body 
     is sent.

   dmsg -s virtual_computer screen_number message_type [message_body]

     Find the component, if such exists, running on the screen indexed
     by screen_number pertaining to the listed virtual computer. Send it
     a message with tag message_type and body message_body. If message_body 
     is not presnt, an empty body is sent.

   dmsg -c virtual_computer message_type [message_body]

     Find the component, if such exists, which is currently running
     as the trigger instance of the given virtual computer. Send it
     a message with tag message_type and body message_body. If message_body 
     is not present, an empty body is sent.

   dps [search_tag]
     List all processes in the format:
       computer_name/process_name/ID
     Including the search_tag parameter lists only those lines containing it.

   dtop [d milliseconds] | q | t
     Repeated dps, like Unix "top" with pretty color coding.
     d specifies a delay (default 500).  q sets delay to 0 (cpu hog).
     t is for stress-"t"esting szgserver:  zero delay and no display.
     Hit "q" to quit (or use dkill).
</pre>
<li>User and szgserver connection management
<pre>
   dhunt
     Display all szgServer's running on the LAN, in the format:
       server_name/server_IP/server_port

     This command reads the phleet configuration file and sends an szgserver
     discovery packet out on each of the interfaces defined therein. There
     is a 2 second time-out on the discovery process for each interface.

   dlogin szgserver_name user_name
     This command takes a system user name (whatever identity the system currently
     assigns to the user) and associates it with a particular szgserver, as given
     by szgserver_name, and a particular phleet user, as given by user_name.
     This association lasts until the dlogout command is issued (by the appropriate
     system user) and, if the system user's identity is XXX, is recorded
     in /tmp/szg_XXX.conf on Unix and c:\szg_XXX.conf on Win32. A dlogin
     must occur before any syzygy programs will operate.

   dlogout
     Log out the current user.

   dwho
     Displays the mapping of the current system user to a Phleet, as
     represented by a szgserver, and a Phleet user identity.
</pre>
<li>Monitoring the operation of the system
<pre>
   dlocks
     Prints a list of the locks currently held by phleet components, along
     with their component IDs.

   dservices
     Prints a list of services currently offered by phleet components.

   dpending
     Prints a list of unfilled service requests that have been posted by
     phleet components.
</pre>
</ul>
<a name="Message">
<p><font size=+2>How Clients Message Each Other (via szgserver)</font>
</a>

<p>Components of the distributed system need to message each other from time to time.
For instance, the "dex" command sends a message to an szgd, which causes szgd to
launch the requested executable. Furthermore, a component can receive a "kill" or
a "reload" message, causing it to take appropriate action. Note that some messages
need to have responses to be meaningful. For instance, the "dex" command must be
able to report any trouble launching the requested executable and even information
from the executable's initialization. 

<p>For reliability, the right to respond to a message (that requires a response) must
be owned by a particular component. If that component drops out of the Phleet, the
szgserver can then easily notify the message-sending component that an error has
occured and that it will never receive a response. Unfortunately, this rule needs to
be somewhat bent to enable the "dex" command's right to respond to an execution
message to be passed on to the launched executable. In this case, szgd indicates to 
the szgserver it wants to trade its right of message response to any phleet 
component making a trade request with an appropriate key. The launched executable is
able to make such a request, and thus is able to respond to the original launch
message.

<p>We now outline the records in the Phleet protocol that pertain to messages.

    <pre>
    "SZG Message"
      int[]  "ID";      // the message's ID
      int[]  "Response"; // 0 if no response is desired, 1 if response is
                         / desired
      char[] "User";    // the user who sent the message. 
      char[] "Type";    // the type of the message, like "quit", "reload", etc.
      char[] "Body";    // additional information
      char[] "Context"; // is this message being sent as part of the operation of a 
                        // virtual computer
      int[]  "Destination"; // the Phleet ID of the message's destination
    </pre>

    <pre>
    "SZG Message Admin" // this is a catch-all record that serves several functions
      int[]  "ID";      // if the admin record is about a particular message, the
                        // ID is filled-in here
      char[] "Status";  // status code, "SZG_SUCCESS", "SZG_FAILURE", or 
                        // "SZG_CONTINUE"
      char[] "Type";    // the command type. "SZG Response",
                        // "SZG Trade Message", "SZG Message Request", "SZG Revoke Trade"
      char[] "Body";    // additional information, if necessary
    </pre>

    <pre>
    "SZG Message Ack"   // used by the szgserver to acknowledge the various 
                        // communications above
      int[]  "ID";      // used to inform the client of a particular message ID
      char[] "Status";  // status code, "SZG_SUCCESS" or "SZG_FAILURE"
    </pre>

<p>We now examine the variations within the "SZG Message Admin" record, as
differentiated by the "Command" field.

<p>"SZG Response": The response to the client's message. The "Status" field tells
whether or not this is valid (for instance, the phleet component owning the right to
respond could have died, in which event, an "SZG Response" would be sent (by the
szgserver) with
"Status" set to "SZG_FAILURE". The "Body" field gives the text of the response.
The "ID" field gives the message ID for which this response is intended. Note that
components are allowed to send partial responses to messages (as may be desirable if the
full message response will take a very long time). In this case, the "Status" field
is set to "SZG_CONTINUE".

<p>"SZG Trade Message": The "ID" field identifies the message of which we are trying
to relinquish ownership. The "Body" field gives the key upon which message trading 
hinges.

<p>"SZG Message Request": The "Body" field is the key with which the client requests
a new message. 

<p>We now construct various scenarios in the use of Phleet messaging.

<p>Message sent, no response required: The simplest scenario. szgserver receives
the message, fills in the ID with the next available message ID, and routes it
to the component with the given destination ID. (note that upon receipt of the
message, the szgserver returns an "SZG Message Ack" containing the message's ID)
The component receiving the message then processes the
message using a callback registered with its arSZGClient. Nothing is ever registered
with the szgserver's internal data storage.

<p>Message sent, response required: Upon receipt of the message, the szgserver fills 
in the ID field with the next available message ID. Next, it returns an 
"SZG Message Ack" record containing the message's ID.
In this way, the sending component can send several messages before getting a single
response and still be able to distinguish which response corresponds to which
message. The szgserver then registers the message ID
with the destination component. The destination component is now able to respond to
that message. The message is then routed to the destination. 
If the destination component leaves the
Phleet before delivering its response, the szgserver sends a record as below to the
originating component:

    <pre>
    "SZG Message Admin"
      int[] { <original message ID> };
      char[] {"SZG_FAILURE"};
      char[] {"SZG Response"};
      char[] {""};
    </pre>

<p>Response sent: Upon receipt at the szgserver of the "SZG Message Admin" record
with type "SZG Response", the
szgserver sees if the component is allowed to respond to the message with the ID. 
If so, it looks up the Phleet ID
of the component owing the message response (which might be different than the
component that actually sent the message in the first place). The response is sent to
this component. The next action depends on the content of the "Status" field. If this
field is set to "SZG_SUCCESS", the entry keyed to the message ID is removed from the table.
On the other hand, if the field is set to "SZG_CONTINUE", the message ID is not removed.
In either case, an "SZG Message Ack" is sent to
responding component, with status "SZG_SUCCESS". On the other hand, if the responding
component does not own the right to respond to the message, an "SZG Message Ack" 
with status "SZG_FAILURE" is sent to the
responding component.

<p>Message response ownership passed to a new component: The receiving component
may decide that it wishes to pass message response ownership to a new component.
The best example of this is with szgd wanting to pass ownership of the execution
message to the spawned process. The receiving component can send an "SZG Message Admin" 
record with type "SZG Message Trade" to the szgserver in order to indicate 
its willingness to relinquish right to
respond to a given message to a new component (as determined by a string key).
This key includes information about the user and the virtual computer.
For instance, if the component run by user "XXX" on host "YYY" and in the context
of virtual computer "cube" wants to
trade a message under the name "foo", the key will then be: "XXX/YYY/foo/cube". Note that
in the particular case of szgd, "foo" will be the name of the launched component. 
The szgserver maintains a table mapping keys to the IDs of the 
components which can respond to those messages. Each component furthermore has a map
associating keys it has posted with message IDs associated with them. These data
structures are now updated.
Next, the new component then sends an "SZG Message Admin" record with 
type "SZG Message Request"
to the szgserver, asking for ownership of
the message with key "XXX/YYY/foo/cube" (as in the previous example). An 
"SZG Message Ack" record is sent back to the
new component. The "Status" field indicates whether it has received ownership of the
message. If so, the "ID" field indicates the ID of the original sending component. Also,
in this case, a "SZG Message Ack" record is returned
to the original receiving component. The global szgserver and component-specific data
structures mentioned above are suitably updated.  

<a name="MessageMethod">
<p><font size=+2>arSZGClient Methods Associated with Messaging</font> 
</a>

  <pre> 
  int arSZGClient::sendMessage(const string& user, const string& type,
                               const string& body, const string& context,
                               int destination, bool responseRequested);
  
  Generates an "SZG Message" with the given parameters. Blocks until it receives
  a reply from the szgserver with the message's ID (or until the szgserver connection
  goes away). Returns 0 on failure and otherwise the message ID assigned to the
  message by the szgserver. NOTE: this means that szgserver message IDs must be strictly
  positive.
  </pre>

  <pre>
  int arSZGClient::getMessageResponse(const string& body, int& messageID);

  Returns 0 on failure, 1 if we've receive a final response to the message, and
  -1 if we've received a partial response to the message.  Note that this allows 
  long duration computations or initializations to be gradually streamed back to 
  the original message sender. The parameter "body" is filled-in with the "Body" 
  field of the "SZG Message Admin" record. The parameter "messageID" is filled-in
  with the ID of the message for which this response is intended.
  </pre>

  <pre>
  bool arSZGClient::messageResponse(int messageID, const string& body,
                                    bool partialResponse);

  Attempts to send a message response to the given message ID and with given body.
  The parameter "partialResponse" is optional (default is false). If it is set to
  false, this is the only response that can be expected to the message. If it is
  set to true, more responses will be forthcoming. Returns false if the response is 
  undeliverable. And true otherwise.
  </pre>  

  <pre>
  bool arSZGClient::startMessageOwnershipTrade(int messageID, const string& key);

  Sends an "SZG Message Admin" record with type "SZG Trade Message"
  to the szgserver. If the command is issued by a component run by user "XXX" on host 
  "YYY" as a part of virtual computer "cube", the sent key will be [key] (in distinction 
  to requestMessageOwnership(...) below). Returns true if the send succeeds and the 
  component has the right to trade this message. False otherwise (as, for instance, 
  if the given key has already been taken).
  </pre>

  <pre>
  bool arSZGClient::finishMessageOwnershipTrade();

  Waits on notification that a pending message ownership trade has occured.
  Returns true if the record receive succeeds. Returns false otherwhise.
  </pre>

  <pre>
  bool arSZGClient::revokeMessageOwnershipTrade(const string& key);

  Attempts to revoke a pending message-ownership trade. Note that we have to give the key
  in a fully-explicit fashion. Returns true if the revocation
  was successful and false otherwise. Several conditions might cause a message ownership
  trade to fail. Specifically, another component might have already completed the
  trade or our component might not have the right to revoke the trade.
  </pre>

  <pre>
  int arSZGClient::requestMessageOwnership(const string& key);

  Requests ownership of message with key "XXX/YYY/<key>/cube" (where "XXX", "YYY",
  and "cube" are as above). Note how the arSZGClient automatically fills-in the data,
  based on its internal state, in distinction to startMessageOwnershipTrade(...) above.
  Returns 0 if this fails and otherwise the ID of the message to which the client now 
  owns the response rights.
  </pre>

<a name="Lock">
<p><font size=+2>The Operation of Locks in Phleet</font>
</a>

<p>Phleet needs locking mechanisms for normal operation. An example of the need for
OS-level locks is found in the launching of an application, which needs to be atomic,
even though it may involve significant operations on components in the distributed
system. Locks can be implemented, in a primitive way, by using database variables,
since there is support for atomic test-and-set. However, this method is insufficient.
Locks should be owned by components so that they are released on that component's
removal from the distributed system.

<p>Consequently, Phleet maintains a lock table. Each lock is named. The name is a key
to the lock table, in which is stored the ID of the component owning the lock. When
a component sends an "SZG Lock Request" to the szgserver, the szgserver checks to
see if another component owns the lock. If so, it sends the originating component a
response (an "SZG Lock Resonse" record) indicating that another component owns the
lock, and giving that component's ID. If not, it sends the originating component a 
message indicating that it now owns the lock. Appropriate modifications are made to
the lock table plus the component's data structure that records the resources it owns.
Specifically, each component maintains a list of locks it owns. When the component
leaves the phleet, these are removed from the global list of held locks.

<p>When the component wants to release a lock it owns, it sends an "SZG Lock Release"
to the szgserver. The szgserver checks to see if the sending component does, in fact,
own the lock. If so, it releases it and sends an "SZG Lock Response" back with 
"Status" field set to "SZG_SUCCESS". Otherwise, the lock remains unreleased and the
szgserver returns an "SZG Lock Response" with "Status" field set to "SZG_FAILURE".

<p>IMPORTANT NOTE: There is currently no way to *wait* until a lock can be grabbed
by the requesting component. A feature to be added (i.e. in some situations it might be
nice to have a getLock(...) call that blocks until the lock is available, which is
the usual semantics of pthreads locks. However, this functionality is not needed for
cluster application launching, so it is put off for a future realease.

    <pre>
    "SZG Lock Request"
      char[] "Name"; // the name of the lock we are requesting
    </pre>

    <pre>
    "SZG Lock Release"
      char[] "Name"; // the name of the lock to be released
    </pre>

    <pre>
    "SZG Lock Response"
      char[] "Name";      // the name of the lock that was requested
      char[] "Status";    // "SZG_SUCCESS" if the lock has been gotten
                          // "SZG_FAILURE" if not gotten
      int[]  "Owner";     // the Phleet ID of the component owning the lock currently
                          // -1 if no component owns it.
    </pre>

    <pre>
    "SZG Lock Listing"
      char[] "Locks";      // a slash-delimited list of the locks names in the system
      char[] "Computers";  // a slash-delimited list of the computers holding those locks
      int[]  "Components"; // an array containing the IDs of those components
    </pre>

    <pre>
    "SZG Lock Notification"
      char[] "Name";   // upon the release of this named lock, we wish to be notified
    </pre>
      

<p>Note that this scheme also handles Phleet resource reservation. A
component can hold a lock on a particular resource in a virtual computer
(like a graphics screen). If a new component wants that resource, it can
try to get the lock. On failure, it learns of the ID of the component holding the 
lock. A kill message can then be sent to that component to free the resource.

<a name="LockMethod">
<p><font size=+2>arSZGClient Methods Associated with Locks</font>
</a>

  <pre>
  bool arSZGClient::getLock(const string& lockName, int& ownerID);

  Returns true if the component now holds the lock (and fills ownerID with -1).
  Otherwise, it returns false and fills ownerID with the ID of the component that does, 
  in fact, own the lock. Note that this allows us to send a "kill" message to the 
  component in question, which will cause the lock to be freed. Note that this is
  a nonblocking call.
  </pre>

  <pre>
  bool arSZGClient::releaseLock(const string& lockName);

  If the component does not currently hold the lock, this call returns false.
  If the component holds the lock, the lock is released and the call returns true.
  </pre>

  <pre>
  bool arSZGClient::requestLockReleaseNotification(const string& lockName);

  Uses a "SZG Lock Notification" record to request that a record of the same
  type be returned upon release of a given lock. Returns whether the request
  succeeded.
  </pre>

  <pre>
  string arSZGClient::getLockReleaseNotification();

  Waits for a "SZG Lock Notification" record to be sent to the client. When
  such is received, it prints out the name of the lock that was released.
  </pre>

<a name="Brokering">
<p><font size=+2>Connection Brokering in Phleet</font>
</a>

<p>In previous Syzygy versions, components offering services did so on IPs/ports fixed by 
parameters stored in the szgserver's database, as did components requesting services.
This is inadequate in several ways. First, it fixes connections based on the computers
on which components run, implying that a component running on computer A will always
connect to another component running on computer B. Second, this was 
the only information in
the parameter databases used with previous syzygy versions that could not be given
sensible defaults, consequently increasing set-up complexity. Third, it introduces a
common source of errors: why won't component A connect to component B?

<p>Syzygy now uses the szgserver as a connection broker. Roughly speaking, when a 
component becomes available as a data source, it registers itself with the szgserver,
using a tag. The szgserver responds with a port on which it can listen for connection
requests. All internet-based Syzygy services now bind to INADDR_ANY. This increases 
flexibility as, often, a service providing component will want to drive components
on multiple IP networks. The client chooses the network on which the connection occurs.
When a client wants to establish a connection to a Syzygy service, it contacts the
szgserver with the tag describing the service to which it wants to connect. If the
tag exists in the szgserver's internal store, the server returns network(s) and a port
number of which the service is accessible. The client can then connect directly to the
service via a network of its choice. A more detailed exlanation of the process follows.

<p>Here are the record types in the Phleet protocol used to deal with connection 
brokering.

    <pre>
    "SZG Register Service"
      int[]  "Match"      // arequest ID generated by the arSZGClient and echoed by
                          // responses from the szgserver. Used to allow services
                          // to register themselves in mutliple threads.
      char[] "Status";    // SZG_SUCCESS, SZG_FAILURE, or SZG_RETRY
      char[] "Tag";       // a string indicating the service's identity
      char[] "Networks";  // a slash-delimited string listing human-readable identifiers
                          // for the various networks on the originating box
      char[] "Addresses"; // a slash-delimited string listing the addresses of the
                          // computer's interfaces on the above communications networks,
                          // in the same order as the networks themselves appear
      int[]  "Size";      // some services may require a block of ports upon which
                          // to operate, this indicates the number of ports required
      char[] "Computer";  // the name of the computer on which the service will run
      int[]  "Block";     // a pair of numbers indicating the starting port and the size
                          // of the port block as defined in szg.conf. This can change
                          // over time, so each record attempting to register a service
                          // contains it
      int[]  "Port";      // in the case of SZG_RETRY, we are letting the szgserver
                          // know we were unable to bind to a port in this array
    </pre>

    <pre>
    "SZG Request Service"
      char[] "Computer";  // the computer on which the service request occurred
      int[]  "Match";     // a request ID generated by the arSZGClient and echoed by
                          // responses from the szgserver. Used to allow service
                          // requests from multiple threads.
      char[] "Tag";       // a string indicating the identity of the requested service
      char[] "Networks";  // a slash-delimited string listing human-readable identifiers
                          // for the various networks on which the client can communicate
      char[] "Async";     // either SZG_TRUE or SZG_FALSE. If SZG_FALSE, the szgserver
                          // will immediately respond with a failure message if the
                          // requested service has yet to be registered. If SZG_TRUE,
                          // the response will wait until registration has occured.
    </pre>

    <pre>
    "SZG Broker Result"
      int[]  "Match";     // Allows the response to be routed to the right thread.
      char[] "Status";    // SZG_SUCCESS or SZG_FAILURE
      char[] "Address";   // If this responds to an "SZG Request Source" record and
                          // the "Status" field is SZG_SUCCESS, then this will be the
                          // address to which it should connect to the service
      int[]  "Port";      // This can either be the array of ports assigned by the 
                          // szgserver to the service or the array of ports to which the 
                          // client will connect, depending on whether this is a 
                          // response to "SZG Register Source" or "SZG Request Source"
    </pre>

    <pre>
    "SZG Get Services"
      char[] "Services";   // Returns a semi-colon delimited list of the running services
                           // managed by this szgserver (or conversely the pending service
                           // requests). note that the list must be
                           // semi-colon delimited since service names may contain slashes
      char[] "Type";       // Are we asking for registered services or requests for a 
                           // service that have yet to be fulfilled?
      char[] "Computers";  // Returns a slash-delimited list giving the computers on which
                           // the services are running (or, conversely the computers on
                           // which the components requesting the services are running)
      int[]  "Components"; // the IDs of the components offering the services (or 
                           // conversely the IDs of the components whose service requests
                           // have yet to be fulfilled).
    </pre>

    <pre>
    "SZG Service Release"
      char[] "Name";       
      char[] "Computer";
    </pre>

<p>There are two commands relating to services. It allows the user to see a listing of 
all services currently offered.

    <pre>
    dservices

    Prints a listing of all services currently offered. This command works by sending
    the szgserver an "SZG Get Services" record with a blank "Services" field, receiving
    in return an "SZG Get Services" record with a "Services" field filled with a
    semi-colon delimited list of service names that are currently posted to this
    szgserver.
    </pre>

    <pre>
    dpending

    Prints a listing of all service requests that have been posted, but not yet
    fulfilled.
    </pre>

<p>A description of the way a component can register its service follows.
<p><ol>
<li>A component has a service type, such as SZG_GEOMETRY, SZG_SOUND,
SZG_INPUT0, SZG_INPUT1, etc. 
Master/slave applications have a service type given by their name (after all,
different master/slave apps form unique service classes). The tag with which the
service is registered depends on the method via which the service was launched.
For instance, if an SZG_GEOMETRY service is launched in the context of virtual computer
cube, the tag will be NULL/SZG_GEOMETRY/cube. On the other hand, if the same service is
launched by user foo, but not on a virtual computer, the tag will be
foo/SZG_GEOMETRY/NULL.
<li>The component sends an "SZG Register Source" record to the szgserver, with "Tag" field
containing the tag determined in the previous step and with "Status" field set to 
"Try". The "Networks" field contains a slash delimited list of the interfaces available
to the computer For instance, if the computer is connected to the internet and the cube
private network, The "Networks" field will be set to "internet/cube". The
"Addresses" field will contain field will contain a slash-delimited list of the 
IP addresses of
the computer's several interfaces, in the same order as their descriptive names.
Since multiple private networks in an installation can contain the same IP addresses,
the network names cannot be infered from the IP addresses. The "Size" field
indicates the number of ports required for the service. Some services, like SZG_GEOMETRY
and SZG_SOUND, require more than one port. Finally, two fields contain configuration
information about the computer on which the component resides. The "Computer" field 
gives its name, which is important since the various lists of ports outlined below are
stored on a per-computer basis. The "Block" field defines the port range the computer
has reserved for syzygy services. Note that this port range can, in fact, change. 
Mechanisms for dealing with such are outlined below.
<li>Upon receipt, the szgserver checks to see if
there is another component already offering this service. If so, an "SZG Broker Result"
record is returned, with the "Status" field marked "SZG_FAILURE". 
<li>If not, the szgserver checks to see if the block of ports given in the
"SZG Register Source" record is the same as a previously stored block, if any. If no
block of ports has been previously stored (i.e. this is the first time in the szgserver's
lifetime that a component has tried to register a service from that computer), the
various ports lists (available, temporary, and used) are initialized for that computer.
If a block of ports has already been defined for that computer and the new block is the
same (the common case), we do nothing. On the other hand, if the block of ports defined
in the "SZG Register Source" record is different than that already reserved, action needs
to be taken. The old available ports list is removed, and is replaced with the new block,
minus those ports which already appear on the temporary or used lists for the computer
in question (the lists can in fact overlap).
<li>Now that the szgserver has adjusted its various ports lists, it checks 
its list of ports available for use on the computer on which the component is
running. It picks the first ports on the list (up to the number of ports requested), 
marks the "Status" field as "SZG_SUCCESS",  and
stores the port number(s) in the "Port" field, returning the "SZG Broker Result" record
to the requesting component. The port number(s) are then removed from the available list
and are placed on the temporary list (but not yet on the used list) associated with that
computer. The tag is placed on the list of temporary tags.
<li>The component now receives the port number(s) and attempts to bind listening sockets
to them, as appropriate, using INADDR_ANY. 
Please note that the socket option for reusing addresses
is set to false. Consequently, if a server is not shut down cleanly, it will be a few
seconds before a new server can bind to that port. It may thus be
possible that the bind can fail, especially if some of the port range specified for the 
syzygy components on the given computer overlaps with active servers corresponding to
other types of software. 
<li>If any of the binds fail, the component sends a new "SZG Register Source"
record to the szgserver. This time, the "Status" field is set to "Retry" and the 
offending port number(s) are included in the "Port" field. 
The szgserver then moves the port
number(s) from the temporary list to the end of the available list, after making sure
that the component sending the record does, in fact, own the ports in question. 
Recall that the port(s)
might just be temporarily unavailable, and, since the port list ideally contains 100 or
200 entries, it will not be tried again for a significant amount of time. The szgserver
then sends a new "SZG Broker Result", as above. To avoid a potential infinite loop,
the number of retries is arbitrarily limited to 10, which should be sufficient given
a port list of size comparable to that mentioned above. 
<li>If the bind succeeds, the component sends an "SZG Register Source" record back
to the server with "Status" field set to "SZG_SUCCESS" and the "Port" field containing the
IDs of 
the used port(s). The szgserver then removes the port number(s) from the temporary list and
transfers them to the used list, making sure that the component in question does in fact
own those ports. The tag is then removed from the temporary tag list
and placed on the used tag list.
<li>Note: in addition to global temporary and used lists, the szgserver maintains these
lists on a per component basis (along with the computer name where the component is
running), keyed on the component's ID. This allows the szgserver
to automatically return these ports to the available list when a component 
exits if they are still within the computer's designated ports block.
The same hold true for
tags, though in this case it is unecessary to include computer name, since, unlike port
numbers, the tags are globally unique.
</ol>

<p>A description of the way a component connects to a registered data source follows.
<p><ol>
<li>The component forms a service tag as above. It then sends an "SZG Request Source" 
with the "Tag" field containing the tag, the "Networks" field containing a slash-delimited
string of possible networks, with the prefered network listed first.
<li>The component blocks until a response occurs from the szgserver. This is OK since
all of szg's connection attempts occur in seperate connection threads.
<li>When the szgserver receives an "SZG Request Source" record, it first checks to see
if there is a matching tag which has succeeded in registering itself. If not, it saves
the request in a pending connection queue.
<li>On the other hand, if a matching tag has succeeded in registering itself, the 
"Networks" field of the "SZG Request Source" record is compared with the networks
associated with the tag, and the best match, if any, is found. An "SZG Broker Result" 
record will be returned to the requesting component. If no network match was found,
the "Status" field will be set to "SZG_FAILURE", otherwise it will be set to "SZG_SUCCESS".
The "Port" field contains the port number(s) and the "Address" field contains the
IP address of the server. When the client receives this, it issue a connect call on the 
the given IP/port pair(s).
<li>As data sources are successfully registered, they check the pending connection queue, 
responding to each matching tag, as above (and removing them from the pending connection
queue).
<li>The pending connection queue, is maintained on a per-component basis, in addition
to being maintained globally, so that, when a component leaves the system, its
pending connections can be removed from the system.
</ol>

<a name="BrokeringMethod">
<p><font size=+2>arSZGClient Methods Associated with Connection Brokering</font> 
</a>

<pre>
  bool arSZGClient::registerService(const string& serviceName, const string& channel,
                                    int numberPorts, int* portIDs);

  Means by which a component starts offering a service for connection brokering. The
  channel determines the networks upon which the service will be offered. Specifically,
  this parameter my be one of "default", "graphics", "sound", or "input", and it
  allows these different services to use different physical networks, if such exist.
  The number of ports needed by the service is given by the "numberPorts"
  parameter, and the "portIDs" parameter provides storage into which the assigned
  ports for the service can be stuffed. This function returns "true" excatly when
  it is successful.

  bool arSZGClient::requestNewPorts(const string& serviceName, const string& channel,
                                    int numberPorts, int* portIDs);

  It could be that the service cannot use the ports successfully retrieved from
  the "registerService" call. In this case, the service can request the
  assignment of new ports, at the same time telling the szgserver that it was
  unsuccessful in using the previously assigned ones.The meaning of the parameters
  is the same as in "registerService", except that, in this case, the caller passes
  the old, problematic ports in inside the "portIDs" array. This function returns 
  "true" exactly when it successfully communicates with the szgserver and receives
  a set of new ports (in the "portIDs" array).

  bool arSZGClient::confirmPorts(const string& serviceName, const string& channel,
                                 int numberPorts, int* portIDs);

  The service must inform the szgserver that it is, in fact, able to use the
  assigned ports. The meanings of "serviceName", "channel", and "numberPorts"
  are the same as above. The ports that the service successfully bound are
  passed in via "portIDs". Returns "true" exactly when it successfully
  communicates with the szgserver and that program is able to put the
  mentioned ports on the list of used ones.

  arPhleetAddress arSZGClient::discoverService(const string& serviceName,
                                               const string& networks, bool async);

  A component wishes to connect to a service running somewhere in the distributed
  system. The component mentions the name of the service to which it wishes to
  connect ("serviceName"), gives a slash-delimited list of networks (using symbolic
  names) upon which it would like to communicate to the service ("networks"),
  and specifies whether the "discoverService" call itself should be blocking or
  nonblocking with the final parameter, "async". If "async" is set to "true" and the
  requested service is not currently registered with the szgserver, the szgserver
  will immediately make a failure response and "discoverService" will return an
  invalid arPhleetAddress. If "async" is set to "false" and the requested service is
  not currently registered with the szgserver, the szgserver will make no response
  until the service is in fact registered. In this case, the call to "discoverService"
  will block. Overall, if the call fails, an invalid arPhleetAddress is returned,
  If the call succeeds, a valid arPhleetAddress is returned, containing an IP 
  address and a sequence of ports to which the component can connect.

  bool arSZGClient::requestServiceReleaseNotification(const string& serviceName);

  Requests that the szgserver send us a notification when the named service is no
  longer held by the system. Returns "true" if the szgserver has successfully 
  received the request and false otherwise. This is useful in allowing high
  availability services. When a service goes away, another component able to offer
  the service can be notified.

  string arSZGClient::getServiceReleaseNotification();

  Block until a service release notification has been received from the szgserver.
  When one has been received, return the name of the service that has been 
  released.

  void arSZGClient::printServices();

  Prints the services which are currently being offered in the distributed system.

  void arSZGClient::printPendingServiceRequests();

  Prints the service requests that have yet to be met in the distributed system.

  int arSZGClient::getServiceComponentID(const string& serviceName);

  If the named service exists, return the ID of the component offering it. If not,
  return -1. This is useful when a new component must offer a service, even to the
  extent of killing off a previous component offering the same service.
</pre>
</body>
</html>
