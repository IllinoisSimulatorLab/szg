<html>
<head>
<title>Syzygy: Shared World Tutorial</title>
</head>
<body bgcolor="#ffffff">
<a href="index.html">Documentation Index</a>
<p><font size=+2>Syzygy: Shared World Tutorial</font>

<p>This tutorial will inreoduce you to the concept of peer-to-peer
reality. To work along with the examples, you'll need to either have 
compiled the <a href="GettingSoftware.html">szg library</a> and the Syzygy
<a href="PySZG.html">Python bindings</a> or have installed a Syzygy SDK as
appropriate for your system.

<a name="Peer">
<p><font size=+2>Graphics Peers: Tutorial Set Up</font>
</a>

<p>This tutorial shows how to use the arGraphicsDatabase and its arGraphicsPeer
subclass from the Python prompt. If you want to be able to display your
work, you will want to use the arGraphicsPeer, so we focus on that.

<p>First, note that you must be running in Phleet mode, as explained in the
<a href="PhleetIntro.html">introductory</a> chapter of Syzygy's distributed
OS. Next, for connection brokering to work, you will have to be dlogin'ed
as the same Phleet user in each machine in your test environment.

<p>You will want to use the Python module rp.py (rp = reality peer). This
will provide you will some functionality needed to manipulate the system, and
it should be on your PYTHONPATH. It imports the Syzygy python bindings.
Start a Python prompt and then type:

<pre>
  from rp import *
  peer.setName("peer")
</pre>

The name "peer" must be unique in the Phleet across all graphics peers owned
by the Phleet user. Next,

<pre>
  peer.init({"peer_name"])
</pre>

The "peer_name" is simply a descriptive term used for this peer. If this
succeeds, you will see a "1" returned. Now type "dps()". You should see, among
other lines, something like:

<pre>
  smoke/peer_name/16
</pre>

Finally, you must do the following at the Python prompt:

<pre>
  peer.start()
</pre>

If it succeeds, it will return a "1".

<p>Now, you will start up a graphical "workspace" which can host a number of
graphics peers. This workspace can be run on any computer in your Phleet, but
beware that you must be dlogin'ed as the same Phleet user to connect. The
"workspace" must be given a name via the command line that is different from
any other workspace name used by that Phleet user.

<pre>
  szg-rp work1
</pre>

If all goes well, a graphics window will appear. You now need to create a peer
within your workspace and connect the two peers together. At the Python
prompt,

<pre>
  m = rpManager()
  work1 = m.getWorkspace("work1")
  handle = work1.newPeer("target")
</pre>

Please note that the name ("target") you give to the new peer must be unique
across all the peers you create as a particular Phleet user. If it isn't, the
final command will fail and you will see the following error message:

<pre>
  workspace error: peer failed to be created.
</pre>

The variable "handle" is a remote manipulation interface for the created
peer. It is of Python type rpPeer and has several methods that will be useful.

<pre>
  translate(x, y, z)

    Translates the peer within the workspace. This is useful for getting
    your content viewable by the workspace camera. This camera has the
    following characteristics:

    near clip plane, x extent = (-0.1, 0.1)
    near clip plane, y extent = (-0.1, 0.1)
    near/far clip plane distance = (0.2, 200)
    camera position = (0,5,20)
    pointed at = (0,5,0)
    up direction = (0,1,0)

  setComment(comment)

    Stores comment text in the remote peer.

  getComment()

    Retrieves comment text from the remote peer.

  reset()

    Clears the remote peer.
</pre>

Go ahead and put the display peer (in the remote workspace) in an easily
viewable spot. You will use the remote access handle.

<pre>
  handle.translate(0,5,-5)
</pre>

Finally, you will want to connect your peers, local and remote together, and
set data flowing between them. Use the local peer for this.

<pre>
  peer.connectToPeer("target")
</pre>

This returns the connection ID on success and -1 otherwise. Since this is
your first connection from "peer", you should see "0". By default, no
information flows on the connection between peers. Lets make the information
flow both ways.

<pre>
  peer.sending("target",1)
  peer.receiving("target",1)
</pre>

Upon success with each command, you should see a "1". You have just ensured
that updates to your local peer will be copied to the remote peer in the
workspace and vice versa. Please note that it is
possible to turn off sending or receiving of scene graph updates at any time
as above (passing "0" will turn it off). Please note that the connection is
referenced by the connected-to peer's name (in this case "target").

<p>The arGraphicsPeer has two other methods of particular importance. These
are useful when one of the peers that connect already has geometry.

<pre>
  arGraphicsPeer::pullSerial(remoteName, receive)

    Get the the description of the connected remote peer and put it into
    the local peer. If the receive flag is "1", continue receiving updates
    on the connection.

  arGraphicsPeer::pushSerial(remoteName, send)

    Push our own description to the connected remote peer. If the send
    flag is "1", continue sending updates.
</pre> 

<p>Now you can manipulate the scene graph contained in "peer" from the 
Python prompt and have the results appear in your workspace. Please note
that this section has just scratched the surface of all the fun things you
can do with reality peers.

<p><ul>
<li>You can have multiple peers embedded in each workspace. A common workspace
displayed on a projector might show the work of several users simultaneously.
<li>Instead of connecting to a peer in a workspace, you can connect to a
peer at someone else's Python command prompt. In this way, you can collaborate
it building an object.
<li>Two users can connect to the same peer in a workspace, collaborating that 
way.
</ul>

<hr>
</body>
</html>