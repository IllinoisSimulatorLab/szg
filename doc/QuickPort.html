<html>
<head>
<title>Syzygy Quick Start for porting a GLUT application</title>
</head>
<body bgcolor="#ffffff">
<a href="index.html">Documentation Index</a>
<p><font size=+2>Syzygy Quick Start for porting a GLUT application</font>

<p>
Many GLUT applications can be easily turned into Master/Slave applications.
A first step is creating a build environment that is compatible with Syzygy.
The final section of the <a href="Programming.html">programming guide</a>
addresses this issue.

<p>
For some examples of Master/Slave applications see the "Application Peers"
section of the <a href="ExampleCode.html">Example Code</a> page, many of these
applications were originally written using GLUT but have been ported to the
Master/Slave framework.  The source code of these applications is available in
the src/demo directory of the Syzygy
<a href="http://www.isl.uiuc.edu/szg/SyzygyDownload.html">source distribution<a/>.

<p>
Here is a general overview of the steps necessary to do a quick and dirty port:
<p>
In the source file containing main(),
<ul>
<li>
  <pre>
  #include "arMasterSlaveFramework.h"
  </pre>
</ul>

In main(),
<ul>
<li>
  <pre>
  arMasterSlaveFramework framework;
  if( !framework.init( argc, argv ) ) {
    return 1;
  }

  framework->setStartCallback( ... );
  framework->setWindowStartGLCallback( ... );
  framework->setPreExchangeCallback( ... );
  framework->setDrawCallback( ... );
  framework->setKeyboardCallback( ... );
  ...
  </pre>

<li>
  Application specific initialization should go into the start callback
  demanded by the framework.  OpenGL state initialization should go into the
  WindowStartGL callback. The user-defined application start callback is called
  once in the body of the framework's start() method (which does not return)
  while the WindowStartGL callback is called once upon each window creation.
<li>
  Sometimes computations and data exchanges need to occur before
  the scene is drawn. Computations whose results need to propagated from
  master to slave should occur in the framework's preExchangeCallback(...),
  which occurs before the data sharing exchange between master and slaves.
  These computations might, for instance, transform input events into
  navigational information. On the other hand, if each slave bases its
  actions on the next input event, then work might occur in the
  postExchangeCallback(...), which occurs after the data sharing exchange
  between masters and slaves.
<li>
  Please note that only the master does the preExchange during an event loop,
  while the master and all slaves connected to a master do the postExchange.
  Unconnected slaves do not do the postExchange.
<li>
  The user-defined display callback should go into the draw callback of the
  framework.  This, and the WindowStartGL callback should be the only two
  places in the application where OpenGL calls are made.
<p>
<li>
  After the framework has been initialized and all necessary callbacks
  registered, the event loop needs to be set in motion:
  <pre>
  if( !framework.start() ) {
    return 1;
  }

  // not reached, start() does not return
  </pre>

<li>
  If framework.start() is called from another thread, at the end of main do
  <pre>
  while( true ) {
    ar_usleep( 1000000 );
  }
  </pre>
  so that the application doesn't immediately terminate.
</ul>

<p>
If the application needs to control the event loop (and window creation)
itself, the framework can be started as follows:
<pre>
  if( !framework.startWithoutWindowing() ) {
    return 1;
  }

  // this is reached, startWithoutWindowing <b>does</b> return
</pre>

<p>
Thereafter, you need to invoke the framework's preDraw() method before drawing
and the postDraw() method after drawing but <i>before</i> buffer swapping.

<p>
General issues with the framework:
<ul>
<li>
  Do not use GLUT commands to manipulate the OpenGL window(s). Let Syzygy handle
  that itself.  If the application needs to be informed of window events (such
  as a resize, move, or close) the framework's WindowEvent callback can be used
  to get access to such events.
<li>
  You can have access to keyboard events if you set a keyboard callback.
  Otherwise, you will not get these events, and, in general, you will not have
  access to mouse events. Instead you should use Syzygy's event processing (of
  VR-style events, matrices, joystick-type events, etc.)
</ul>

</body>
</html>
