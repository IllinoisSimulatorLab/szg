<html>
<head>
<title>Myriad Scene Graph</title>
</head>
<body bgcolor="#ffffff">
<a href="index.html">Documentation Index</a>
<p><font size=+2>Myriad Scene Graph</font>

<p><img src="images/SceneGraphIntro.jpg" width=500 height=392>

<p>This section gives a general introduction to the Myriad scene graph and
explains its C++ API. For a description of the (similar) Python API, please
see this <a href="SceneGraphTutorial.html">tutorial</a>. There are several
scene graph examples in Python:

<p><ul>
<li><a href="python/particle-shape.py">particle-shape</a>: A particle system
using some of the built-in shapes.
<li><a href="python/lorenz.py">lorenz</a>: A visualization of the lorenz attractor.
<li><a href="python/cosmos.py">cosmos</a>: Translation of the cosmos C++ demo into
Python.
<li><a href="python/simpleviz.py">simpleviz</a>: Shows how to manipulate a collection
of objects using a grasping tool. Also demonstrates a custom standalone mode
simulator.
</ul>

<p>When reading this section, you'll first want to understand the 
<a href="#Overview">basic</a>
design of the Myriad distributed scene graph, including how various kinds
of state (lighting, texturing, coordinate arrays) are
<a href="#Drawing">inherited</a> to guide rendering where it actually takes
place: at the "drawable" nodes. It is also important to understand how to
<a href="#Constructing">construct</a> a node tree and populate it using
<a href="#BuiltIn">built-in</a> objects, which is the best way to get 
something working quickly.

<p><ul>
<li><a href="#Overview">Overview</a>
<li><a href="#Drawing">Node Inheritance and Drawing</a>
<li><a href="#NodeTypes">Node Types</a>
<li><a href="#Constructing">Constructing a Node Tree</a>
<li><a href="#HelperClasses">Helper Classes</a>
<li><a href="#BuiltIn">Using Built-In Objects</a>
<li><a href="#NodeMethods">Node Methods in C++</a>
<li><a href="#DrawableNode">Drawable Node Specifics</a>
<li><a href="#GraphicsState">Graphics State Node</a>
<li><a href="#ThreadSafety">Notes on Thread Safety</a>
</ul>

<a name="Overview">
<p><font size=+2>Overview</font>
</a>

<p>The arGraphicsDatabase object receives a stream of data records causing
it to alter its internal contents. These data records are either in
the form of arStructuredData or byte blocks which can be parsed into
arStructuredData records. The alter() method receives arStructuredData,
while the alterRaw() method receives byte blocks, parses them, and then
runs the result through alter().

<p>The arGraphicsDatabase object manages a tree of arGraphicsNode objects.
The base class arGraphicsNode is subclassed to define the various
types of nodes, like visibility nodes, texture nodes, lines nodes,
etc. These objects have three important methods, receiveData(), draw(),
and dumpData().  Message streams sent to the arGraphicsDatabase via
alter()/alterRaw() are either routed to the arGraphicsDatabase itself,
like the message that requests a new node be created, or to a specific
node.  For instance, a message might ask that a visibility node turn
itself on or off. This is the use of the receiveData() method. The 
draw() method renders graphics via OpenGL. The dumpData() method creates a
record that reflects the node's state. This record can then be used to
replicate that state in another linked database.

<p>Graphics state is synchronized across multiple machines by replicating
arGraphicsDatabase objects on each machine. An arGraphicsServer object
exists on the master machine and an arGraphicsClient object exists on each
render box (slave); all of these manage an arGraphicsDatabase.  When an 
arGraphicsClient connects to the arGraphicsServer, the server serializes the
state of its arGraphicsDatabase (using the dumpData() methods of its nodes)
and sends it across the network to the newly-connected arGraphicsClient, 
which then uses the alterRaw() method of its arGraphicsDatabase to recreate
the remote state. Subsequently, all alter() calls to the arGraphicsDatabase 
managed by the arGraphicsServer are mirrored over the network to those
managed by the connected arGraphicsClients.

<a name="Drawing">
<p><font size=+2>Node Inheritance and Drawing</font>
</a>

<p><img src="images/SceneGraphInherit.jpg" width=450 height=544>

<p>Tree traversal, arGraphicsContext.

<a name="NodeTypes">
<p><font size=+2>Node Types</font>
</a>

<p><ul>
<li>transform: The type name for an arTransformNode.
<li>texture: The type name for an arTextureNode.
<li>bounding sphere: The type name for an arBoundingSphereNode.
<li>billboard: The type name for an arBillboardNode.
<li>visibility: The type name for an arVisibilityNode.
<li>blend: The type name for an arBlendNode.
<li>light: The type name for an arlightNode.
<li>material: The type name for an arMaterialNode.
<li>normal3: The type name for an arNormal3Node.
<li>color4: The type name for an arColor4Node.
<li>tex2: The type name for an arTex2Node.
<li>index: The type name for an arIndexNode.
<li>points: The type name for an arPointsNode.
<li>drawable: The type name for an arDrawableNode.
<li>graphics state: The type name for an arGraphicsStateNode.
<li>persp camera: The type name for an arPerspectiveCameraNode.
<li>viewer: The type name for an arViewerNode.
</ul>

<a name="Constructing">
<p><font size=+2>Constructing a Node Tree</font>
</a>

<p>arGraphicsDatabase is a subclass of arDatabase, as arGraphicsNode is a
subclass of arGraphicsNode. A short summary of the kinds of operations
that are possible.

<p>Node names. The root node has a special name ("root") and ID (0).

<pre>
  string arDatabaseNode::getName() const;
  void arDatabaseNode::setName(const string& name);
</pre>

<p>Node IDs. Cannot set node ID This is done by an arDatabase only in node
construction. An arDatabase never repeats node IDs for the nodes it creates.

<pre>
  int arDatabaseNode::getID();
</pre>

<p>Node info.

<pre>
  string arDatabaseNode::getInfo() const;
  void arDatabaseNode::setInfo(const string& info);
</pre>

<p>Node type.

<pre>
  string arDatabaseNode::getTypeString() const;
</pre>

<p>Creating new nodes. This must be done via the arDatabase.

<pre>
  arDatabaseNode* arDatabase::getRoot();
  arDatabaseNode* arDatabase::newNode(arDatabaseNode* parent, 
                                      const string& type,
                                      const string& name = "", 
                                      bool refNode = false);
  arDatabaseNode* arDatabaseNode::newNode(const string& type, 
                                          const string& name = "",
                                          bool refNode = false);
</pre>

<p>Reference counting. Necessary for thread-safety (if another thread is
deleting).

<pre>
  void arDatabaseNode::ref();
  void arDatabaseNode::unref();
  int arDatabaseNode::getRef();
  bool arDatabaseNode::active();
  list&lt;arDatabaseNode*&gt; arDatabaseNode::getChildrenRef();
</pre>

<p>Deleting nodes, cutting and erasing.

<pre>
  bool arDatabase::cutNode(arDatabaseNode* node);
  bool arDatabase::cutNode(int ID);
  bool arDatabase::eraseNode(arDatabaseNode* node);
  bool arDatabase::eraseNode(int ID);
</pre>

<p>Inserting between existing parent and child (or in front of ALL of a 
parent's children). Must go through arDatabase to avoid deadlocks.

<pre>
  arDatabaseNode* arDatabase::insertNode(arDatabaseNode* parent,
			                 arDatabaseNode* child,
			                 const string& type,
			                 const string& name = "",
                                         bool refNode = false);
</pre>

<p>Permuting children.

<pre>
  void arDatabase::permuteChildren(arDatabaseNode* parent,
                                   list<arDatabaseNode*>& children);
  void arDatabaseNode::permuteChildren(list<arDatabaseNode*>& children);
</pre>

<p>Inspecting and traversing the node tree.

<pre>
  arDatabaseNode* arDatabaseNode::getParent() const;
  list&lt;arDatabaseNode*&gt; arDatabaseNode::getChildren() const;
  void arDatabaseNode::ps(int maxLevel=10000);
</pre>

<p>Finding nodes via name or ID.

<pre>
  arDatabaseNode* arDatabaseNode::findNode(const string& name, 
                                           bool refNode = false);
  arDatabaseNode* arDatabaseNode::findNodeByType(const string& type.
                                                 bool refNode = false);
  arDatabaseNode* arDatabase::getNode(int ID);
</pre>

<p>Manipulating node level. Imporant only for peer-to-peer reality.

<p><ul>
<li>AR_IGNORE_NODE
<li>AR_STRUCTURE_NODE
<li>AR_STABLE_NODE
<li>AR_OPTIONAL_NODE
<li>AR_TRANSIENT_NODE
</ul>

<pre>
  arNodeLevel getNodeLevel();
  void setNodeLevel(arNodeLevel nodeLevel);
</pre>

<p><font size=+2>Helper Classes</font>

<p>arMaterial, with the fields having the same meaning and defaults as in
the OpenGL specification.

<pre>
  arVector3 diffuse;
  arVector3 ambient;
  arVector3 specular;
  arVector3 emissive;
  float exponent; 
  float alpha; 
</pre>

<p>arLight, with the fields having the same meaning and defaults as in the
OpenGL specification.

<pre>
  int lightID;      
  arVector4 position;
  arVector3 diffuse;
  arVector3 ambient;
  arVector3 specular;
  float     constantAttenuation;
  float     linearAttenuation;
  float     quadraticAttenuation;
  arVector3 spotDirection;
  float     spotCutoff;
  float     spotExponent;
</pre>

<p>arBoundingSphere

<pre>
  arVector3 position;
  float     radius;
  bool      visibility;
</pre>

<p>arRay

<pre>
  arVector3 origin;
  arVector3 direction;
</pre>

<a name="BuiltIn">
<p><font size=+2>Using Built-In Objects</font>
</a>

<p><img src="images/BuiltInShapes.jpg" width=500 height=396">

<p>If you are writing your own custom code instead of using the
arDistSceneGraphFramework or arMasterSlaveFramework objects
(all the demos included with this distribution use these frameworks), first 
call dgSetGraphicsDatabase() before issuing any other API calls.
The framework objects hide this detail.

<pre>
  arGraphicsDatabase graphicsDatabase;
  dgSetGraphicsDatabase(&graphicsDatabase);
</pre>

<p>arSphereMesh: Sphere of radius 1 centered at (0,0,0).

<pre>
  void arSphereMesh::setSectionSkip(int skip);
</pre>

<p>arCubeMesh: Cube with side length 1 centered at (0,0,0) and axis-aligned.

<p>arCylinderMesh: Cylinder of length 1 pointing along the z axis.

<pre>
  void arCylinderMesh::setAttributes(int numberDivisions, 
                                     float bottomRadius,
                                     float topRadius);
  void arCylinderMesh::toggleEnds(bool useEnds);
</pre>

<p>arRectangleMesh: Square with sides of length 1 centered at (0,0,0). Normal
in the positive y direction.

<p>arTorusMesh: Torus in the x-y plane.

<pre>
  void arTorusMesh::reset(int numberBigAroundQuads, 
                          int numberSmallAroundQuads,
                          float bigRadius, 
                          float smallRadius)
</pre>

<p>Importing files in .obj format.

<a name="NodeMethods">
<p><font size=+2>Node Methods in C++</font>
</a>

<pre>
void arDatabaseNode::lock();
void arDatabaseNode::unlock();

arMatrix4 arTransformNode::getTransform();
void arTransformNode::setTransform(const arMatrix4& transform);

string arTextureNode::getFileName();
void arTextureNode::setFileName(const string& fileName, int alpha = -1);

string arBillboardNode::getText();
void arBillboardNode::setText(const string& text);

bool arVisibilityNode::getVisibility();
void arVisibilityNode::setVisibility(bool visibility);

float arBlendNode::getBlend();
void arBlendNode::setBlend(float blendFactor);

arLight arLightNode::getLight();
void arLightNode::setLight(arLight& light);

arMaterial arMaterialNode::getMaterial();
void arMaterialNode::setMaterial(const arMaterial& material);

const float* arNormal3Node::getNormal3(int& number);
void arNormal3Node::setNormal3(int number, float* normal3, int* IDs = NULL);
vector<arVector3> arNormal3Node::getNormal3();
void arNormal3Node::setNormal3(vector<arVector3>& normal3);
void arNormal3Node::setNormal3(vector<arVector3>& normal3,
                               vector<int>& IDs);

const float* arColor4Node::getColor4(int& number);
void arColor4Node::setColor4(int number, float* color4, int* IDs = NULL);
vector<arVector4> arColor4Node::getColor4();
void arColor4Node::setColor4(vector<arVector4>& color4);
void arColor4Node::setColor4(vector<arVector4>& color4,
		             vector<int>& IDs);

const float* arTex2Node::getTex2(int& number);
void arTex2Node::setTex2(int number, float* tex2, int* IDs = NULL);
vector<arVector2> arTex2Node::getTex2();
void artex2Node::setTex2(vector<arVector2>& tex2);
void arTex2Node::setTex2(vector<arVector2>& tex2,
	                 vector<int>& IDs);

const int* arIndexNode::getIndices(int& number);
void arIndexNode::setIndices(int number, int* indices, int* IDs = NULL);
vector<int> arIndexNode::getIndices();
void arIndexNode::setIndices(vector<int>& indices);
void arIndexNode::setIndices(vector<int>& indices,
		             vector<int>& IDs);
</pre>

<a name="DrawableNode">
<p><font size=+2>Drawable Node Specifics</font>
</a>

<p>Relationship between drawable number, the sizes of the various arrays,
and the number of primitives drawn.

<p><ul>
<li>DG_POINTS
<li>DG_LINES 
<li>DG_LINE_STRIP 
<li>DG_TRIANGLES
<li>DG_TRIANGLE_STRIP
<li>DG_QUADS
<li>DG_QUAD_STRIP
<li>DG_POLYGON
</ul>

<pre>
int arDrawableNode::getType();
string arDrawableNode::getTypeAsString();
int arDrawableNode::getNumber();
void arDrawableNode::setDrawable(arDrawableType type, int number);
void arDrawableNode::setDrawableViaString(const string& type, int number);
</pre>

<a name="GraphicsState">
<p><font size=+2>Graphics State Node</font>
</a>

<p><ul>
<li>point_size
<li>line_width
<li>shade_model
<li>lighting
<li>blend
<li>depth_test
<li>blend_func
</ul>

<p><ul>
<li>false
<li>true
<li>smooth
<li>flat
<li>zero
<li>one
<li>dst_color
<li>src_color
<li>one_minus_dst_color
<li>one_minus_src_color
<li>src_alpha
<li>one_minus_src_alpha
<li>dst_alpha
<li>one_minus_dst_alpha
<li>src_alpha_saturate
</ul>

<pre>
string arGraphicsStateNode::getStateName();
bool arGraphicsStateNode::isFloatState();
bool arGraphicsStateNode::isFloatState(const string& stateName);
string arGraphicsStateNode::getStateValueString(int i);
float arGraphicsStateNode::getStateValueFloat();
bool arGraphicsStateNode::setGraphicsStateString(const string& stateName,
                                                 const string& value1,
			                         const string& value2 = "false");
bool arGraphicsStateNode::setGraphicsStateFloat(const string& stateName,
                                                float stateValueFloat);
</pre>


<a name="ThreadSafety">
<p><font size=+2>Notes on Thread Safety</font>

<p>The Myriad scene graph is thread-safe, for instance, with respect to
drawing in multiple threads even with simultaneous deletions and other
scene graph restructurings occur in still other threads.

<hr>
</body>
</html>
