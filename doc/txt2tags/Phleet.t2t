Syzygy Documentation: Distributed Operating System
Integrated Systems Lab
%%mtime(%m/%d/%Y)
%!options: --headers --toc --toc-level=3
%!encoding: iso-8859-1

[Documentation Table of Contents index.html]

%%toc

The Phleet distributed operating system layer of the
Syzygy toolkit has a minimal number of features and components.
The group of computers comprising the Phleet
is controlled by an szgserver program, which performs several functions:

-  Manages multiple users.
-  Stores a parameter database for each user, which is used by software
components to obtain configuration information. The parameter database is
similar in character to Unix environment variables.
-  Maintains a list of the software components registered with the Phleet,
with each component being identified by the computer on which it is running,
a symbolic string (equivalent to executable name), and a unique ID (equivalent
to Unix process ID).
-  Can route messages from one registered software component to another.
These messages can be used like Unix signals. For instance, to cause a
component to terminate or reload its parameters.
-  Contains a connection brokering service which deals with multi-homing and
aids in ease of set-up.
-  Supports named locks that are owned by Phleet components. Locks are
necessary so that certain operations, like starting a distributed application,
can be performed atomically. These locks are released when a component dies.


The Phleet can be controlled in two basic ways:

+ From the command line (or scripts). A complete selection of commands is
provided. This is useful, for instance, in providing GUI front-ends for various
categories of tasks via a scripting language like Python.

+ Programatically by using the methods of an arSZGClient object. There is
almost a one-to-one mapping between the methods of this object and the command
line executables. This method is used to make launching applications on
"virtual computers" easier.


A Phleet is comprised of a set of computers connected by a network. Each
Phleet is controlled by an szgserver program. There is only one instance of
this program per Phleet instance. The connection to the szgserver is
maintained on a
per-computer basis (for all users of the box), but you can switch a given
computer to a new szgserver using the dconnect command. Furthermore,
for full operation, each computer in the Phleet
should run a copy of szgd, the remote execution daemon. Like the rest of the
Phleet toolset, szgd is designed to support multiple users. When you try to
remotely execute a program with Phleet identity XXX, the remote program also
gets identity XXX. A Phleet member doesn't have to run szgd, if
programs will be executed manually thereon.


=Reserved Words and Characters=[ReservedWords]

"NULL" or "*" cannot be user-defined user, computer, group, or
parameter names. "NULL" internally functions as the indication of an undefined
value, whereas "*" is used in the szgserver discovery process. The characters

```
  :  ;  |  /
```

should not be used in names since they are used for data parsing and
representation.


=Reserved Ports=[ReservedPorts]

The Phleet components use UDP on port 4620 to provide automatic discovery of
running szgserver's. Syzygy also needs a block of ports reserved on each
machine in the Phleet, as a Syzygy cluster is called, for connection brokering.
By default, the port block used is 4700-4899, but can be redefined by the user
with the dports command.


=Phleet Configuration=[PhleetConfiguration]

The Phleet configuration file, szg.conf, is comprised of several different
XML record types.

```
  "computer"
    char[] name;
```

```
  "interface"
    char[] type;    // only "ip" valid so far
    char[] name;    // a name for the network, like "internet", "wall", or "cube"
    char[] address; // the interface's address, for instance 192.168.0.1
    char[] netmask; // the netmask associated with this interface, assumed to be
                    // 255.255.255.0 if not set.
```

```
  "ports"
    int[] first; // the first port in the block to be used by Syzygy on the given computer
    int[] size;  // the number of ports in the block
```

Here is an example of an szg.conf file

```
  <computer>
    <name>smoke</name>
  </computer>
  <interface>
    <type>IP</type>
    <name>wall</name>
    <address>192.168.0.1</address>
  </interface>
  <ports>
    <first>
      4700
    </first>
    <size>
      200
    </size>
  </ports>
```

The szg.conf file contains one "computer" record, giving the computer's
Syzygy name, which can be different from any other names the computer has,
for instance via DNS. It then contains several "interface" record, one for
each communications interface the computer has. Finally, the szg.conf file
contains one "ports" record, which determines which ports services running on
that computer will use. If no such record is present, the dname command will
write a default record to the file, The default port range is 4700-4899.

By default, the szg.conf file is found at c:\szg\szg.conf on Win32 systems
and at /etc/szg.conf on Unix systems. To enable non-root users to use Syzygy
on Unix or let Windows boxes without a c: hard disk be Syzygized, the
environment variable SZG_CONF can be used to change the location of the
szg.conf file. If SZG_CONF is set and not equal to "NULL", it gives the
location of the szg.conf file. The value must NOT include a trailing slash
(i.e. it should be something like /usr/szg or /tmp/szg).

The user should not have to edit szg.conf by hand. Consequently, several
command line programs are provided. Each of these commands parse the whole
szg.conf file, writing it fresh upon completion, thus eliminating errors that
could creep in via editting by hand. Both the "name" and "ports" record must
be present in this file. If they are not, default values are written. The
default "ports" record has already been mentioned. The default "name" record
uses a default name of "NULL".

```
  dconfig
    Parses the szg.conf file and prints the information contained therein in
    compact form.
```

```
  daddinterface name address [netmask]
    Adds an interface to szg.conf file with the given name, IP address, and
    (optionally) netmask. The name is descriptive (like "internet") can is
    meant to uniquely identify a network. IP address alone cannot do this
    because of private networks like 192.168.0.*. The network's netmask can
    also be given (the default is 255.255.255.0) so that Syzygy's broadcast
    system for szgserver discovery will work correctly. If the environment
    variable SZG_CONF is not set (or is set to "NULL") a default location is
    used, which depends on the host operating system. Otherwise, SZG_CONF gives
    the directory where szg.conf will be written.
```

```
  ddelinterface name address
    Removes the interface with the given name/address pair from the szg.conf
    file. As before, the environment variable SZG_CONF can change the
    config file's location.
```

```
  dports first size
    Changes the "ports" record in the szg.conf file, with "first" giving the
    number of the first port to be used and "size" giving the size of the port
    window. As before, the environment variable SZG_CONF can change the
    config file's location.
```

```
  dname name
    Sets the computer's name in the szg.conf file. If no ports information is
    present, it goes ahead and adds a default ports record, reserving the range
    4700-4899. As before, the environment variable SZG_CONF can change the
    config file's location.
```

The Phleet configuration file just determines the identity of an
individual computer in the distributed system: its name, its network
interfaces, and the ports it will use to offer services. This information is
insufficient to join a Phleet. For that, one also needs to know which
szgserver and which Phleet user name are being used. This information is
maintained, per host system user, in a Phleet login file. The login file is
manipulated via the dlogin and dlogout commands. By default, if the host
system user is XXX, the Phleet login file will be /tmp/szg_XXX.conf on
Unix-like systems and c:\szg\szg_XXX.conf on Win32 systems. As with the
szg.conf file, these locations might be inconvenient for
some reason or another. Consequently, if the SZG_LOGIN environment variable
is set and not equal to "NULL", it gives the directory where they will
be stored. SZG_LOGIN must NOT have a trailing slash.

```
  dlogin szgserver_name user_name
  dlogin IP port user_name
    In the first case, the dlogin program attempts to discover the szgserver
    given by szgserver_name by broadcasting a discovery packet on the LAN. If
	such is found, the Phleet login file is written with user_name giving the
    Phleet user identity.
    In the second case, the dlogin program attempts to connect to the szgserver
    using the IP/port parameters (much as a standard Phleet component would using
    corresponding parameters from the login file). If successful, the Phleet
    login file is written, using the given user_name.
    Note that the second case is necessary since the szgserver might not be
    reachable via broadcast packets from the dlogin program. A good example of
    this occurs when running everything on a computer that is not connected to
    a network. The loopback address 127.0.0.1 may be the only one available in
    this case and it does not allow broadcast traffic. Another example occurs
    when wanting to dlogin to an szgserver on another network.
```

```
  dlogout
    This command resets the Phleet login file for the particular host system user.
```

```
  dwho
    Prints the Phleet login file of the particular host system user in a
    compact form.
```

```
  dhunt
    Display all szgServer's running on the LAN, in the format:
      server_name/server_IP:server_port
    This command reads the Phleet configuration file and sends an szgserver
    discovery packet out on each of the interfaces defined therein. There
    is a 2 second time-out on the discovery process for each interface.
```


=Additional Command Line Tools=[CommandLine]

The commands for editting the Phleet configuration file (szg.conf) and
for session management (like dlogin) have been outlined in a previous
[section #PhleetConfiguration]. Phleet also has commands for
managing the paramter database (which is used for configuration), for
sending messages to running Phleet components (and even for receiving
replies for an RPC capability), and for monitoring the status of the
system (being able to find out what is running, among other tricks). Please
see the section on [configuration SystemConfiguration.html]
for information on the dbatch file format.


==Parameter Database Management==
```
   dbatch batch_file
     Take the configuration information contained in the given file and
     transfer it to the szgserver. By default, the command looks in the
     current directory for the file and then on a search path given by
     computer/SZG_SCRIPT/path.
```
```
   dget computer parameter_group parameter_name
     Display the value of the parameter computer/group_name/parameter_name.
```

```
   dget global_parameter_name
     While many Phleet parameters are keyed to particular computers, some
     are global in nature (i.e. concerned with the global system instead
     of one computer). A good example of a global parameter an input
     device definition.
```

```
   dget -a search_string
     Display all key/value pairs in the parameter database containing
     string search_string. To do more complex searches, pipe the output
     through grep or sed. If search_string is omitted, all database entries
     for the given user will be returned.
```

```
   dset computer parameter_group parameter_name value
     Assign "value" to the item with key computer/parameter_group/parameter_name.
```

```
   dset global_parameter_name value
     Assign "value" to the global parameter having key global_parameter_name.
```


==Interprocess Communications==
```
   dex [-v] execution_location executable_name [args]
     dex determines if the execution_location names
     a specific host or a virtual computer. If a virtual computer has been
     named, the executable is run through the szgd on the virtual computer's
     "trigger" computer and, from there, launches other processes it might
     need for operation. On the other hand, if a specific host is named, the
     executable will run (along with specified args) on that host, as spawned
     by szgd.
     In each case, if szgd is not found, dex fails. If szgd is found, messages
     will return to dex to be printed. For instance, dex will remark if an
     executable fails to be found. Once the szgd launches the new component,
     it will send messages to dex, allowing the component to provide feedback
     on its start up. By default, only the contents of the final message are
     printed, but -v option makes all messages print.
     Phleet supports launching both native and Python programs. For native
     programs on Windows hosts, ".EXE" is automatically appended to executable_name
     (so don't add it yourself). If executable_name ends in ".py" then it is assumed
     to be a Python progarm.

   dex [-v] executable_name
     A special case, this launches executable_name on the local computer. No additional
     arguments may be passed to the program.

```

```
   dkill [-9] [computer_name] executable_label
     Send a "quit" message to the first entry in the Phleet process table
     matching the inputs. Like unix "kill -9", the -9 option forcibly closes
     sgzserver's connection (if a client died without szgserver realizing that
     its connection to the client is gone).
```

```
   dmsg ID message_type [message_body]
     Send a message to the process with the specified ID. Phleet messages
     have two text strings, the type (e.g., "exec") and the body (e.g.,
     "/home/randomuser/bin/linux"). The body defaults to the empty string.
```

```
   dmsg [-r] -p computer_name component_name message_type [message_body]
     Find the component, if such exists, with name component_name that is
     running on computer computer_name. Send it a message with tag
     message_type and body message_body. If message_body is not present,
     an empty body is sent. If the -r flag is specified, dmsg requests
     a reply to its message and waits for that reply, printing it upon
     receipt.
```

```
   dmsg [-r] -m virtual_computer message_type [message_body]
     Find the component, if such exists, running on the master screen of
     the given virtual computer. Send it a message with tag message_type
     and body message_body. If message_body is not present, an empty body
     is sent. The -r flag carries the same meaning as above.
```

```
   dmsg [-r] -g virtual_computer screen_number message_type [message_body]
     Find the component, if such exists, running on the screen indexed
     by screen_number pertaining to the listed virtual computer. Send it
     a message with tag message_type and body message_body. If message_body
     is not presnt, an empty body is sent. The -r flag carries the same
     meaning as above.
```

```
   dmsg [-r] -c virtual_computer_location message_type [message_body]
     Find the component, if such exists, which is the trigger for the currently
     running application in the given virtual computer location. Send it
     a message with tag message_type and body message_body. If message_body
     is not present, an empty body is sent. The -r flag carries the same
     meaning as above.
```

```
   dmsg [-r] -s service_name message_type [message_body]
     Find the component, if such exists, that is providing the service
     indicated by service_name. Send it a message with tag message_type and
     body message_body. If message_body is not presnt, an empty body is sent.
     The -r flag carries the same meaning as above.
```

```
   dmsg [-r] -l lock_name message_type [message_body]
     Find the component, if such exists, holding the lock indicated by
     lock_name. Send it a message with tag message_type and body message_body.
     If message_body is not presnt, an empty body is sent. The -r flag carries
     the same meaning as above.
```


==System Monitoring==
```
   dps [search_tag]
     List all processes in the format:
       computer_name/process_name/ID
     Including the search_tag parameter lists only those lines containing it.
```

```
   dtop [d milliseconds] | q | t
     Repeated dps, like Unix "top" with pretty color coding.
     d specifies a delay (default 500). q sets delay to 0 (cpu hog).
     t is for stress-"t"esting szgserver: zero delay and no display.
     Hit "q" to quit (or use dkill).
```

```
   dlocks
     Prints a list of the locks currently held by Phleet components, along
     with their component IDs.
```

```
   dservices
     Prints a list of services currently offered by Phleet components.
     Useful in seeing what is running.
```

```
   dpending
     Prints a list of unfilled service requests that have been posted by
     Phleet components. Useful in understanding why something is failing
     to connect to or otherwise get information from another component.
```


=Running szgserver=[RunningSzgserver]

To run szgserver, type:
```
  szgserver server_name server_port
```

Optionally, you can restrict the IP addresses from which connections will
be accepted by appending a sequence of whitelist entries, which can either
add single IP addresses or blocks of IPs to the whitelist. If you typed:
```
  szgserver server_name server_port 130.126.127.0/255.255.255.0 192.168.0.11
```

then only connections from IP addresses beginning with 130.126.127 or from
IP address 192.168.0.11 would be accepted.

"server_name" should be a unique alphanumeric tag. "server_port" is the
port on which the szgserver will listen for TCP connection requests. All
components in the Phleet distributed system connect to
szgserver via this port and maintain that connection throughout their
operation. The IP address and port number are embedded in a user's login file,
as explained [here #PhleetConfiguration].

While login can involve
explicitly stating the IP address/ port pair of the desired szgserver,
there is also an automated discovery mechanism
keyed on the szgserver's name. Clients can discover the szgserver
by broadcasting UDP packets on port 4620. When the szgserver receives a packet
on this port containing it's name, it broadcasts a reply, also on port 4621,
containing the IP address and port of the szgserver.

When an szgserver runs, it uses the Phleet configuration file on the
local computer to determine the IP address it should use in its response to
client discovery requests. It picks the first IP address listed in the
configuration file. Consequently, the
user should make sure that this IP address is globally accessible via all
computers that will be part of the Phleet.


=How Clients Connect to the szgserver=[Connect]

Syzygy programs can either operate in Phleet mode or
[standalone mode Standalone.html]. For some programs, such as
those that manipulate the Phleet, standalone mode, where the program operates
without connection to an szgserver, does not make sense. However, user
applications can often operate in a self-contained manner, and, consequently,
standalone mode makes sense for them. For instance, both Syzygy application
frameworks can operate in standalone mode.

 When a Phleet component starts, it
first reads the appropriate login file. This file specifies the szgserver to
use and has name szg_XXX.conf, where XXX is the user name according to the
host system. If this file does not exist or is in a dlogged-out state, the
program will operate in standalone mode, if it supports such. If the program
does not support standalone operation, it will exit, prompting the user to
dlogin in. On the other hand, if the login file indicates the user is logged
in to an szgserver, the embedded arSZGClient attempts to contact that
server (the IP address and port are contained in the file) and form a
connection. If the connection attempt fails, the program will attempt to
operate in standalone mode, failing if it does not support such.

As mentioned in this [section #PhleetConfiguration], the dlogin
command creates the Phleet login file, either via explicitly feeding the
command an IP address/port pair or by automatic discovery. The discovery
process is described now. First, the component broadcasts a call to szgservers
out on the LAN. All szgserver programs listen for UDP packets on port 4620 and
respond to discovery requests by broadcasting on the same port.
Requests and responses
are distinguished by a one byte flag in the packet, and both types are 200
bytes long. They have the following format:

```
  discovery packet (size 200 bytes)
   bytes 0-3: A version number. Allows us to reject incompatible packets.
   byte 4: Is this discovery or response? 0 for discovery, 1 for response.
   bytes 4-131: The requested server name, NULL-terminated string.
   bytes 132-199: All 0's
```

When an szgserver receives a discovery packet, it checks whether the
requested name is the wildcard character "*" or equals its own name. If so,
it returns a response packet.

```
  response packet (size 200 bytes)
   bytes 0-3: A version number. Allows us to reject incompatible packets.
   byte 4: Is this discovery or response? 0 for discovery 1 for response.
   bytes 5-131: Our name, NULL-terminated string.
   bytes 132-163: The interface upon which the remote whatnot should
    connect, NULL-terminated string.
   bytes 164-199: The port upon which the remote whatnot should connect,
    NULL-terminated string. (in fact, all trailing zeros)
```

The timeout period during which the client will wait for a response is
2 seconds.


=szgd, the Remote Connection Daemon=[szgd]

The remote execution daemon szgd is a special Phleet component that executes
Syzygy programs in response to Phleet messages (via dex). It handles both
native (i.e. C++) and Python programs, supports multiple users each with
their own executables, and manipulates environment variables controlling
dynamic linker paths and python module paths to ensure that loadable objects
behave as expected to particular users. The szgd cannot run in standalone mode
and consequently must connect to an szgserver once it starts, requiring a
successful dlogin to occur beforehand. Only one szgd can run on a given host.
On start, szgd tries to grab a Phleet lock named XXX/szgd, where XXX is the
name of the computer on which it runs. If it fails, it quits immediately.

If user XXX attempts to execute a program on
a computer YYY running szgd, the szgd instance finds the value of
YYY/SZG_EXEC/path in the parameter database of user XXX and uses that as a
search path for the requested executable. By convention, dynamic libraries
are assumed to live in the same directory as the executables that load them.
Consequently, when executing a program, szgd prepends the directory in which
the program lives to the front of environment variable giving the dynamic
linker search path (LD_LIBRARY_PATH on Linux).


=Names, According to the szgserver=[Names]

The szgserver does not do name resolution of any kind. The Phleet
configuration files of individual computers determine the name of that
computer, as used by Phleet. When a client is communicating with the szgserver,
it reads the Phleet configuration file to determine the computer's name, and
transmits that to the szgserver, which trusts the transmission.


=How Do Clients Determine the Current User?=[User]

As the arSZGClient object initializes, it needs to determine the user. Many
communications with the szgserver are stamped with user name. Manipulations
of a parameter database (one of which exists for each user) clearly need this
information. Messages from one arSZGClient to another are also stamped with
user name, which allows, for instance, szgd daemons to execute programs in the
as the Phleet user making the remote execution request, instead of
the Phleet user who started the szgd program.

This is how the Syzygy program determines the Phleet user:

+ First, check to see if the environment variable SZGUSER is set. If so, then
   the value is the Phleet user name. When szgd executes a Syzygy program, it
   sets this variable to the Phleet user name associated with the execution
   request.

+ If not, determine the current user name as reported by the host system
   (which can be completely different from an Phleet user name). Use this
   user name to load a Phleet login file. If the host system user name is
   XXX, then the Phleet login file, on a unix system, will be
   /tmp/szg_XXX.conf. The Phleet user name is read from this file.


=How Clients Message Each Other (via szgserver)=[Message]

Components of the distributed system need to message each other from time to time.
For instance, the "dex" command sends a message to an szgd, which causes szgd to
launch the requested executable. Furthermore, a component can receive a "kill" or
a "reload" message, causing it to take appropriate action. Note that some messages
need to have responses to be meaningful. For instance, the "dex" command must be
able to report any trouble launching the requested executable and even information
from the executable's initialization.

For reliability, the right to respond to a message (that requires a response) must
be owned by a particular component. If that component drops out of the Phleet, the
szgserver can then easily notify the message-sending component that an error has
occured and that it will never receive a response. Unfortunately, this rule needs to
be somewhat bent to enable the "dex" command's right to respond to an execution
message to be passed on to the launched executable. In this case, szgd indicates to
the szgserver it wants to trade its right of message response to any Phleet
component making a trade request with an appropriate key. The launched executable is
able to make such a request, and thus is able to respond to the original launch
message.

We now outline the records in the Phleet protocol that pertain to messages.

```
    "SZG Message"
      int[]  "ID";      // the message's ID
      int[]  "Response"; // 0 if no response is desired, 1 if response is
                         / desired
      char[] "User";    // the user who sent the message.
      char[] "Type";    // the type of the message, like "quit", "reload", etc.
      char[] "Body";    // additional information
      char[] "Context"; // is this message being sent as part of the operation of a
                        // virtual computer
      int[]  "Destination"; // the Phleet ID of the message's destination
```

```
    "SZG Message Admin" // this is a catch-all record that serves several functions
      int[]  "ID";      // if the admin record is about a particular message, the
                        // ID is filled-in here
      char[] "Status";  // status code, "SZG_SUCCESS", "SZG_FAILURE", or
                        // "SZG_CONTINUE"
      char[] "Type";    // the command type. "SZG Response",
                        // "SZG Trade Message", "SZG Message Request", "SZG Revoke Trade"
      char[] "Body";    // additional information, if necessary
```

```
    "SZG Message Ack"   // used by the szgserver to acknowledge the various
                        // communications above
      int[]  "ID";      // used to inform the client of a particular message ID
      char[] "Status";  // status code, "SZG_SUCCESS" or "SZG_FAILURE"
```

We now examine the variations within the "SZG Message Admin" record, as
differentiated by the "Command" field.

"SZG Response": The response to the client's message. The "Status" field tells
whether or not this is valid (for instance, the Phleet component owning the right to
respond could have died, in which event, an "SZG Response" would be sent (by the
szgserver) with
"Status" set to "SZG_FAILURE". The "Body" field gives the text of the response.
The "ID" field gives the message ID for which this response is intended. Note that
components are allowed to send partial responses to messages (as may be desirable if the
full message response will take a very long time). In this case, the "Status" field
is set to "SZG_CONTINUE".

"SZG Trade Message": The "ID" field identifies the message of which we are trying
to relinquish ownership. The "Body" field gives the key upon which message trading
hinges.

"SZG Message Request": The "Body" field is the key with which the client requests
a new message.

We now construct various scenarios in the use of Phleet messaging.

Message sent, no response required: The simplest scenario. szgserver receives
the message, fills in the ID with the next available message ID, and routes it
to the component with the given destination ID. (note that upon receipt of the
message, the szgserver returns an "SZG Message Ack" containing the message's ID)
The component receiving the message then processes the
message using a callback registered with its arSZGClient. Nothing is ever registered
with the szgserver's internal data storage.

Message sent, response required: Upon receipt of the message, the szgserver fills
in the ID field with the next available message ID. Next, it returns an
"SZG Message Ack" record containing the message's ID.
In this way, the sending component can send several messages before getting a single
response and still be able to distinguish which response corresponds to which
message. The szgserver then registers the message ID
with the destination component. The destination component is now able to respond to
that message. The message is then routed to the destination.
If the destination component leaves the
Phleet before delivering its response, the szgserver sends a record as below to the
originating component:

```
    "SZG Message Admin"
      int[] {  };
      char[] {"SZG_FAILURE"};
      char[] {"SZG Response"};
      char[] {""};
```

Response sent: Upon receipt at the szgserver of the "SZG Message Admin" record
with type "SZG Response", the
szgserver sees if the component is allowed to respond to the message with the ID.
If so, it looks up the Phleet ID
of the component owing the message response (which might be different than the
component that actually sent the message in the first place). The response is sent to
this component. The next action depends on the content of the "Status" field. If this
field is set to "SZG_SUCCESS", the entry keyed to the message ID is removed from the table.
On the other hand, if the field is set to "SZG_CONTINUE", the message ID is not removed.
In either case, an "SZG Message Ack" is sent to
responding component, with status "SZG_SUCCESS". On the other hand, if the responding
component does not own the right to respond to the message, an "SZG Message Ack"
with status "SZG_FAILURE" is sent to the
responding component.

Message response ownership passed to a new component: The receiving component
may decide that it wishes to pass message response ownership to a new component.
The best example of this is with szgd wanting to pass ownership of the execution
message to the spawned process. The receiving component can send an "SZG Message Admin"
record with type "SZG Message Trade" to the szgserver in order to indicate
its willingness to relinquish right to
respond to a given message to a new component (as determined by a string key).
This key includes information about the user and the virtual computer.
For instance, if the component run by user "XXX" on host "YYY" and in the context
of virtual computer "cube" wants to
trade a message under the name "foo", the key will then be: "XXX/YYY/foo/cube". Note that
in the particular case of szgd, "foo" will be the name of the launched component.
The szgserver maintains a table mapping keys to the IDs of the
components which can respond to those messages. Each component furthermore has a map
associating keys it has posted with message IDs associated with them. These data
structures are now updated.
Next, the new component then sends an "SZG Message Admin" record with
type "SZG Message Request"
to the szgserver, asking for ownership of
the message with key "XXX/YYY/foo/cube" (as in the previous example). An
"SZG Message Ack" record is sent back to the
new component. The "Status" field indicates whether it has received ownership of the
message. If so, the "ID" field indicates the ID of the original sending component. Also,
in this case, a "SZG Message Ack" record is returned
to the original receiving component. The global szgserver and component-specific data
structures mentioned above are suitably updated. 


=arSZGClient Methods Associated with Messaging=[MessageMethod]

```
  int arSZGClient::sendMessage(const string& user, const string& type,
                               const string& body, const string& context,
                               int destination, bool responseRequested);
    Generates an "SZG Message" with the given parameters. Blocks until it receives
    a reply from the szgserver with the message's ID (or until the szgserver connection
    goes away). Returns 0 on failure and otherwise the message ID assigned to the
    message by the szgserver. NOTE: this means that szgserver message IDs must be strictly
    positive.
```

```
  int arSZGClient::getMessageResponse(const string& body, int& messageID);
    Returns 0 on failure, 1 if we've receive a final response to the message, and
    -1 if we've received a partial response to the message.  Note that this allows
    long duration computations or initializations to be gradually streamed back to
    the original message sender. The parameter "body" is filled-in with the "Body"
    field of the "SZG Message Admin" record. The parameter "messageID" is filled-in
    with the ID of the message for which this response is intended.
```

```
  bool arSZGClient::messageResponse(int messageID, const string& body,
                                    bool partialResponse);
    Attempts to send a message response to the given message ID and with given body.
    The parameter "partialResponse" is optional (default is false). If it is set to
    false, this is the only response that can be expected to the message. If it is
    set to true, more responses will be forthcoming. Returns false if the response is
    undeliverable. And true otherwise.
```

```
  bool arSZGClient::startMessageOwnershipTrade(int messageID, const string& key);
    Sends an "SZG Message Admin" record with type "SZG Trade Message"
    to the szgserver. If the command is issued by a component run by user "XXX" on host
    "YYY" as a part of virtual computer "cube", the sent key will be [key] (in distinction
    to requestMessageOwnership(...) below). Returns true if the send succeeds and the
    component has the right to trade this message. False otherwise (as, for instance,
    if the given key has already been taken).
```

```
  bool arSZGClient::finishMessageOwnershipTrade();
    Waits on notification that a pending message ownership trade has occured.
    Returns true if the record receive succeeds. Returns false otherwhise.
```

```
  bool arSZGClient::revokeMessageOwnershipTrade(const string& key);
    Attempts to revoke a pending message-ownership trade. Note that we have to give the key
    in a fully-explicit fashion. Returns true if the revocation
    was successful and false otherwise. Several conditions might cause a message ownership
    trade to fail. Specifically, another component might have already completed the
    trade or our component might not have the right to revoke the trade.
```

```
  int arSZGClient::requestMessageOwnership(const string& key);
    Requests ownership of message with key "XXX/YYY//cube" (where "XXX", "YYY",
    and "cube" are as above). Note how the arSZGClient automatically fills-in the data,
    based on its internal state, in distinction to startMessageOwnershipTrade(...) above.
    Returns 0 if this fails and otherwise the ID of the message to which the client now
    owns the response rights.
```


=The Operation of Locks in Phleet=[Lock]

Phleet needs locking mechanisms for normal operation. An example of the need for
OS-level locks is found in the launching of an application, which needs to be atomic,
even though it may involve significant operations on components in the distributed
system. Locks can be implemented, in a primitive way, by using database variables,
since there is support for atomic test-and-set. However, this method is insufficient.
Locks should be owned by components so that they are released on that component's
removal from the distributed system.

Consequently, Phleet maintains a lock table. Each lock is named. The name is a key
to the lock table, in which is stored the ID of the component owning the lock. When
a component sends an "SZG Lock Request" to the szgserver, the szgserver checks to
see if another component owns the lock. If so, it sends the originating component a
response (an "SZG Lock Resonse" record) indicating that another component owns the
lock, and giving that component's ID. If not, it sends the originating component a
message indicating that it now owns the lock. Appropriate modifications are made to
the lock table plus the component's data structure that records the resources it owns.
Specifically, each component maintains a list of locks it owns. When the component
leaves the Phleet, these are removed from the global list of held locks.

When the component wants to release a lock it owns, it sends an "SZG Lock Release"
to the szgserver. The szgserver checks to see if the sending component does, in fact,
own the lock. If so, it releases it and sends an "SZG Lock Response" back with
"Status" field set to "SZG_SUCCESS". Otherwise, the lock remains unreleased and the
szgserver returns an "SZG Lock Response" with "Status" field set to "SZG_FAILURE".

IMPORTANT NOTE: There is currently no way to *wait* until a lock can be grabbed
by the requesting component. A feature to be added (i.e. in some situations it might be
nice to have a getLock(...) call that blocks until the lock is available, which is
the usual semantics of pthreads locks. However, this functionality is not needed for
cluster application launching, so it is put off for a future realease.

```
    "SZG Lock Request"
      char[] "Name"; // the name of the lock we are requesting
```

```
    "SZG Lock Release"
      char[] "Name"; // the name of the lock to be released
```

```
    "SZG Lock Response"
      char[] "Name";      // the name of the lock that was requested
      char[] "Status";    // "SZG_SUCCESS" if the lock has been gotten
                          // "SZG_FAILURE" if not gotten
      int[]  "Owner";     // the Phleet ID of the component owning the lock currently
                          // -1 if no component owns it.
```

```
    "SZG Lock Listing"
      char[] "Locks";      // a slash-delimited list of the locks names in the system
      char[] "Computers";  // a slash-delimited list of the computers holding those locks
      int[]  "Components"; // an array containing the IDs of those components
```

```
    "SZG Lock Notification"
      char[] "Name";   // upon the release of this named lock, we wish to be notified
```


Note that this scheme also handles Phleet resource reservation. A
component can hold a lock on a particular resource in a virtual computer
(like a graphics screen). If a new component wants that resource, it can
try to get the lock. On failure, it learns of the ID of the component holding the
lock. A kill message can then be sent to that component to free the resource.


=arSZGClient Methods Associated with Locks=[LockMethod]

```
  bool arSZGClient::getLock(const string& lockName, int& ownerID);
    Returns true if the component now holds the lock (and fills ownerID with -1).
    Otherwise, it returns false and fills ownerID with the ID of the component that does,
    in fact, own the lock. Note that this allows us to send a "kill" message to the
    component in question, which will cause the lock to be freed. Note that this is
    a nonblocking call.
```

```
  bool arSZGClient::releaseLock(const string& lockName);
    If the component does not currently hold the lock, this call returns false.
    If the component holds the lock, the lock is released and the call returns true.
```

```
  bool arSZGClient::requestLockReleaseNotification(const string& lockName);
    Uses a "SZG Lock Notification" record to request that a record of the same
    type be returned upon release of a given lock. Returns whether the request
    succeeded.
```

```
  string arSZGClient::getLockReleaseNotification();
    Waits for a "SZG Lock Notification" record to be sent to the client. When
    such is received, it prints out the name of the lock that was released.
```


=Connection Brokering in Phleet=[Brokering]

In previous Syzygy versions, components offering services did so on IPs/ports fixed by
parameters stored in the szgserver's database, as did components requesting services.
This is inadequate in several ways. First, it fixes connections based on the computers
on which components run, implying that a component running on computer A will always
connect to another component running on computer B. Second, this was
the only information in
the parameter databases used with previous syzygy versions that could not be given
sensible defaults, consequently increasing set-up complexity. Third, it introduces a
common source of errors: why won't component A connect to component B?

Syzygy now uses the szgserver as a connection broker. Roughly speaking, when a
component becomes available as a data source, it registers itself with the szgserver,
using a tag. The szgserver responds with a port on which it can listen for connection
requests. All internet-based Syzygy services now bind to INADDR_ANY. This increases
flexibility as, often, a service providing component will want to drive components
on multiple IP networks. The client chooses the network on which the connection occurs.
When a client wants to establish a connection to a Syzygy service, it contacts the
szgserver with the tag describing the service to which it wants to connect. If the
tag exists in the szgserver's internal store, the server returns network(s) and a port
number of which the service is accessible. The client can then connect directly to the
service via a network of its choice. A more detailed exlanation of the process follows.

Here are the record types in the Phleet protocol used to deal with connection
brokering.

```
    "SZG Register Service"
      int[]  "Match"      // arequest ID generated by the arSZGClient and echoed by
                          // responses from the szgserver. Used to allow services
                          // to register themselves in mutliple threads.
      char[] "Status";    // SZG_SUCCESS, SZG_FAILURE, or SZG_RETRY
      char[] "Tag";       // a string indicating the service's identity
      char[] "Networks";  // a slash-delimited string listing human-readable identifiers
                          // for the various networks on the originating box
      char[] "Addresses"; // a slash-delimited string listing the addresses of the
                          // computer's interfaces on the above communications networks,
                          // in the same order as the networks themselves appear
      int[]  "Size";      // some services may require a block of ports upon which
                          // to operate, this indicates the number of ports required
      char[] "Computer";  // the name of the computer on which the service will run
      int[]  "Block";     // a pair of numbers indicating the starting port and the size
                          // of the port block as defined in szg.conf. This can change
                          // over time, so each record attempting to register a service
                          // contains it
      int[]  "Port";      // in the case of SZG_RETRY, we are letting the szgserver
                          // know we were unable to bind to a port in this array
```

```
    "SZG Request Service"
      char[] "Computer";  // the computer on which the service request occurred
      int[]  "Match";     // a request ID generated by the arSZGClient and echoed by
                          // responses from the szgserver. Used to allow service
                          // requests from multiple threads.
      char[] "Tag";       // a string indicating the identity of the requested service
      char[] "Networks";  // a slash-delimited string listing human-readable identifiers
                          // for the various networks on which the client can communicate
      char[] "Async";     // either SZG_TRUE or SZG_FALSE. If SZG_FALSE, the szgserver
                          // will immediately respond with a failure message if the
                          // requested service has yet to be registered. If SZG_TRUE,
                          // the response will wait until registration has occured.
```

```
    "SZG Broker Result"
      int[]  "Match";     // Allows the response to be routed to the right thread.
      char[] "Status";    // SZG_SUCCESS or SZG_FAILURE
      char[] "Address";   // If this responds to an "SZG Request Source" record and
                          // the "Status" field is SZG_SUCCESS, then this will be the
                          // address to which it should connect to the service
      int[]  "Port";      // This can either be the array of ports assigned by the
                          // szgserver to the service or the array of ports to which the
                          // client will connect, depending on whether this is a
                          // response to "SZG Register Source" or "SZG Request Source"
```

```
    "SZG Get Services"
      char[] "Services";   // Returns a semi-colon delimited list of the running services
                           // managed by this szgserver (or conversely the pending service
                           // requests). note that the list must be
                           // semi-colon delimited since service names may contain slashes
      char[] "Type";       // Are we asking for registered services or requests for a
                           // service that have yet to be fulfilled?
      char[] "Computers";  // Returns a slash-delimited list giving the computers on which
                           // the services are running (or, conversely the computers on
                           // which the components requesting the services are running)
      int[]  "Components"; // the IDs of the components offering the services (or
                           // conversely the IDs of the components whose service requests
                           // have yet to be fulfilled).
```

```
    "SZG Service Release"
      char[] "Name";      
      char[] "Computer";
```

There are two commands relating to services. It allows the user to see a listing of
all services currently offered.

```
    dservices
      Prints a listing of all services currently offered. This command works by sending
      the szgserver an "SZG Get Services" record with a blank "Services" field, receiving
      in return an "SZG Get Services" record with a "Services" field filled with a
      semi-colon delimited list of service names that are currently posted to this
      szgserver.
```

```
    dpending
      Prints a listing of all service requests that have been posted, but not yet
      fulfilled.
```

A description of the way a component can register its service follows.

+ A component has a service type, such as SZG_GEOMETRY, SZG_SOUND,
SZG_INPUT0, SZG_INPUT1, etc.
Master/slave applications have a service type given by their name (after all,
different master/slave apps form unique service classes). The tag with which the
service is registered depends on the method via which the service was launched.
For instance, if an SZG_GEOMETRY service is launched in the context of virtual computer
cube, the tag will be NULL/SZG_GEOMETRY/cube. On the other hand, if the same service is
launched by user foo, but not on a virtual computer, the tag will be
foo/SZG_GEOMETRY/NULL.

+ The component sends an "SZG Register Source" record to the szgserver, with "Tag" field
containing the tag determined in the previous step and with "Status" field set to
"Try". The "Networks" field contains a slash delimited list of the interfaces available
to the computer For instance, if the computer is connected to the internet and the cube
private network, The "Networks" field will be set to "internet/cube". The
"Addresses" field will contain field will contain a slash-delimited list of the
IP addresses of
the computer's several interfaces, in the same order as their descriptive names.
Since multiple private networks in an installation can contain the same IP addresses,
the network names cannot be infered from the IP addresses. The "Size" field
indicates the number of ports required for the service. Some services, like SZG_GEOMETRY
and SZG_SOUND, require more than one port. Finally, two fields contain configuration
information about the computer on which the component resides. The "Computer" field
gives its name, which is important since the various lists of ports outlined below are
stored on a per-computer basis. The "Block" field defines the port range the computer
has reserved for syzygy services. Note that this port range can, in fact, change.
Mechanisms for dealing with such are outlined below.

+ Upon receipt, the szgserver checks to see if
there is another component already offering this service. If so, an "SZG Broker Result"
record is returned, with the "Status" field marked "SZG_FAILURE".

+ If not, the szgserver checks to see if the block of ports given in the
"SZG Register Source" record is the same as a previously stored block, if any. If no
block of ports has been previously stored (i.e. this is the first time in the szgserver's
lifetime that a component has tried to register a service from that computer), the
various ports lists (available, temporary, and used) are initialized for that computer.
If a block of ports has already been defined for that computer and the new block is the
same (the common case), we do nothing. On the other hand, if the block of ports defined
in the "SZG Register Source" record is different than that already reserved, action needs
to be taken. The old available ports list is removed, and is replaced with the new block,
minus those ports which already appear on the temporary or used lists for the computer
in question (the lists can in fact overlap).

+ Now that the szgserver has adjusted its various ports lists, it checks
its list of ports available for use on the computer on which the component is
running. It picks the first ports on the list (up to the number of ports requested),
marks the "Status" field as "SZG_SUCCESS",  and
stores the port number(s) in the "Port" field, returning the "SZG Broker Result" record
to the requesting component. The port number(s) are then removed from the available list
and are placed on the temporary list (but not yet on the used list) associated with that
computer. The tag is placed on the list of temporary tags.

+ The component now receives the port number(s) and attempts to bind listening sockets
to them, as appropriate, using INADDR_ANY.
Please note that the socket option for reusing addresses
is set to false. Consequently, if a server is not shut down cleanly, it will be a few
seconds before a new server can bind to that port. It may thus be
possible that the bind can fail, especially if some of the port range specified for the
syzygy components on the given computer overlaps with active servers corresponding to
other types of software.

+ If any of the binds fail, the component sends a new "SZG Register Source"
record to the szgserver. This time, the "Status" field is set to "Retry" and the
offending port number(s) are included in the "Port" field.
The szgserver then moves the port
number(s) from the temporary list to the end of the available list, after making sure
that the component sending the record does, in fact, own the ports in question.
Recall that the port(s)
might just be temporarily unavailable, and, since the port list ideally contains 100 or
200 entries, it will not be tried again for a significant amount of time. The szgserver
then sends a new "SZG Broker Result", as above. To avoid a potential infinite loop,
the number of retries is arbitrarily limited to 10, which should be sufficient given
a port list of size comparable to that mentioned above.

+ If the bind succeeds, the component sends an "SZG Register Source" record back
to the server with "Status" field set to "SZG_SUCCESS" and the "Port" field containing the
IDs of
the used port(s). The szgserver then removes the port number(s) from the temporary list and
transfers them to the used list, making sure that the component in question does in fact
own those ports. The tag is then removed from the temporary tag list
and placed on the used tag list.

- Note: in addition to global temporary and used lists, the szgserver maintains these
lists on a per component basis (along with the computer name where the component is
running), keyed on the component's ID. This allows the szgserver
to automatically return these ports to the available list when a component
exits if they are still within the computer's designated ports block.
The same hold true for
tags, though in this case it is unecessary to include computer name, since, unlike port
numbers, the tags are globally unique.


A description of the way a component connects to a registered data source follows.

+ The component forms a service tag as above. It then sends an "SZG Request Source"
with the "Tag" field containing the tag, the "Networks" field containing a slash-delimited
string of possible networks, with the prefered network listed first.

+ The component blocks until a response occurs from the szgserver. This is OK since
all of szg's connection attempts occur in seperate connection threads.

+ When the szgserver receives an "SZG Request Source" record, it first checks to see
if there is a matching tag which has succeeded in registering itself. If not, it saves
the request in a pending connection queue.

+ On the other hand, if a matching tag has succeeded in registering itself, the
"Networks" field of the "SZG Request Source" record is compared with the networks
associated with the tag, and the best match, if any, is found. An "SZG Broker Result"
record will be returned to the requesting component. If no network match was found,
the "Status" field will be set to "SZG_FAILURE", otherwise it will be set to "SZG_SUCCESS".
The "Port" field contains the port number(s) and the "Address" field contains the
IP address of the server. When the client receives this, it issue a connect call on the
the given IP/port pair(s).

+ As data sources are successfully registered, they check the pending connection queue,
responding to each matching tag, as above (and removing them from the pending connection
queue).

+ The pending connection queue, is maintained on a per-component basis, in addition
to being maintained globally, so that, when a component leaves the system, its
pending connections can be removed from the system.


=arSZGClient Methods Associated with Connection Brokering=[BrokeringMethod]

```
  bool arSZGClient::registerService(const string& serviceName, const string& channel,
                                    int numberPorts, int* portIDs);
    Means by which a component starts offering a service for connection brokering. The
    channel determines the networks upon which the service will be offered. Specifically,
    this parameter my be one of "default", "graphics", "sound", or "input", and it
    allows these different services to use different physical networks, if such exist.
    The number of ports needed by the service is given by the "numberPorts"
    parameter, and the "portIDs" parameter provides storage into which the assigned
    ports for the service can be stuffed. This function returns "true" excatly when
    it is successful.
```

```
  bool arSZGClient::requestNewPorts(const string& serviceName, const string& channel,
                                    int numberPorts, int* portIDs);
    It could be that the service cannot use the ports successfully retrieved from
    the "registerService" call. In this case, the service can request the
    assignment of new ports, at the same time telling the szgserver that it was
    unsuccessful in using the previously assigned ones.The meaning of the parameters
    is the same as in "registerService", except that, in this case, the caller passes
    the old, problematic ports in inside the "portIDs" array. This function returns
    "true" exactly when it successfully communicates with the szgserver and receives
    a set of new ports (in the "portIDs" array).
```

```
  bool arSZGClient::confirmPorts(const string& serviceName, const string& channel,
                                 int numberPorts, int* portIDs);
    The service must inform the szgserver that it is, in fact, able to use the
    assigned ports. The meanings of "serviceName", "channel", and "numberPorts"
    are the same as above. The ports that the service successfully bound are
    passed in via "portIDs". Returns "true" exactly when it successfully
    communicates with the szgserver and that program is able to put the
    mentioned ports on the list of used ones.
```

```
  arPhleetAddress arSZGClient::discoverService(const string& serviceName,
                                               const string& networks, bool async);
    A component wishes to connect to a service running somewhere in the distributed
    system. The component mentions the name of the service to which it wishes to
    connect ("serviceName"), gives a slash-delimited list of networks (using symbolic
    names) upon which it would like to communicate to the service ("networks"),
    and specifies whether the "discoverService" call itself should be blocking or
    nonblocking with the final parameter, "async". If "async" is set to "true" and the
    requested service is not currently registered with the szgserver, the szgserver
    will immediately make a failure response and "discoverService" will return an
    invalid arPhleetAddress. If "async" is set to "false" and the requested service is
    not currently registered with the szgserver, the szgserver will make no response
    until the service is in fact registered. In this case, the call to "discoverService"
    will block. Overall, if the call fails, an invalid arPhleetAddress is returned,
    If the call succeeds, a valid arPhleetAddress is returned, containing an IP
    address and a sequence of ports to which the component can connect.
```

```
  bool arSZGClient::requestServiceReleaseNotification(const string& serviceName);
    Requests that the szgserver send us a notification when the named service is no
    longer held by the system. Returns "true" if the szgserver has successfully
    received the request and false otherwise. This is useful in allowing high
    availability services. When a service goes away, another component able to offer
    the service can be notified.
```

```
  string arSZGClient::getServiceReleaseNotification();
    Block until a service release notification has been received from the szgserver.
    When one has been received, return the name of the service that has been
    released.
```

```
  void arSZGClient::printServices();
    Prints the services which are currently being offered in the distributed system.
```

```
  void arSZGClient::printPendingServiceRequests();
    Prints the service requests that have yet to be met in the distributed system.
```

```
  int arSZGClient::getServiceComponentID(const string& serviceName);
    If the named service exists, return the ID of the component offering it. If not,
    return -1. This is useful when a new component must offer a service, even to the
    extent of killing off a previous component offering the same service.
```

