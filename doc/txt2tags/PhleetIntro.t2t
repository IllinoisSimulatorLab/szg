Syzygy Documentation: Introduction to the Distributed OS
Integrated Systems Lab
%%mtime(%m/%d/%Y)
%!options: --headers --toc --toc-level=3
%!encoding: iso-8859-1

[Documentation Table of Contents index.html]

This chapter explains basic operations of Syzygy's distributed operating
system and is the first you
should read when beginning to set up a Syzygy cluster.

+ If your computers are running firewalls, you should definitely read
  [A Note on Firewalls #Firewalls].
+ If this is your first time using Syzygy, [Creating a Cluster #CreatingPhleetOverview] will
  walk you through the basic process of setting up your distributed system.
+ [Virtual Computers #VirtualComputer] make it much easier to manage applications on clusters.
+ [Component Contexts #Context] explaines how to use special command line arguments to
  modify the operation of Syzygy components.
+ To understand how cluster components cooperate, read
  [Connection Brokering and Service Names #Services] and [Locks #Locks].
+ [Troubleshooting #Troubleshooting] explains commonly-encountered problems.


%%toc


=A Note on Firewalls=[Firewalls]

IMPORTANT: Many operating systems today will install a firewall.
The default configuration of this software might very well keep Syzygy from
functioning. As a networked system, Syzygy expects to be able to
communicate on particular ports. The easiest option is to simply not have a
firewall at all. However, this may not be acceptable.

These ports must be allowed through a firewall:

- For Syzygy to operate in a distributed fashion, you will need to create a
  cluster. This involves running an szgserver, which requires specifying a
  port for incoming TCP connections. The computer on which
  szgserver runs must allow connections to this port.

- The "dhunt" and "dlogin" commands rely on UDP packets reaching port
  4620 to operate properly.

- Each computer that is part of the cluster will require a block of
  ports for Syzygy components to connect to one another. This
  block is defaults to port number 4700-48999, but it can be set
  manually using the ``dports`` command. TCP connections to this block of ports
  must be let through your firewall.


=Creating a Cluster: Overview=[CreatingPhleetOverview]

Syzygy's distributed operating system performs the following tasks:
+ It helps programs share data with one another.
+ Stores configuration information for users.
+ Provides an interface for managing a cluster's software components.


The central component of a cluster is the Syzygy server, ``szgserver``.
The most common configuration will
be a group of related computers, with a single szgserver running on one of them
and providing the distributed operating system for all the users of the
cluster. We will focus on setting up such a system. However,
different users on different computers can be connected to different
Syzygy servers if desired, easily changing their associations over time.

NOTE: szgserver is meant to run in the background for a long
time (like a linux daemon or windows service).
Here are some common misunderstandings:
- Do not run a new copy of szgserver for each application.
- Do not run a copy of szgserver on every computer in your cluster.


=Creating a Cluster: Configuring Computers=[ComputerConfig]

This section shows you how to configure each computer in your
cluster using some of Syzygy's command-line tools: ``dname``, ``daddinterface``,
``ddelinterface``, and ``dports``.


==szg.conf Configuration File Location==

Network interface data are stored in a file named //szg.conf//. The default location
of this file varies by platform:
- On Unix-like operating systems (Linux, Mac OS X, Irix), the
  default location is in /etc/. Note that non-root users cannot write to /etc, so
  initial network configuration must be done as root if the default location is
  used.
- On Windows, the default location is in c:\szg\.


If desired you can set the environment variable SZG_CONF to the path to a directory
where this file should be created. Note that all Syzygy users MUST be able to change
into the directory containing the szg.conf file.

Every Syzygy program will try to //read// the szg.conf file, but they generally do
not try to //write// to it. It must
exist for programs to work in Cluster Mode but it is not
necessary for programs to work in [Standalone Mode Standalone.html].


==Creating szg.conf==

To create szg.conf, perform the following steps (to perform these steps you must have
write access to the directory where szg.conf will be created):

+ Login to the computer to be configured.
+ Assign the computer a Syzygy name. This name must be unique across all the computers in your
  system. A good choice is the short version of your computer's DNS name
  (e.g. foobar.isl.uiuc.edu becomes foobar) but other names are possible. We assume
  that you can write to the file's location. For example, type:
```
  dname foobar
```
+ szg.conf must contain information about the network interfaces
  in the computer, specifically the IP address and netmask.
  In addition, each interface must be assigned to a Syzygy network.
  To add an interface to the config file:
```
  daddinterface network_name address [netmask]
```
  "network_name" assigns the interface to a particular Syzygy network. Internet
  addresses should use the name "internet". Private networks can use an arbitrary
  name, but this should be consistent across the private network and
  different from that assigned to other private networks in the distributed
  system. For example, the distributed system might contain 2 clusters,
  each connected internally by a distinct 192.168.0.XXX private network. In
  this case, the network_name associated with each should be different. This
  lets Syzygy operate properly with respect to connection brokering.

  The primary or default network for each computer should be added //first//.
  This network should be one to which all computers in the distributed system
  are connected. Components will expect to connect to the szgserver on this
  network. Furthermore, if components have a choice about how to connect to
  one another (i.e. they are connected by several networks), they will
  default to using the first network.

  You can optionally specify a netmask for the interface. By default,
  a netmask of 255.255.255.0 is used.

  You can remove networks from the config file using the following command:
```
  ddelinterface network_name address
```

  Syzygy operates using connection brokering. This means that you will not explicitly assign
  the ports on which servers will listen for connections. Instead, Syzygy
  will assign the servers' ports based on a pool it maintains
  on a per-computer basis. By default, the block of ports numbers 4700-4799 is used, which
  is likely to be OK on both Unix and Windows machines. However, you can
  change this block using the following command:
```
  dports first_port num_ports
```
  This command allocates a block of ports beginning at "first_port" and
  containing "num_ports" ports. IMPORTANT: you'll want every port in this
  block to be free and user services to be able to bind to them.
  The block should be of reasonable size in order to
  accomodate all the services that might run on the computer. It
  is best to be generous when assigning the size.
  NOTE: some Windows versions do not like user services to bind to
  ports 5000 and above.

+ After issuing these commands, you can check the stored config
  file by typing:
```
  dconfig
```
  The output might look something like this for a computer with two network
  interface cards:
```
  computer = foobar
  network = internet, address = 999.999.999.999, netmask=255.255.255.0
  network = private_net, address = 192.168.0.1, netmask=255.255.255.0
  ports = 4700 - 4899
```


=Creating a Cluster: Running szgserver and szgd=[RunningSzgserver]

In this section we show you how to run //szgserver//, the program that
controls the Syzygy distributed OS, and //szgd//, the Syzygy remote
execution daemon. These programs will form the backbone of your cluster,
enabling you to control it from an arbitrary location on your
network.

+ Choose a computer that will act as the server machine for the
  distributed OS. This is where the szgserver program will run. Do not
  run szgserver on more than one computer. The syntax for the szgserver
  command is as follows:
```
  szgserver server_name server_port [network_1] ... [network_n]
```
  You need to give the szgserver program a name, server_name, which
  can be anything. You must also give it a server_port at which it listens
  for connections and the IP address of the server machine. DO NOT
  choose a port within the ports block printed by ``dconfig``;
  that block must be free for connection brokering. The optional
  "network" arguments allow you to specify a whitelist: a set of
  IP address ranges from which your server will accept connections.
  If you do not specify any network ranges, the szgserver will accept
  connections from anywhere. The whitelist is specified as a list
  of address/netmask pairs, for example:
```
  192.168.0.0/255.255.255.0
```
  will only be matched by IP addresses that, when masked by 255.255.255.0,
  equal 192.168.0.0.

  The following szgserver will accept a connection on
  port 4343 from IP address 192.168.0.224 but not from address 10.0.0.2.
```
  szgserver generic 4343 192.168.0.0/255.255.255.0
```

  A reminder about firewalls:  if one is running on the computer running
  szgserver, poke holes for UDP port 4620 and whatever TCP port you
  specified as the "server_port" argument to szgserver.

+ To interact with the system, you'll need to login to the szgserver, which
  is done on a per-OS-user-per-computer basis. Type:
```
  dlogin server_name syzygy_user_name
```
e.g.
```
  dlogin generic johndoe
```
  "server_name" should be the parameter of the same name used to start the
  szgserver; "syzygy_user_name" will be your Syzygy user name.
  This command associates a Syzygy user name with the current operating system
  (Windows, Unix) user name. Any subsequent commands issued on that computer
  while logged in as that operating system user will be interpreted by Syzygy
  as being issued by the specified Syzygy user. To change Syzygy users for a
  given OS user you can either (a) dlogin as a different Syzygy user, or
  (b) dlogout, which disconnects you from any szgserver.

  The foregoing assumes that braodcast packets can travel between the computer
  you're dlogging in on and the one running the Syzygy server. You haven't
  specified the IP address and port for the server, so ``dlogin`` has to
  broadcast to find it. Another command that uses broadcase to find
  szgservers is
```
  dhunt
```
  ...which will print a list of servers on the local subnet (i.e. servers
  that can be found via broadcast).

  If your server //isn't// on the same subnet (and therefore doesn't show up
  in the list printed by ``dhunt``), you'll need to use an alternate form
  of ``dlogin`` in which you specify the szgserver IP address and port:
```
  dlogin server_IP_address server_port syzygy_user_name
```
e.g.
```
  dlogin 999.999.999.999 4343 johndoe
```

  As you can see, there is currently //no authentication// of Syzygy users.

  The ``dlogin`` commands creats a login file named "szg_<OS_user_name>.conf.
  Its default location varies by platform:
  - Unix: /tmp/
  - Windows: c:\szg\

  As with szg.conf, you can specify a directory for login files by setting
  the environment variable SZG_LOGIN to the path to a directory.

  Upon successful dlogin, the information in the login file will be printed,
  looking something like:
```
  OS user     = schaeffr
  syzygy user = ben
  szgserver   = "generic", 999.999.999.999:4343
```

  You can access this information at any time by typing:
```
  dwho
```

  dlogin works as follow: When connecting to the szgserver
  via name, it reads the szg.conf file. It then
  sends broadcast packets on each of the network interfaces listed there
  The szgserver continually listens for such packets.
  If it receives one tagged with its own name it returns information about
  how to connect.

  This process can fail in several ways. The failure possibilities and remedies are:

  - Broadcast packets may be filtered by the network between dlogin and the szgserver.
    For example, the loopback interface (127.0.0.1) filters broadcast
    packets on several systems supported by Syzygy (e.g. Mac OS X).
    You can work around this by explicitly specifying the szgserver address and port:
```
  dlogin szgserver_IP_address szgserver_port syzygy_user_name
```

  - The networks in the Syzygy config file on the machine on which dlogin was issued
    may be incorrect. Check them again using dconfig.

  - The szgserver name given in dlogin and the name of the running szgserver may be
     different. Make sure they are the same.

  - The szgserver tells dlogin to connect using the //first// address in the szg.conf
    file on the szgserver machine. The machine from which you are trying to dlogin must
    be able to reach this IP address. If not, use ``ddelinterface`` and ``daddinterface``
    to reorder the addresses in the szg.conf file on the szgserver machine.


+ Now run the remote execution daemon //szgd// on each machine in the cluster.
```
  szgd <base_paths> [-r]
```
  The required base_paths argument is intended as a security measure. It should
  be a semicolon-delimited list of paths to directories or executables, and paths
  to executables should not include the '.exe' suffix on Windows. ``szgd`` is in
  charge of launching programs on each machine in your cluster in response to a
  remote command. It will //only// launch programs whose full path begins with
  one of the paths in the base_paths list. For example, on Windows you probably
  do //not// want it to include c:\Windows\. You might type:
```
  szgd c:\myapps
```
  ``szgd`` immediately attempts to connect to the szgserver that you are currently
  dlogged into. By default, it exits on failure to connect. If the optional ``-r``
  argument is passed it will instead repeatedly attempt to reconnect on failure.

+ Now, on any machine in the distributed system, type "dps". You'll see something like:
```
  computer1/szgd/0
  computer2/szgd/1
  computer3/szgd/2
  computer4/szgd/3
  computer5/szgd/4
  computer6/szgd/5
```
  i.e. "computer name"/"process name"/"process ID".
  There should be a line for each computer on which you have run szgd.


=Using a Virtual Computer=[VirtualComputer]

For information on //defining// virtual computers, see
[Virtual Computer Configuration VirtCompConfiguration.html].

To launch an application on a virtual computer, you will need a copy of
szgd running on every "mapped" machine, i.e. any real computer whose name appears as
the value of a "<something>/map" parameter value in the virtual computer definition.
Once this is done, to launch atlantis
(a sample application included with the szg source) on
virtual computer ``vc``, use the command:
```
  dex vc atlantis
```

There are two ways to kill an application running on the virtual computer.
You can directly kill the trigger instance. For that you need to know the
//location// parameter of the virtual computer. For the example virtual
computer defined in
[Virtual Computer Configuration VirtCompConfiguration.html], that would
be "my_room", so you would type:
```
  dmsg -c my_room quit
```

Or you can type:
```
  dkillall vc
```

Here are several useful commands for managing a virtual computer:

```
  dkillall virtual_computer
```
   Kill any application currently running on the given virtual computer,
   along with any associated services such as szgrender, SoundRender, or
   DeviceServer.

```
  dmsg -c virtual_computer_location quit
```
   Kills the application, if any, currently running in the given virtual
   computer //location//, but leaves services alone.

```
  restarttracker virtual_computer
```
   Restart services associated with virtual_computer (e.g.
   input devices and sound).

```
  setdemomode virtual_computer [true, false]
```
   If second argument is "true", this sets each render machine to use a fixed
   head position rather than that reported by the tracking device. The head
   position is read from the active screen definition (see
   [Graphics Configuration GraphicsConfiguration.html]) on each render computer.
   Each rendering machine will assume that the direction of gaze is perpendicular
   to its display, and the up direction of the head will be the screen's up
   direction rotated by the angle (in degrees) given by the screen's
   fixedheadupangle element. To set things back to normal mode, use "false"
   as the second argument.

```
  setstereo virtual_computer [true, false]
```
   Turns active stereo rendering on and off for each rendering machine of the
   cluster.

```
  screensaver virtual_computer
```
   Start szgrender programs on each render machine in the cluster. Since
   szgrender is black when no application is connected, this is effectively a
   screensaver.

```
  calibrationdemo virtual_computer
```
   Display a calibration screen useful for alignment and color matching,
   looking for the calibration picture cubecal.ppm in the SZG_DATA/path of
   each render machine.


=Component Contexts=[Context]


==What is the Component Context?==

Every component in Syzygy is executed in a "context". The context
determines the overall behavior of the component, whether the component
is executing as part of a virtual computer, and what networks it will use
for various sorts of communication. It consists of a list of
variable/value pairs, as listed below:
```
  virtual=virtual_computer_name
```
   The name of the virtual computer on which this component is
   executing. Set to the value "NULL" if it is not executing
   on a virtual computer (the default).

```
  mode/default=[trigger, master, component]
```
   The overall behavior of the component. The "trigger" value
   causes a syzygy application to run as a trigger instance,
   launching other necessary components on a virtual computer.
   The "master" value causes a master/slave component to
   take the master role. The "component" value is a default
   and has no effect.

```
  mode/graphics=SZG_DISPLAY(n)
```
   One of SZG_DISPLAY0, SZG_DISPLAY1, etc. If the component opens
   a graphics window, this determines the screen configuration
   it will use from among those defined for the computer it is
   running on. If you specify a display that isn't defined,
   a default display configuration will be used.

```
  networks/default=network_list
```
   The value network_list is a slash-delimited list of network names,
   like internet/my_private_net. It indicates, in descending order of preference,
   the network across which service connections should occur,
   assuming that the service type (input, graphics, sound) has
   not already specified this.

```
  networks/input=network_list
```
   Defines the network across which input service connections
   should occur.

```
  networks/graphics=network_list
```
   Defines the network across which graphics service (szgrender)
   connections should occur.

```
  networks/sound=network_list
```
   Defines the network path upon which sound service connections
   should occur.

```
  parameter_file=parameter_file_name
```
   If the application is running in [Standalone Mode Standalone.html]
   it reads its parameter database from a file in its current working
   directory. By default it looks for szg_parameters.xml and then
   szg_parameters.txt, but this can be changed by passing this special parameter.

```
  user=syzygy_user_name
```
    The Syzygy user under whose auspices the application will run.

```
  server=IPaddress/port
```
    Identifies the location of the szgserver to which the component should
    attempt to connect.


Note those last two items in particular: By manipulating them you could run a component
as a different user and connecting to a different Syzygy server from the one
you are currently dlogged into.


==Manipulating Component Contexts==

Normally when you launch an application on a virtual computer
the application launching process sets up the context appropriately for
each launched component. However, sometimes you will want or need to set
the context manually; for example, you may need to restart an individual
component of an application running on a virtual computer. This can be
done in two ways: (1) By setting the SZGCONTEXT environment variable, or
(2) by passing special arguments on the command line.


===Setting SZGCONTEXT===

The value of SZGCONTEXT should consist of a sequence of the above pairs seperated
by ';'. You can set this environment variable manually to control the behavior
of Syzygy components on a particular computer. A sample one might look something like:
```
  virtual=vc;mode/graphics=SZG_DISPLAY0;networks/graphics=my_private_net
```


===Command-line Context Manipulation===

To manipulate a context from the command line, pass "variable=value" pairs
preceded by "-szg". For example:
```
  syzygy_executable -szg virtual=vc -szg networks/graphics=internet
```

Obviously, this method is more flexible than setting an environment variable,
but it has a weakness: It depends on all Syzygy components (including any
applications that you write) processing command-line arguments //after//
the Syzygy client object, ``arSZGClient``, has been initialized
(``arSZGClient::init()``). In framework-based applications (see
[Programming Programming.html] this happens in the framework object's
``init()`` method. When this method is called the special arguments are
parsed and removed from the global argv variable, so the application or
component won't be faced with them.

Yet another advantage to this method of manipulating the context: It can
be used remotely. When you launch an application using the ``dex`` command,
most context variables specified on the command line are passed on to the
component being launched. For example:
```
  dex render1 szgrender -szg virtual=vc
```
will launch szgrender on computer "render1" and tell it to behave as a
component of virtual computer "vc".

dex will interpret the "user" and "server" arguments, allowing you to launch
applications as a different user or even on a different cluster from those
specified in the login file. For example:
```
  dex vc_far_away my_app -szg server=faraway_IP_address/faraway_port -szg user=somebody_else
```


=Connection Brokering and Service Names=[Services]

Connections to Syzygy services such as input event streams, sound output,
and scene-graph rendering are brokered by the Syzygy server ``szgserver``
using a service name. Components
that provide a service with a particular name will fail to launch if another
provider of that same service name is already running, so
it is important to understand how services get their names and
how to find out what services are offered.

Service names are parially determined by the nature of the service
(the "basic service name") and
partially by the circumstances under which a component is launched.
If a user launches a component, but //not// in the context of a
virtual computer, the component's service name will be:
```
  basic_service_name/syzygy_user_name
```
This prevents the actions of one syzygy user from interfering with those
of another.

On the other hand, if a user launches a component in the context of
a virtual computer, the component's service name will be:
```
  virtual_computer_location/basic_service_name
```
(see [Virtual Computer Configuration VirtCompConfiguration.html]).
This allows different users to share application components running in
a particular virtual computer location, allowing them to be used as
a communal resource.


==Base Service Names==

Base service names for the various syzygy service are listed below.

```
  SZG_INPUT#
```
   An input-event service: One of SZG_INPUT0, SZG_INPUT1, etc.
   The number refers to the driver slot.???
   inputsimulator and DeviceServer offer this service. DeviceClient
   and Syzygy applications in general must connect to it in order to
   receive input from trackers, joysticks, gamepads, and so on.

```
  SZG_SOUND
```
   A source of sound information. The sound-playing component SoundRender
   needs to //receive// or connect to this service.
   Syzygy VR framework applications (see [Programming Programming.html]) //offer// it.

```
  SZG_SOUND_BARRIER
```
   Synchronization for the SZG_SOUND service. SoundRender connects to this
   service. Syzygy VR framework applications offer it.

```
  SZG_GEOMETRY
```
   A source of scene graph information, generally a distributed scene
   graph framework application (see [Programming Programming.html]).
   The scene-graph rendering component szgrender needs to connect to this
   service.

```
  SZG_GEOMETRY_BARRIER
```
   Synchronization for the SZG_GEOMETRY service. szgrender needs to
   connect to this service. Distributed scene graph applications offer it.

```
  SZG_MASTER_<application_name>
```
   The master instance of a master/slave application
   (see [Programming Programming.html]) offers data to the
   slaves via this service. Slave instances try to connect to this service.

```
  SZG_MASTER_(application_name)_BARRIER
```
   Synchronization for the above service.


==Examining Running Services==

Examining services can be helful in debugging problems with components
not connecting properly.

For a list of currently-offered services, type:
```
  dservices
```
For a list of pending service requests, i.e. requests that have not
yet been able to connect to a provider of the requested service, type:
```
  dpending
```


==How it All Fits Together==

Consider a brief example.

You launch a distributed scene graph application. It signals the connection
broker in the server that it requires an SZG_INPUT service (for user input)
and provides SZG_GEOMETRY and SZG_SOUND services (i.e it is a source of
virtual-world-object and sound information).

The connection broker notes that there is a running DeviceServer providing
SZG_INPUT0, several szgrenders on various computers requesting SZG_GEOMETRY,
and a SoundRender requesting SZG_SOUND. In each case, it sends the IP address
and port of the service provider to the components requesting the service,
allowing them to connect and satisfy their cravings.


=Locks=[Locks]

Locks are used to ensure that sequences of networked operations occur
atomically. They work like mutexes within a single, multi-threaded
program, but are instead maintained by the Syzygy server to synchronize
operations of multiple programs on different computers.

For example, as noted in [Virtual Computer Configuration VirtCompConfiguration.html],
overlapping virtual computers can be assigned a common "location" parameter.
Virtual computers with the same location parameter are assumed to share
machines. If one user launches an application on one such virtual computer,
you don't want anyone else to be able to start another program on an
overlapping virtual computer at the same time.

To prevent this, the first application to launch requests a lock with the
name "<virtual_computer_location>/SZG_DEMO/lock". It holds the lock
until all of its components have launched, then releases it.
Other applications attempting to launch on another virtual computer with
the same location parameter will request the same lock and will be blocked
until they can acquire it.

Locks are also used to reserve resources. Some Syzygy components are not
allowed to run if another instance of the same component is already running
on the same computer. When such a component starts, it requests a lock
and does not release it until it exits; other instances attempting to start
in the meantime will be unable to aquire the lock and will exit.
Here are a few components and their named locks:
- szgd:         <computer_name>/szgd.
- SoundRender:  <computer_name>/SoundRender.
- DeviceServer: <computer_name>/DeviceServer.
- szgrender:    <computer_name>/SZG_DISPLAY# (# is determined by the display
  it is using, see [Graphics Configuration GraphicsConfiguration.html]). Multiple
  szgrenders can run on the same computer if they use different displays.


Finally, locks facilitate automatic shutdown of previously running
applications. If a new application requires a particular resource
(for example, it needs to run a rendering component on render1/SZG_DISPLAY0),
it requests the associated lock. If the request fails, the server sends
the Syzygy process ID of the component holding the lock to the application.
The new application then sends the offending component a "quit" message and
waits for the lock to be released.

To see the existing locks, type:
```
  dlocks
```


=Troubleshooting=[Troubleshooting]

When things go wrong, e.g. an application or application
component does not launch or two components refuse to connect, the user
needs to understand connection brokering, locks, and the tools
to examine them. Misconfiguration or misuse of
these features is a major cause of problems when using Syzygy.

- szgrender, SoundRender, szgd refuse to launch: Each of these components
holds a Syzygy lock corresponding to a real world resource during its
operation. For szgrender, it is a given chunk of screen real estate. For
SoundRender, it is the sound card. For szgd, it is the computer itself.
In the case of szgrender, executing a second copy to display on
the same virtual screen (SZG_DISPLAY0, SZG_DISPLAY1, etc.) as an already
running szgrender will cause the second copy to quit with
the following error message (the component ID will vary):
```
  szgrender error: failed to get screen resource held by component <ID##>.
```
This is the desired behavior when a resource cannot be shared.
- A Syzygy VR framework application (see [Programming Programming.html])
that is run on a real computer but not as part of a virtual computer
fails to launch with the following error message:
```
  arSyncDataServer error: failed to register service.
```
Again, this is an expected behavior. The VR framework application wants to
offer an SZG_SOUND service. If it is not run as part of a virtual computer,
its service name will default to "SZG_SOUND/<syzygy_user_name>".
If the same user runs a second framework application on a different computer,
it will attempt to provide exactly the same named service. This is not allowed,
otherwise SoundRender would not know which of the two to connect to.

- Component A does not connect to Component B even though it should: First, you
should run a [Connection-Brokering Test #TestingPhleet].
If this tests succeeds, one of the following is almost certainly true:
  - Neither component is being run on a virtual computer, but they are
      being run with different user names. You might have dlogin'ed
      with different Syzygy user names on the different computers. In this case, you
      must be dlogin'ed with the same Syzygy name on both computers.
  - One component is being run on a virtual computer but another is not.
      Again, this will fail. Both must be running in the same virtual computer
      location. Recall that every virtual computer has a location; if not
      specified, it defaults to the virtual computer name.
  - One component is being run in virtual computer location L1 while the
      other is being run in virtual computer location L2. Again, this is
      going to fail. The virtual computer locations must be the same for
      the components to connect.

You can diagnose these problems by running "dservices" to see the names
of services which are being offered and by running "dpending" to see the names
of unfulfilled service requests. You should see the full name of the offered
service, the full name of the request, and see how they fail to match.

- A computer running some Syzygy components crashed, had its power
cord yanked, etc. Now these components are stuck in the Syzyg process table,
i.e. they still show up int the list of processes printed by ``dps``.
Furthermore, new instances of those components cannot be launched. Assume for
the sake of example that the relevant component is ``szgd``. The problem
occurs because the ``<computer_name>/szgd`` lock was
never released because ``szgd`` did not exit normally. The solution is to type:
```
  dkill -9 szgd
```
(or whatever the actual component name is). This forcibly removes the
component name from the Syzygy process table and releases the relevant lock.


==Connection-Brokering Test==[TestingPhleet]

To verify that basic connection brokering works between computers in
your cluster:

+ Start BarrierServer on one of your cluster machines.

+ Start BarrierClient on another machine. If all is well, the BarrierClient will
begin printing the average time necessary to perform each synchronization
through the BarrierServer.

  Troubleshooting:
  - If BarrierClient fails to start, make sure dlogin succeeded on the
      machine on which it is running..
  - If BarrierClient starts but does not start printing, you have entered the
      IP address incorrectly in the szg.conf file on the BarrierServer machine.
      Use dconfig to examine it and ddelinterface/daddinterface to fix it.

+ Start BarrierClient on other machines.

+ Kill BarrierServer and restart on another machine. If the various running
    BarrierClients do not reconnect, see the troubleshooting section above.


