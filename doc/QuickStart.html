<html>
<head>
<title>Syzygy Quick Start</title>
</head>
<body bgcolor="#ffffff">
<a href="index.html">Documentation Index</a>
<p><font size=+2>Syzygy Quick Start</font>

<p>NOTICE: This is Syzygy version 0.7. 
If you have been using an earlier version,
consult the <a href="ChangeLog.html">Change log</a> for how to 
modify earlier practices.

<p><font size=+2>What you should know</font>

<p>This quickstart assumes that you know the fundamentals of how makefiles,
environment variables, libraries, and shared libraries work.

<p><font size=+2>Topics Covered</font>

<p>After reading this chapter, you'll be able to set up a Syzygy cluster
and run various of the included demos. You'll also learn how to use some
of the interface programs, like wandsimserver (a desktop GUI that simulates
VR-style input devices) and JavaInterface (a Java GUI that lets you control
the cluster).

<p><ul>
<li><A HREF="#Requirements">Requirements</a>
<li><A HREF="#BuildEnvVar">Syzygy Build Environment Variables</a>
<li><A HREF="#VCCEnvVar">Visual C++ Command-Line Environment Variables</a>
<li><A HREF="#SupportLibs">Installing Supporting Libraries</a>
<li><A HREF="#CompileSyzygy">Compiling the Syzygy Toolkit</a>
<li><A HREF="#CompileDemos">Compiling the Demos</a>
<li><A HREF="#InstallData">Installing the Optional Data Distribution</a>
<li><A HREF="#InstallDemos">Installing the 2nd Tier Demos</a>
<li><A HREF="#Firewalls">A Note on Firewalls</a>
<li><A HREF="#CreatingPhleet">Creating a Phleet</a>
<li><A HREF="#SimpleTest">Simplest Possible Distributed Graphics Test</a>
<li><A HREF="#ManagingPhleet">Managing the Phleet</a>
<li><A HREF="#DBExamples">Database Parameter Examples</a>
<li><A HREF="#ConfidenceTest">Running the Distributed Graphics Confidence Test</a>
<li><A HREF="#MasterSlave">Running a Master/Slave Application</a>
<li><A HREF="#VirtualComputer">Using Virtual Computers (Best Way to Launch an Application)</a>
<li><A HREF="#Advanced">Advanced Configuration and Demo Information</a>
<li><A HREF="#TrackingSim">Using the Tracking Simulator Interface</a>
</ul>

<A NAME="Requirements">
<p><font size=+2>Requirements</font>
</a>

<p>Syzygy works on Linux, Windows, Mac OS X, and Irix platforms. 
   Please read the notes below for your platform(s).

<p>Some of the included demos require additional libraries and data, discussed below.

<p>Linux: 
<p><ol>
<li>Most current versions include OpenGL libraries via Mesa. 
  Hardware-accelerated graphics can be set up with minimal effort. 
  NVidia graphics cards have high-quality <a href="http://www.nvidia.com">drivers</a>.
<li>GLUT is not installed by default in many Linux distros. However,
  it is very easy to find it on the <a href="http://www.opengl.org">web</a> 
  and compile it. Note that Mesa includes GLUT.
  Headers for GLUT and the .so must be installed in /usr/include/GL and /usr/lib,
  as is standard.
<li>IMPORTANT NOTE: for reliable operation, syzygy requires a thread-safe libc++.
  gcc-2.96 fails in this regard, so occasional problems will be observed on,
  for instance, RedHat 7.0 and RedHat 7.1, which use this compiler, when 
  deployed in an SMP configuration. The solution is to use an earlier or later
  version (RedHat 6.2 is OK as is RedHat 8.0). For other Linux distros, consider
  that gcc-3.2.x is known to work.
<li>IMPORTANT NOTE: the Syzygy build environment produces code for the i686 architecture
  by default.
  If you have an older processor, you need to change the "-march=i686" flag in
  szg/build/make/Makefile.defines. Experiment with either removing it or 
  downgrading, for instance to "-march=i586".
</ol>

<p>Windows: Syzygy's build system uses GNU make and the command line Visual Studio
  compiler and linker. This has been tested with Visual Studio 6.0 and Visual
  Studio .Net. Reports of compilation trouble with earlier versions of Visual Studio 
  are welcome.
  
<p>You will need a unix-like shell for Windows that provides a GNU make utility. We
  have tested two, MinGW/MSYS and Cygwin. If you're not currently using either, we
  recommend MinGW (except perhaps for Win98, see below); Cygwin is a much larger package
  and at the time of writing is
  only available as a network installer. MinGW is relatively small and comes as
  two self-contained installers, which we have included in our distribution. You can
  also check for more recent versions at
  <a href="http://www.mingw.org/">www.mingw.org</a>. Run the MinGW installer first,
  then the MSYS installer. If you do install
  Cygwin (<a href="http://www.cygwin.com/">www.cygwin.com</a>) instead, make sure that
  the checkboxes for make and for bin/utils are checked. If you don't plan to use
  Cygwin for anything else, you can create
    a minimum-disk-space Cygwin which will still build Syzygy by 
    selecting only these packages (uncheck <i>all</i> other checkboxes):
    <dl>
    <dt>Category: Base
        <dd>ash bash cygwin fileutils login sh-utils
    <dt>Category: Devel
        <dd>bin-utils make
    <dt>Category: Shells
        <dd>ash bash sh-utils
    </dl>
<li>Install MS Visual Studio.  When it asks if you want to use
    the tools from the command line, answer "yes." Note that this
    document also shows you the right environment variable settings
    in the <A HREF="#VCCEnvVar">VC++ Command Line Environment Variables section</a>.
<li>Install <a href="http://www.xmission.com/~nate/glut.html">GLUT</a>.
    For a standard install of Visual Studio 6, the directory:

<pre>
    Microsoft Visual Studio/Vc98/Include/GL
</pre>
 
    should hold the includes and

<pre>
    Microsoft Visual Studio/Vc98/Lib
</pre> 

    should hold the libraries.
    For Visual Studio .Net 2003, use these directories instead:
 
<pre>
    Microsoft Visual Studio .NET 2003/Vc7/PlatformSDK/Include/gl
    Microsoft Visual Studio .NET 2003/Vc7/PlatformSDK/Lib
</pre>

<li>IMPORTANT: Make sure that your SZGHOME environment variable is set to the
    top-level of your szg tree. See below.
<li>Launch a (MSYS or Cygwin) shell. Check that the PATH environment variable includes
    the directory containing cl.exe and link.exe (the Visual Studio compiler
    and linker). Directories containing dll's used
    by the compiler and linker will also need to be in the BIN path.
<li>The software will run on Win98, NT, Win2K, and Win XP. Note that there appear to
    be problems with timing if some of the Syzygy executables are run directly from
    the MSYS shell; specifically, the MSYS shell is not yet very good and outputing
    text. In general, we recommend running commands from a regular Windows shell (cmd.exe).
<li>IMPORTANT: the support for Win98 is limited, with normal usage necessitating
    a work-around noted below. Specifically, the various syzygy
    components check argv[0] to determine their name. Unfortunately, on Win98 when 
    an executable is run from cmd.exe (the default shell), it
    is impossible to retrieve the executable name with case preserved from argv[0]. 
    Hence, a few critical components (szgd, SoundRender, and DeviceServer) 
    have their correct names hard-coded. There will be problems running other 
    components on Win98 from cmd.exe. However, the components can be run from
    the Cygwin shell. We don't know how they will behave if run from the MSYS shell,
	which is why people using Win98 might need to install Cygwin. This workaround
	allows normal operation on Win98.
</ol>

<p>Mac OS X: GLUT is already installed so things will compile out of the box.
   Note that early versions of Mac OS 10.2 have difficulty launching OpenGL windows
   from the command line (the launched window might not be able to get
   keyboard focus). Consequently, at least version 10.2.5 is recommended. 
   The only additional library supported is fmod (though it might be easy to get others
   to work). One important note, however. Since the source uses dlopen,
   you need to compile szg/contrib/dlcompat. This is a simple:

<p><ul>
<li> cd szg/contrib/dlcompat-20020709
<li> make
</ul>

<p>Irix: Unfortunately, the code is unstable on Irix due to the difficulty of 
  finding a thread-safe compiler/libc combo. Any help here would be appreciated!
  However, you will, at least, be able to try the software.

<a NAME="BuildEnvVar">
<p><font size=+2>Syzygy Build Environment Variables</font>
</a>

<p>The Syzygy build process uses recursive make. A top-level Makefile in
szg/build guesses the operating system and then executes the appropriate
Makefiles. For instance, there are both szg/build/win32/language and 
szg/build/linux/language directories. On a Windows machine, the Makefile in 
the first directory is executed. The Makefile guesses the operating system
via uname, defaulting to the OSTYPE environment variable if this fails. 
If the top-level makefile fails to guess your machine type, you can fix the 
problem by setting the OSTYPE (to "linux" or "cygwin", for instance).

<p>Several environment variables should be set to tell the makefiles
where certain things are. You MUST set SZGHOME. SZGEXTERNAL is 
optional (but needed
if you want to use any of the additional libraries). SZGBIN is also optional.
If you want to do a debug build on Linux or Win32, SZGDEBUG must be
set to TRUE. By default, a non-debug build is produced. 

<p>Syzygy also uses two environment variables, SZGUSER and SZGCONTEXT,
to route internal communications to programs. Their use is explained below.
<p><ul>
<li>SZGHOME: required. The top-level syzygy directory 
  (for instance, /home/user1/szg).
<li>SZGBIN: optional. Where to put the binaries.  
  If this is not set it defaults to
  szg/bin/$(MACHINE_TYPE), where MACHINE_TYPE is one of linux, win32, darwin,
  mips3, or mips4. (These last two refer to SGI processor families.)
<li>SZGEXTERNAL: optional. The location of external
  libraries like sound and motion tracking. If this is not set,
  the code will compile but disable support for such features.
  Libraries are expected to be in subdirectories of $(SZGEXTERNAL)/lib,
  headers in subdirectories of $(SZGEXTERNAL)/include.
<li>SZGDEBUG: optional. If set to "TRUE", a debug build will be produced.
<li>SZGUSER: internal usage only. If this is set, a Syzygy component will
  attempt to run under the identity of user $(SZGUSER).
<li>SZGCONTEXT: internal usage only. This variable records the "context"
  under which a component attempts to execute.For instance, SZGCONTEXT
  encodes which virtual computer will be used, the particular virtual
  screen (i.e. SZG_SCREEN(n)), etc.
</ul>

<p>In Windows, <i>use forward slashes instead of backslashes</i> (otherwise
the VC++ compiler doesn't understand what the GNU makefile tells it).
For example:
<pre>
  SZGHOME=D:/szg
  SZGEXTERNAL=g:/public
</pre>
Also use drive letters ("D:/...") instead of the Cygwin abbreviations
"/cygdrive/d/..." or "/d/...", so the latter aren't misinterpreted as
MSDOS-style slash-delimited options.  Isn't multiplatform wonderful.

<A NAME="VCCEnvVar">
<p><font size=+2> Visual C++ Command-Line Environment Variables</font>
</a>

<p>The Windows build environment invokes the VC++ tools from the command line,
via GNU make and the Cygwin shell. If you haven't set up VC++ to 
run from the command line, compiling will fail. Possible error messages 
include not being able to find cl.exe (the compiler) and the linker not
finding required dll's. Here are the settings for the
environment variables include, lib, MSDevDir, and path that work with
a standard install of Visual Studio 6.0.

<pre>
include
  C:\Program Files\Microsoft Visual Studio\VC98\atl\include;
  C:\Program Files\Microsoft Visual Studio\VC98\mfc\include;
  C:\Program Files\Microsoft Visual Studio\VC98\include

lib
  C:\Program Files\Microsoft Visual Studio\VC98\mfc\lib;
  C:\Program Files\Microsoft Visual Studio\VC98\lib

MSDevDir
  C:\Program Files\Microsoft Visual Studio\Common\MSDev98

path
  C:\Program Files\Microsoft Visual Studio\Common\Tools\WinNT;
  C:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin;
  C:\Program Files\Microsoft Visual Studio\Common\Tools;
  C:\Program Files\Microsoft Visual Studio\VC98\bin
</pre>

<p>The following work with a standard install of Microsoft Visual
Studio .NET 2003.  (In Windows XP, it helps if these are "user variables"
rather than "system variables" -- the Cygwin shell inherits values from
the former.)

<pre>
include
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\ATLMFC\INCLUDE;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\INCLUDE;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\PlatformSDK\include

lib
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\ATLMFC\Lib;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\PlatformSDK\Lib;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\Lib

path
  C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\IDE;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\BIN;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\Tools;
  C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\Tools\bin
</pre>

<A NAME="SupportLibs">
<p><font size=+2>Installing Supporting Libraries</font>
</a>

<p>Syzygy makes use of 10 libraries not found on all systems:
GLUT (windowing for 3D graphics), libjpeg (for reading and writing jpeg files),
libz (for compression/ decompression), fmod (sound), BirdWindowsDriver 
(supports the Ascension Flock-of-Birds magnetic tracking system under Windows),
lib3DS (supports loading 3D Studio Max models under Linux), EVaRT 
(supports Motion Analysis optical trackers under Windows), CG supports 
real-time shaders on modern graphics cards, VTK supports various
scientific visualization algorithms, and vrpn supports connecting to a wide
variety of input devices.
You must install GLUT, but the others are 
optional. Installation of GLUT has already been covered under the 
<a href="#Requirements">Requirements</a> section at the start of this document. 
When just starting out with the system, you should ignore the optional libraries. 
You'll be able to experiment without them.
<p>The Syzygy makefiles (via szg/build/make/Makefile.libscan) will automatically
detect the presence of the libraries, given that they are copied to the places
outlined below. See Makefile.libscan for details.

<ul>
<li>For sound support, install
<a href="http://www.fmod.org/">fmod</a> version 3.7. You will need to download and
unzip (or untar) the file(s) appropriate for your platform(s).

<p>Then, before building Syzygy, copy these libraries as directed for your system:
<br> &nbsp&nbsp&nbsp libfmod-3.7.so into $(SZGEXTERNAL)/lib/fmod-3.7/linux (Linux) 
<br> &nbsp&nbsp&nbsp libfmod.a into $(SZGEXTERNAL)/lib/fmod-3.7/darwin (Mac OS X)
<br> &nbsp&nbsp&nbsp fmodvc.lib into $(SZGEXTERNAL)/lib/fmod-3.7/win32 (Win32)
<br>
And copy these include files into $(SZGEXTERNAL)/include/fmod-3.7:
<br> &nbsp&nbsp&nbsp fmoddyn.h
<br> &nbsp&nbsp&nbsp fmod.h
<br> &nbsp&nbsp&nbsp fmod_errors.h
<br> &nbsp&nbsp&nbsp wincompat.h

<p>If you don't copy these files over, Syzygy will still build and run,
but the executable file SoundRender will print a warning message and exit 
instead of playing any sounds.

<p>Before running programs which use fmod (currently, only SoundRender),
place the fmod shared library where it can be found:

<p><ul>
<li>Linux: as root copy libfmod-3.7.so into /lib.
<li>Windows: copy fmod.dll into into your system directory ($WINDIR\system).
<li>Mac OS X: a statically linked version is used so no further action is needed.
</ul>
<p>
<li>In order to import jpeg images (needed for the q33 demo to compile), you will
need jpeg support. This feature is also useful for importing jpeg files into the
Syzygy library in general. First, obtain libjpeg from the web and compile it for your
platform. On a Linux system, this will not be necessary. However, in the Linux
case, you will have to copy already installed files to new locations, as outlined
below.
<ul>
<li> On Linux, make a directory $(SZGEXTERNAL)/lib/jpeg/linux and copy libjpeg.a
there. Try 'locate libjpeg.a' to see if this is already present on your system.
Next, make a directory $(SZGEXTERNAL)/include/jpeg/linux and copy jconfig.h, 
jmorecfg.h, and jpeglib.h there. Once again, these files might already be on your
system and can be found using the 'locate' command.
<li> On Windows, make a directory $(SZGEXTERNAL)/lib/jpeg/win32 and copy libjpeg.lib,
as produced by your compilation of the libjpeg sources, to there. Next, make a
directory $(SZGEXTERNAL)/include/jpeg/win32 and copy jconfig.h, 
jmorecfg.h, and jpeglib.h there.
<li> On Mac OS X, make a directory $(SZGEXTERNAL)/lib/jpeg/darwin and copy libjpeg.a
there. Try 'locate libjpeg.a' to see if this is already present on your system.
Next, make a directory $(SZGEXTERNAL)/include/jpeg/darwin and copy jconfig.h, 
jmorecfg.h, and jpeglib.h there. Once again, these files might already be on your
system and can be found using the 'locate' command.
</ul>
<p>
<li>In order to support compression/decompression of files (needed for the q33 demo
to compile), you will need zlib support. This is not used anywhere else in the code.
First, obtain zlib from the web and compile it for your platform.On a Linux system, 
this will not be necessary. However, in the Linux case, you will have to copu already
installed files to new locations, as outlined below.
<ul>
<li>On Linux, make a directory $(SZGEXTERNAL)/lib/zlib/linux and copy libz.a there.
Try 'locate libz.a' to see if this is already present on your system. Next, make
a directory $(SZGEXTERNAL)/include/zlib/linux and copy zconf.h and zlib.h there.
Once again, these files might already be on your system and can be found using the
'locate' command.
<li>On Windows, make a directory $(SZGEXTERNAL)/lib/zlib/win32 and copy zlib.lib,
as produced by your compilation of the library sources, to there. Next, make
a directory $(SZGEXTERNAL)/include/zlib/win32 and copy zconf.h and zlib.h to there.
<li>On Mac OS X, make a directory $(SZGEXTERNAL)/lib/zlib/darwin and copy libz.a there.
Try 'locate libz.a' to see if this is already present on your system. Next, make
a directory $(SZGEXTERNAL)/include/zlib/sarwin and copy zconf.h and zlib.h there.
Once again, these files might already be on your system and can be found using the
'locate' command.
</ul>
<p>
<li>In order to import .3ds files (Autodesk 3D Studio format),
you will need to build and install lib3ds. Included in $SZGHOME/contrib/ is a folder named
"lib3ds", which is simply the latest release of lib3ds, downloaded from
<A HREF="http://www.sourceforge.net/projects/lib3ds/">
http://www.sourceforge.net/projects/lib3ds/</a>. Follow the instructions
provided in $SZGHOME/contrib/lib3ds/INSTALL to build the library. To install for
Syzygy compilation, follow the instructions for your platform:
<p><ul>
<li>Windows: Copy lib3ds.lib to $(SZGEXTERNAL)/lib/lib3ds/win32. Copy all
    header files to $(SZGEXTERNAL)/include/lib3ds/lib3ds. 
<li>Linux: Copy lib3ds.a to $(SZGEXTERNAL)/lib/lib3ds/linux. Copy header files
    as in the Windows case.
<li>Mac OS X: not supported yet, but this should be possible in the future.
</ul>
<p>
<li>Syzygy currently supports the Ascension Flock-of-Birds tracking system under
Windows. To enable this, you need to install the BirdWindowsDriver:

<ul>
<li>
Download BirdWindowsDriver.zip from 
	<a href="http://www.ascension-tech.com/support/downloads/">here</a>.
<li>
Copy Bird.dll to the appropriate location for your system
(e.g. in Win2k, to C:\WINNT\system32). NOTE: that this device is
currently supported only under Win32!
<li>
Copy Bird.lib to $(SZGEXTERNAL)/lib/ascension/win32.
<li>
Copy Bird.h to $(SZGEXTERNAL)/include/ascension.
</ul>
<p>If Bird.lib is not installed correctly, make will succeed without Flock-of-Birds
support.  If Bird.lib is present but Bird.h is missing, make will fail.  If both
of these are present but Bird.dll is not installed, make will succeed but the device
driver will not run.
<p>
<li>Enabling EVaRT support: You should have received files EvaRT.h,
macrtcom.lib, and macrtcom.dll with your optical motion capture
system. 
<p><ul>
<li>Copy EvaRT.h into $(SZGEXTERNAL)/include/evart.
<li>Copy macrtcom.lib into $(SZGEXTERNAL)/lib/evart/win32.
<li>The build
process will detect the presence of EVaRT.h and macrtcom.lib and
will build executables with EVaRT support.
<li>Place macrtcom.dll in the path
of every Windows machine on which you want to execute.Alternatively, if your 
executables are accessed from a central location, just place the dll in the
same directory as your executables.
</ul>
<p>
<li>Enabling vrpn support: You can use vrpn (Virtual Reality Peripheral
Network, from UNC) to feed input events to Syzygy. Note that we only
support vrpn on Linux so far.
<p><ul>
<li>Download and compile vrpn.
<li>(on linux) Copy libvrpn.a to $(SZGEXTERNAL)/lib/vrpn/linux.
<li>Make a directory $(SZGEXTERNAL)/include/vrpn and copy the vrpn header
files there. Note that only vrpn_Shared.h, vrpn_Tracker.h, vrpn_Analog.h,
and vrpn_Button.h are needed.
</ul>
<p>
<li>Enabling CG support: This is currently only supported under Linux and
does not (yet) do much. We have added an experimental bump map node to the
graphics database API.
<p><ul>
<li>Obtain the CG developer's kit from NVIDIA. Compile (Linux) and copy
libCgGL.so and libCg.so to $(SZGEXTERNAL)/lib/Cg/linux.
<li>In $(SZGEXTERNAL)/include/Cg, make a directory "Cg" and copy the header
files cg_bindlocations.h, cg_datatypes.h, cg_deprecated_api.h, cg_errors.h,
cgGL_deprecated_api.h, cgGL.h, cgGL_profiles.h, cg.h, and cg_profiles.h to
there. Note that the header files will be in $(SZGEXTERNAL)/include/Cg/Cg.
<li>(Linux) Make sure your LD_LIBRARY_PATH variable has $(SZGEXTERNAL)/lib
in the search path. This is necessary since libCgGL.so calls libCg.so.
<li>The files cg_bump_mapping_fragment.cg and cg_bump_mapping_vertex.cg
need to go in /home/public/Data (yes, this is experimental). To change the
location, see src/graphics/arBumpMapNode.cpp. The aforementioned files can
be found in src/graphics.
</ul>
<p>
<li>Enabling VTK support: We just use this, so far, in the 2nd tier demo
vtkfile. At this early stage, you'll have to decode that demo's Makefile
to figure out how to make it work!
<p>
<li>Enabling vrpn support: Linux only. Using this library it is possible to
import data into Syzygy from any device supported by vrpn.
<p><ul>
<li>Obtain the vrpn source from the UNC vrpn homepage. Compile.
<li>Copy libvrpn.a to $(SZGEXTERNAL)/lib.
<li>Make a directory $(SZGEXTERNAL)/include/vrpn and copy the vrpn header
files there.
</ul>
</ul>

<A NAME="CompileSyzygy">
<p><font size=+2>Compiling the Syzygy Toolkit</font> 
</a>

<p><ol>
<li>Unpack szg.tar.gz.
<li>In szg/build, type make. Note that 'make clean' does the expected thing.
    On Windows this must be done from a cygwin shell since syzygy uses GNU make.
<li>If you get compile or link errors, you may need to modify szg/build/make/Makefile.defines.
    A common cause of this is a nonstandard location of OpenGL headers and libraries.
    But this is relatively rare.
<li>If fmod is not installed, Syzygy will build
    but sound will be disabled. Similarly, support for the Flock of Birds, Motion Analysis
    motion trackers, or importing 3D Studio Max models will be disabled if the
    appropriate libraries and headers are not found at compile-time, as
    outlined above.
</ol>

<p>Common problems:

<p><ul>
<li>If SZGBIN is set but isn't a directory, the cp command at the
    end of each step in the recursive make will fail.
<li>On most systems, the build system will automatically guess the
    system type and proceed.
    But if a top-level build fails with
    "Makefile failed to guess OS type"
    then manually set the environment variable 
    OSTYPE to one of linux, cygwin, darwin, or irix.
<li>If cygwin was not installed properly, you might not have gotten "make"
    or "ar". In this case, the build will fail, complaining that it can't find
    the relevant executable. Please try installing cygwin again, this time
    with a customized install including these components.
</ul>

<p>You can also build individual directories, which can be very convenient during development.
To build the objects derived from src/language, for instance, run make in
the directory szg/build/$(MACHINE_TYPE)/language, where MACHINE_TYPE is
one of linux, win32, darwin, mips3, or mips4. For this to work, the environment
variables SZGHOME, SZGBIN, and SZGEXTERNAL must be set appropriately.

<A NAME="CompileDemos">
<p><font size=+2>Compiling the demos</font>
</a>

<p>Several demos are included with the Syzygy toolkit. The hope is that this
will make it easy to go from simply having a collection of networked 
computers to running cluster-based virtual reality applications in very little
time!
<p><ol>
<li>To build all the demos, in szg/build type "make demo".
   This also rebuilds the toolkit ("make") if needed.
   It continues on to the next demo if one fails to build.
   You can clean the demo directories with "make democlean". 
<li>Of special note in building the Quake III level viewer demo, q33: 
   On Unix (well, Linux at least), this
   will likely proceed without problems. On Windows, you will need to install
   some libraries and header files. In szg/contrib, you will find the
   jpeg and zlib directories. These contain source for libraries needed
   by the q33 demo. Check out the READMEs for which header files to copy
   over to the Microsoft VC++ include directory. Also copy
   the compiled libraries (instructions are in the READMEs) to 
   C:\Windows\System32. Note: the included code repositories build
   against multi-threaded libc. Libraries already existing on your Windows
   system might be built against single-threaded libc and, consequently,
   not be compatible with Syzygy. You'll also need to install the file
   glext.h with VC++'s other header files (but not in the GL subdirectory).
</ol>

<p>It is also possible to build the demos individually. For example, to build the "cosmos"
demo on a linux machine, go to

<pre>
  szg/build/linux/demo/cosmos
</pre>

and invoke make. As above, for this to work properly, SZGHOME, SZGBIN,
and SZGEXTERNAL must be set correctly.

<A NAME="InstallData">
<p><font size=+2>Installing the Optional Data Distribution</font>
</a>

<p>Many of the <a href="Demos.html">demos</a> require additonal data files to run.
Previous versions of Syzygy have included an optional data distribution as a gzip-ed
tar file. This file has grown too large to be useful. Instead, the data for the
demos is now distributed on the Syzygy DVD, which can be obtained by writing the
<A href="www.isl.uiuc.edu">Integrated Systems Lab</a> (just follow the links to Syzygy
from the lab's main page). To install the data, you will simply copy the 'data'
folder from the top level of the DVD to your desired location.

<p>Once the data is installed, set the following parameter in
the Syzygy database (discussed below) for each machine that will be accessing the data.
Of course, you will point to the actual location of the 'data' directory, instead of
'/szg/data'.

<pre>
 XXX SZG_DATA path /szg/data
</pre>

<p>This sets the "path" parameter of the SZG_DATA parameter group on the machine named 
XXX to /szg/data. Now, the programs will be able to find their data.

<p>To install
the q33 demo, for example, you'll need to install pak0.pk3 (available from the Quake3 CD or
ID software demo download) into the data path. Either copy it into
the data directory you've already created, or copy it to an /arbitrary/location
and append to the data path:

<pre>
  XXX SZG_DATA path /szg/data;/arbitrary/location
</pre>

<A NAME="InstallDemos">
<p><font size=+2>Installing the 2nd Tier Demos</font>
</a>

<p>Syzygy has a collection of demos that ship with the core distribution.
These are included not only to give downloaders something interesting to
do with their cluster right away but also to serve as a verfication base
as the library grows and changes. These demos will always be working as
the code base changes. However, the Syzygy project aims to distribute as
many demos as possible, even though it is not practical to include these
in the base distribution. Information about the demos found in the
2nd tier can be found <a href="Demos.html">here</a>.

<p><ul>
<li>Unpacking the additional demos: 
<a href="http://www.isl.uiuc.edu/syzygy/index.htm">Download</a>
or otherwise obtain the appropriate version szgdemo-X.X.tar.gz. Extract
to the directory szgdemo.
<li>Compiling additional libraries: One of the 2nd tier demos requires
the vmat library (a library for doing simple real-time physics). SZGHOME
needs to be set for this to work. 
<a href="http://www.isl.uiuc.edu/syzygy/index.htm">Download</a>
and unpack the source. Set VMATHOME to the top-level directory where
you unpacked the source. Go into vmat and type "make".
<li>Compiling the demos:
  <p><ul>
  <li>SZGHOME and SZGBIN must be set as outlined above. SZGEXTERNAL
  is optionally set (if you have some of the 3rd party supporting libraries).
  <li>In the top level of the szgdemo distribution, type "make". Your
  machine type is automatically detected and the various additional demos
  are built. The executables are placed in your SZGBIN directory.
  </ul>
</ul>

<A NAME="Firewalls">
<p><font size=+2>A Note on Firewalls</font>
</a>

<p>IMPORTANT: Many operating systems today will install a firewall. The default 
configuration of this software might very well keep Syzygy from functioning.
After all, as a networked system, Syzygy expects to be able to communicate on
particular ports. The easiest option is to simply not have a firewall at all. 
However, this will be unacceptable in some environments.

<p>We now outline the ports that must be allowed through the firewall. In the
next section, you'll learn that, for Syzygy to operate in a distributed fashion,
you will need to create a Phleet. This involves running an szgserver program.
The computer on which szgserver runs must allow connections on the port you
specify.

<p>The "dhunt" and "dlogin" commands rely on ports 4620 and 4621 to operate
properly. 

<p>Finally, every computer that is part of the Phleet will have a block of
ports upon which components it is running will listen for connections. This
block is set by the "dports" command. By default, it is 4700-4899. You will
want to let this block (however you choose to define it) through the firewall.

<A NAME="CreatingPhleet">
<p><font size=+2>Creating a Phleet</font>
</a>

<p>Please make sure you read the previous section on firewalls.

<p>Syzygy depends on a lightweight distributed operating system,
Phleet. This system helps programs share data with one another, stores
configuration information for users, and provides an interface for 
managing the cluster software components. A single instance of the Phleet
kernel, szgserver, runs for each distributed operating system instance. 
An individual computer is a member of only one Phleet instance at a time.
In what follows, you'll learn how to set up Syzygy in a simple, but common,
case: a broadcast packet from one computer can reach all others and no one
else on the LAN has a running Syzygy system.

<p>NOTE: szgserver is meant to run in the background for a long
time (like a linux daemon or windows service).  Don't run a new copy for
each application.  Two copies of szgserver can't run on the same host.

<p><ol>
<li>First, configure each computer to be used in your distributed system. 
    <p><ul>
    <li>Login to the computer to be configured.
    <li>You will use the command line to alter a config file. 
    <li>On Windows this file is C:\szg\szg.conf
        (or D:\szg\szg.conf if the C: drive does not exist). Note
        that this changes the location from previous Syzygy versions. The change was forced
        because only an administrator user can write a file into the top level of the
        C: drive on WinXP. 
    <li>On Unix the default location is /etc/szg.conf
        but only root can write this file. So an alternative, world-writeable
        location, /tmp/szg.conf, can also be used. If /etc/szg.conf exists, the
        system will ignore /tmp/szg.conf.
    <li>On Unix, in each of dname, daddinterface, ddelinterface, and dports, the -t option
        means to use /tmp/szg.conf.
    <li>Name the computer. This must be unique across all the computers in your
        system. A good choice is the short version of your computer's DNS name
        (i.e. XXX.YYY.YYY.edu becomes XXX) but other names are possible. If you can
        write to /etc, it is preferable to use:

<pre>
  dname the_name
</pre>

    <li>On Unix, if you cannot write to /etc, use:

<pre>
  dname -t the_name
</pre>

    <li>The -t option is not mentioned when daddinterface, ddelinterface, and dports
        are described below. YOU MUST USE IT CONSISTENTLY. In other words, use it with
        each of the listed commands or with none of them.
    <li>The syzygy config file contains information about the network interfaces
        in the computer. This information is used, for instance, in automatically
        connecting various components to one another. To add an interface to the 
        config file:

<pre>
  daddinterface network_name address
</pre>

    <li>The network_name gives a descriptive name for the network. Internet addresses
        should use "internet". Private networks can use an arbitrary name, but this
        should be consistent across the private network and different from that
        assigned to other private networks in the distributed system. For instance,
        the distributed system might contain 2 clusters, each connected internally
        by a distinct 192.168.0.XXX private network. In this case, the network_name
        associated with each should be different. This lets Phleet operate properly
        with respect to connection brokering.
    <li>The primary or default network for each computer should be added *first*.
        This network should be one to which all computers in the distributed system
        are connected. Components will expect to connect to the szgserver on this
        network. Furthermore, if components have a choice about how to connect to
        one another (i.e. they are connected by several networks), they will use
        the first network to connect.
    <li>One can remove networks from the config file.

<pre>
  ddelinterface network_name address
</pre>

    <li>Syzygy operates using connection brokering. You will not explicitly assign the
        ports on which servers will listen for connections. Instead, Phleet will
        assign the servers ports based on an available pool it maintains 
        (on a per-computer basis). By default,
        the block 4700-4799 is used, which is likely to be OK on both Unix and 
        Windows machines. However, you can change this using the following command:

<pre>
  dports first size
</pre>

    <li>This command allocates a block of ports beginning at "first" and containing
        "size" many ports. IMPORTANT: you'll want every port in this block to be
        free and for user services to be able to bind to them. Furthermore, the
        block should be of reasonable size, in order to accomodate all the services
        that might run on the computer. All in all, it is best to be generous when
        assigning the size, consequently the default value. NOTE: some Windows versions
        do not like user services to bind to ports 5000 and above.
    <li>After having issued these commands, you should check the stored config file.

<pre>
  dconfig
</pre>
  
    <li>The output might look something like this:

<pre>
  Phleet Configuration
  --------------------
  Computer name = MY_COMPUTER
  Network Name = internet, Address = XXX.XXX.XXX.XXX
  Network Name = wall, Address = 192.168.0.1
  Ports = 4700 - 4899
</pre>

    <li>The dconfig command will display the information in the config file Phleet
        components running on the computer will use. If this seems different from
        what you typed above, perhaps you used the -t option inconsistently.
    </ul>
<li>Choose a computer that will act as the server for the Phleet
    distributed OS. This is where the szgserver program will run. Do not
    run szgserver on more than one computer. The syntax for the szgserver
    command is as follows:

<pre>
  szgserver server_name server_port
</pre>

    You need to give the szgserver program a name, server_name, which
    can be anything. You also give it a server_port at which it listens
    for connections and the IP address of the server machine. Don't
    choose a port within the ports block that will be used for
    connection brokering on the computer running szgserver.

<pre>
  szgserver generic 4343
</pre>

<p>Windows XP NOTE:  if running Windows' built-in firewall (a good idea),
poke a hole in the firewall for ports 4620/UDP and 4343/TCP (where "4343"
is the port specified on the command that invoked szgserver).

<li>To interact with the system, you'll need to login. This is 
    done on a per-machine basis.
    To run Syzygy commands from the commmand line on a particular
    machine, first login on that machine by typing (and making sure
    that the szgserver_name is the same as used above):

<pre>
  dlogin szgserver_name syzygy_user_name
</pre>

   Conceptually, this command logs you in to the szgserver given by szgserver_name
   using user name syzygy_user_name. Syzygy login occurs on a computer by associating
   a user name (in the context of the computer's OS) with a syzygy user name.
   Subsequently (until dlogout), any syzygy command issued on that computer by the
   given user (as understood by the OS)
   will be controlled by the given szgserver and executed as the given
   syzygy user.
<li>Make sure that you have issued the dlogin command, as above, on each computer
    that'll be part of your distributed system. Upon success, a login file will
    be written. If the OS thinks the user's name is XXX, then, on Unix, the
    login file will be /tmp/szg_XXX.conf while on Windows the login file
    will be C:\szg\szg_XXX.conf (or D:\szg\szg_XXX.conf if the C: drive does not exist).
    Also, upon successful login, the information in the login file will be printed,
    looking something like:
    
<pre>
  Phleet Login
  ------------
  System user name = schaeffr
  Phleet user name = ben
  szgserver name = cube
  szgserver IP = XXX.XXX.XXX.XXX
  szgserver port = 8888
</pre>

<li>It is necessary to explain the login mechanics so that potential problems can
    be idenitified and solved. The dlogin command, when connecting to the szgserver
    via name, works by first reading the phleet 
    config file on the machine on which it runs. It then sends broadcast packets
    on each of the networks listed there (i.e. if 192.168.0.1 is an address, a packet
    is sent to 192.168.0.255). The szgserver is continually listening for such packets,
    and, if it receives one destined for an szgserver with its own name, returns 
    information to dlogin about how to connect.
<li>This can fail in several ways. The failure possibilities and remedies are:
    <p><ul>
    <li>Broadcast packets are filtered by the network between dlogin and the szgserver.
        For instance, note that the loopback interface (127.0.0.1) filters broadcast
        packets. You can solve this by connecting explicitly to the szgserver (see below).
    <li>The networks in the phleet config file on the machine on which dlogin was issued
        are incorrect. Check them again using dconfig.
    <li>The szgserver name given in dlogin and the name of the running szgserver are 
         different. Make sure they are the same.
    <li>The szgserver tells dlogin to connect using the first address in the phleet config
        file located on the MACHINE RUNNING SZGSERVER. The machine running dlogin must
        be able to reach this IP address. If not, reorder the addresses in the phleet
        config file on the szgserver machine using ddelinterface and daddinterface
        ON THAT MACHINE.
    </ul>
<li>If broadcast packets will not travel from dlogin to szgserver, you can issue an explicit
    version of dlogin.
    
<pre>
  dlogin szgserver_IP_address szgserver_port syzygy_user_name
</pre>

<li>Now, on each machine in the distributed system, run szgd, the phleet remote execution
    daemon.
    
<pre>
  szgd
</pre>

    When you run szgd on a machine, make sure that you are logged-in (OS-wise) 
    to that machine as you were when you issued the dlogin command.
<li>Now, on any machine in the distributed system, type "dps". You'll see something like:

<pre>
  computer1/szgd/0
  computer2/szgd/1
  computer3/szgd/2
  computer4/szgd/3
  computer5/szgd/4
  computer6/szgd/5
</pre>

    There should be a line for each computer on which you have run szgd.
<li>PLEASE NOTE: the szgd's are not strictly necessary for the simple distributed
    graphics tests described in the next section (in which there is no remote
    execution of components), but they will be used in subsequent sections.
<li>Syzygy is a multi-user system. While you have to login to an szgserver to
    run szgd, other users will be able to use your remote execution daemon
    to launch THEIR executables.
    the szgserver
   where syzygy_user_name identifies you to the system.  (You only need to dlogin
   on one machine, if you'll only be running commands on that one machine.)
<li>Run dps on a machine that is part of the system and where you are
    logged-on as in the previous step. This should list
    an entry for szgd on each machine.
</ol>

<A NAME="SimpleTest">
<p><font size=+2>A Simple Distributed Graphics Test</font>

<p>One can now run some simple distributed graphics tests without any further configuration.
A distributed scene graph application, in its simplest form, consists of 3 seperate executable
components: the application itself, a renderer, and an input program. These can can be run in
arbitrary locations in the distributed system prepared above. Concretely, on any computer in
the distributed system, type (you'll have to have compiled the base demos):

<pre>
  cosmos
</pre>

The "cosmos" executable will not return, though no window will appear, if all goes well 
(to exit you can ctrl-c). If this is not the case, the only possibility is that the servers
embedded in cosmos could not bind to their ports, as determined by the szgserver. Try changing
the ports block on this computer using dports, as above.

<p>Next, on any computer in the system, type:

<pre>
  szgrender
</pre>

On the computer on which you typed "szgrender", a window will pop up and display 4 solid blue
rotating torii, from which emerge a shimmering halo of lines. If this doesn't happen, either
the phleet config file on this computer has incorrect network information (check using dconfig)
or the computer running cosmos is not reachable via the first network listed in the phleet
config file on this computer. 
In the later case, reorder the addresses in the config file using ddelinterface
and daddinterface (it is assumed that it is possible to reach cosmos over the network from
this computer). Quit szgrender and run it again. Everything should now work.
NOTE: to quit szgrender, type ESC.

<p>Next, on any computer in the system, type:

<pre>
  wandsimserver
</pre>

On that computer, a window will appear with some geometrical objects. Move the mouse in that
window with the left button down. The wireframe sphere should move and, furthermore, the torii
in the szgrender window should move as well. The wandsimserver program has a server (for
input device information) embedded in it like the cosmos program has a server embedded in it
(for geometry). Consequently, the potential faults are similar. If it fails to launch,
make attempt adjusting the ports block via dports on the computer on which it executed. If it
launches, but the torii in the szgrender window do not move when the wireframe sphere moves,
this is because the input device client embedded in cosmos could not connect. Make sure the
phleet config file on the computer running cosmos has correct information and that the computer
running wandsimserver is reachable via the first
address listed in the phleet config file on the computer running cosmos. If the later is false,
use daddinterface and ddelinterface to manipulate the config file on the computer running cosmos.
Then, upon killing and then restarting cosmos, everything should work. NOTE: to quit wandsimserver,
type ESC.

<p>One can have fun exploring different possible configurations. 
On any computer in the distributed
system, run another copy of szgrender. Kill a currently running copy of szgrender. 
Repeat in
an arbitrary fashion. Note that only one copy of wandsimserver or cosmos 
will run at a given time.
Each offers a service (like SZG_INPUT0 in the case of wandsimserver), and 
the szgserver enforces
that only a single component can offer a particular service. Try running 
mulitple copies of each and
observe the failure. On the other hand, try killing wandsimserver and 
restarting it on another
computer in the distributed system. This will work, assuming that the 
computers in question
are configured correctly, as discussed above. Similarly, cosmos can be 
killed and restarted
on another computer. In each case, the components automatically reconnect 
and recreate a working total application.

<p>One can also run a simple master/slave application test without 
any further configuration. Go ahead 
and kill any instances of cosmos, szgrender, and wandsimserver that 
you still have running from previous experiments. Next, on any computer 
in the distributed system, type:

<pre>
  hspace
</pre>

A window should appear with a green spiderweb on a black background. 
If the window fails to launch, the
only possibility is that the ports were misconfigured on the machine on 
which it executed. The
remedy is the same as above. The first successfully launched instance of 
hspace is the "master".
Subsequently launched instances will be "slaves", depending upon the 
master for information about navigation
and the state of the world. Go ahead and launch hspace on other computers 
in the distributed system. 
You can quit the program by typing ESC.

<p>Next, type:

<pre>
  wandsimserver
</pre>

on one of the computers in the distributed system. Move the mouse in the 
resulting window with a button
held down. The green spiderwebs should move in unison. If they do not move, 
the configuration of the
computer on which the FIRST instance of hspace (the master) ran must be incorrect. 
Make sure that on that
computer the network addresses are correct in the phleet config file. Furthermore,
 make sure that that
computer can communicate with the computer running wandsimserver over one of those 
addresses.

<p>As before, experiment with freely killing and restarting hspace and wandsimserver 
on the various computers
in the distributed system. Note that when you kill the master instance of hspace, 
no motion of the
wandsimserver will cause the slaves to move. This is because there now exists now 
master instance. However,
the next hspace instance you launch will become the new master and everything 
will again work.

<A NAME="ManagingPhleet">
<p><font size=+2>Managing the Phleet</font>
</a>

<p>Phleet includes commands to manage processes running on the cluster.

<dl>
<dt>
dps
<dd>
  List all programs registered with Phleet.  Each line in the listing has the form
  <br>
  XXX/YYY/###
  <br>
  where
<br>
  XXX = computer name
  YYY = program name
  ### = Phleet ID
  
<dt>
dex XXX YYY
<dd>
  Run program named YYY on machine named XXX (where XXX is e.g. output by dps).
  User identity is propogated through the system. If Phleet thinks syzygy user
  ZZZ issued the dex command, then YYY will run as if issued by user ZZZ. Note
  that szgd must be running on machine XXX for this to succeed.

<dt>
dkill XXX YYY
<dd>
  Kill program YYY running on machine XXX.
  <br>
  If machine XXX crashes, the szgserver may think that 
  program YYY is still running. This is because XXX has not correctly closed the
  TCP connection.
  To close the connection for sure, type
  <br>
  dkill -9 XXX YYY

<dt>
dmsg component_ID TTT [YYY]
<dd>
  Send a message with tag TTT and body YYY to program with Phleet ID 
  given by component_ID. If YYY is not present, an empty body is sent.
  <br>
  Examples:
  <br>

  dmsg 17 quit
  <br>

    - Same as dkill'ing the program with ID 17.
  <p>
  dmsg 17 reload
  <br>
    - Tell the program with ID 17 to reload its parameters from the database.
<dt>
dmsg -p computer_name component_name TTT [YYY]
<dd>
  Find the component, if such exists, with name component_name that is
  running on computer computer_name. Send it a message with tag TTT and
  body YYY. If YYY is not present, an empty body is sent.
<dt>
dmsg -m virtual_computer TTT [YYY]
<dd>
  Find the component, if such exists, running on the master screen of
  the given virtual computer. Send it a message with tag TTT and body
  YYY. If YYY is not present, an empty body is sent.
<dt>
dmsg -s virtual_computer screen_number TTT [YYY]
<dd>
  Find the component, if such exists, running on the screen indexed
  by screen_number pertaining to the listed virtual computer. Send it
  a message with tag TTT and body YYY. If YYY is not presnt, an empty 
  body is sent.
<dt>
dmsg -c virtual_computer TTT [YYY]
<dd>
  Find the component, if such exists, which is currently running
  as the trigger instance of the given virtual computer. Send it
  a message with tag TTT and body YYY. If YYY is not present, an
  empty body is sent.
</dl>

<p>Phleet also has a parameter database that provides functionality like
that of environment variables. A separate database is maintained for each
Phleet user. Values are stored as:

<pre>
  computer_name/parameter_group/parameter_name = value
</pre>

<p>Phleet-enabled programs query the database to configure themselves.

<pre>
dget XXX YYY ZZZ
    Gets the database value for computer name XXX, parameter group YYY, and parameter name ZZZ.

dset XXX YYY ZZZ AAA
    Sets the database value for computer name XXX, parameter group YYY, and parameter name ZZZ 
    to AAA.

dbatch XXX
  Inserts parameter values from the file XXX into the Phleet parameter
  database. Note that if (current_computer)/SZG_SCRIPT/path is 
  defined in the parameter database, this will define a search path
  for the file XXX. Files accepted by dbatch consist of a list of
  lines of the form:

  XXX YYY ZZZ AAA

  where XXX is a computer, YYY is a group, ZZZ is a parameter, and AAA is 
  the value.
</pre>

<A NAME="DBExamples">
<p><font size=+2>Database Parameters Example for Confidence Tests</font>
</a>

<p>While, as above, some of Syzygy's flavor can be experienced without specific
configuration, more interesting effects require it. For instance, reading data
files and constructing tiled displays require configuration. Here are some example 
parameters, in a format readable by the
dbatch command. We made the following assumptions in creating this list:
<p><ol>
<li>Syzygy contains two frameworks for constructing user applications. In a
<em>distributed scene graph</em> application, the main application runs on a
single cluster node, while
rendering programs (in this case szgrender) create the graphics on the display
nodes. In the case of a <em>master/slave</em> application, on the other hand,
seperate copies
of the application run on each render node, with one application, the master,
controlling the execution of the others. This first example will demonstrate
how to set the parameters for a distributed scene graph application ("cosmos").
<li>In the parameters below, we've assumed that /szg is the location where
you unpacked the code. This'll be easy to change to the actual location.
 Also, the value of the SZG_EXEC/path parameter assumes you are
using Linux machines. Pathnames in Windows will use backslashes 
instead of forward slashes and appropriate drive letters.
<li>The parameters used to configure the view are appropriate for a
2x1 tiled wall placed in front of the observer's position in tracked
coordinates.
<li>The machine running the main program is named "control", while two machines
running szgrender are named "slave1" and "slave2". These will need to be replaced
with the names of your computers.
</ol>
<pre>
# note how dbatch scripts can have comment lines
slave1 SZG_SCREEN0 size 640/480
slave1 SZG_SCREEN0 stereo false
slave1 SZG_SCREEN0 screen_center 0/5/-5
slave1 SZG_SCREEN0 screen_dim 10/10
slave1 SZG_SCREEN0 screen_normal 0/0/-1
slave1 SZG_SCREEN0 screen_up 0/1/0
slave1 SZG_SCREEN0 tile 0/2/0/1
slave1 SZG_RENDER texture_path /szg/rsc
slave1 SZG_RENDER text_path /szg/rsc/Text
slave1 SZG_SOUND path /szg/rsc
slave1 SZG_EXEC path /szg/bin/linux
slave1 SZG_DATA path /szg/data

slave2 SZG_SCREEN0 size 640/480
slave2 SZG_SCREEN0 stereo false
slave2 SZG_SCREEN0 screen_center 0/5/-5
slave2 SZG_SCREEN0 screen_dim 10/10
slave2 SZG_SCREEN0 screen_normal 0/0/-1
slave2 SZG_SCREEN0 screen_up 0/1/0
slave2 SZG_SCREEN0 tile 1/2/0/1
slave2 SZG_RENDER texture_path /szg/rsc
slave2 SZG_RENDER text_path /szg/rsc/Text
slave2 SZG_SOUND path /szg/rsc
slave2 SZG_EXEC path /szg/bin/linux
slave2 SZG_DATA path /szg/data

control SZG_SCREEN0 size 640/480
control SZG_SCREEN0 stereo false
control SZG_SCREEN0 screen_center 0/5/-5
control SZG_SCREEN0 screen_dim 10/10
control SZG_SCREEN0 screen_normal 0/0/-1
control SZG_SCREEN0 screen_up 0/1/0
control SZG_SCREEN0 tile 0/1/0/1
control SZG_RENDER texture_path /szg/rsc
control SZG_RENDER text_path /szg/rsc/Text
control SZG_SOUND path /szg/rsc
control SZG_EXEC path /szg/bin/linux 
control SZG_DATA path /szg/data
</pre>

<p>Descriptions of parameters:

<p><ul>
<li>SZG_SCREEN0/screen_center should give the center of the screen in question.
Note that units are given in feet. Each computer can have several virtual screens
attached to it, SZG_SCREEN0, SZG_SCREEN1, etc. Virtual screen 0 is the default used.
<li>SZG_SCREEN0/screen_dim gives the dimensions of the screen, horizontal
dimension followed by vertical dimension.
<li>SZG_SCREEN0/screen_normal gives a unit normal vector to the screen pointing
away from the observer.
<li>SZG_SCREEN0/screen_up gives the up direction (another unit vector).
<li>SZG_SCREEN0/tile allows you to amalgamate a set of screens into a tiled
video wall. The format is x/nx/y/ny, where nx and ny specify the number
of tiles in the horizontal and vertical directions, respectively, and x and y
are numbers between 0 to n-1 identifying the specific tile position of the current
machine's screen within this
grid. Tile coordinates are calculated from the lower left
corner of the screen. For instance, 0/2/0/2 denotes the lower left corner
of a 2x2 video wall. If tiling is used, SZG_SCREEN0/screen_dim, screen_center, 
screen_normal, and screen_up apply to the entire array, instead of
an individual tile.
</ul>

<p><ul>
<li>SZG_RENDER/texture_path and SZG_RENDER/text_path specify base paths to use
in locating texture and font data.  For example,
textures for the cosmos demo are located in szg/rsc/Texture (the donut textures)
and szg/rsc/Texture/Text (the textured font). Note that these paths are defined
on a per-computer (SZG_RENDER) instead of a per-screen (SZG_SCREEN(n)) basis.

</ul>

<p><ul>
<li>SZG_EXEC/path is the path to search for executables to be run by the <em>dex</em>
command.  If "control" runs Windows instead of Linux, you might
see something more like this...

<pre>
control SZG_EXEC path c:\szg\bin\win32
</pre>
</ul>

<p><ul>
<li>SZG_DATA/path is the path that some executables search for data files.
    This should be wherever you installed the optional data distribution
    mentioned above.
</ul>

<p>You'll have to alter the following for your setup:
<p><ul>
<li>SZG_RENDER/texture_path should be XXX/szg/rsc (where XXX is the directory
    in which szg was installed).
<li>SZG_RENDER/text_path should be set to XXX/szg/rsc/Text 
(where XXX is the directory in which szg was installed).
<li>SZG_EXEC/path should be set to the location of the installed binaries. Look at the
discussion of SZGBIN in the compilation section for more information.
</ul>

<p>The set-up outlined above assumes that the display computers will
have monitors side by side. In this example, "slave1" is displaying the
left half and "slave2" is displaying the right half. You can easily reverse this
by swapping the SZG_SCREEN0/tile parameter values. Or you can set up a completely
different type of display
by changing the screen_center, screen_dim, screen_normal, screen_up, and
tile values.

<A NAME="ConfidenceTest">
<p><font size=+2>Running the Distributed Graphics Confidence Test</font>
</a>

<p>These are the basic steps:
<p><ol>
<li>Configure your system as described <a href="#CreatingPhleet">here</a>.
<li>Set the database parameters, either one at at time using <em>dset</em> or
altogether using <em>dbatch</em>.
<li>Run the main application and the rendering programs as follows (we assume
    that <em>szgd</em> is running on each of slave1, slave2, and control):
<pre>
   dex slave1 szgrender 
   dex slave2 szgrender 
   dex control cosmos
</pre>
<li>These commands can be run from any computer in the system.
</ol>
   
<p>What <em>should</em> happen is that each execution of szgrender should cause a black-filled
window to open on the appropriate machine.  When cosmos runs, each window should show a partial
view of a set of rotating, concentric, highly colorful tori, along with some other stuff.

<p>If you get an error "szgd found no file foo in the SZG_EXEC path",
   then you didn't set up the database properly in step 3.
   The executables in question need to be in SZG_EXEC/path.

<p>The various demo programs, including cosmos, want to connect to
   a networked input device. See the <a href="InputDevices.html">
   Input Devices</a> documentation page for an enumeration of the supported
   devices. For simplicity's sake, here we assume you'll control the demo
   using a program called <em>wandsimserver</em> (see below) that translates
   mouse movements and keyboard presses into tracker-style events.

<pre>
  dex control wandsimserver
</pre>

<p>Type "dps" on a member of the Phleet and note the output. 
You can see everything running now. To kill the test, type:

<pre>
   dkill control cosmos
</pre>

<p>The szgrender windows will go black again. You can execute cosmos on control again,
   and the tori will return. Note that you can also
   run any of these executables from the command line on the individual machines 
   instead of via "dex". To kill the other stuff,
   
<pre>
   dkill slave1 szgrender
   dkill slave2 szgrender
   dkill control wandsimserver
</pre> 

<p>You can also hear sound from many of the demos, assuming you've compiled
with fmod support and have a sound card in control. Try:

<pre>
  dex control SoundRender
</pre>

<p>NOTE: the same parameters mentioned above will allow you to run everything
on a single box. Typing:

<pre>
  dex control szgrender
  dex control cosmos
  dex control wandsimserver
</pre>

<p>will bring everything up. Appropriate dkill's will bring everything down.

<A NAME="MasterSlave">
<p><font size=+2>Running a Master/Slave Application</font>
</a>

<p>So far, you've seen how to run a distributed scene graph application. Let's
now examine how to run a master/slave application (using dex, dkill, and configured screens). 
As mentioned above, in a master/slave application , seperate copies
of the application run on each render node, with one application, the master,
controlling the execution of the others.

<p>We'll use the same three-machine configuration for this example, the difference
being that one of the rendering machines, "slave1" will be running the master application
(OK, that's a little unfortunate, but you can handle it),
the other, "slave2", will be running the slave application, and "control" will be
responsible for input and sound as before.

<p>We can now run a master/slave application, like hspace (one
of the included demos) as follows:

<pre>
   dex slave1 hspace
   dex slave2 hspace
</pre>

<p>To stop the application:

<pre>
   dkill slave1 hspace
   dkill slave2 hspace
</pre>

<p>To hear sound (assuming you've compiled w/ fmod support and have
a sound card in control):

<pre>
   dex control SoundRender
</pre>

<p>You can also run a master/slave application on a single box, just launch all
components on, for instance, control.

<A NAME="VirtualComputer">
<p><font size=+2>Using Virtual Computers (Best Way to Launch an Application)</font>

<p>The above examples focus on launching the application components by hand and 
suitable for quick experimentation with the system or debugging. However, in a
production setting, using a set collection of hardware, it is better to define a
"virtual computer" and let Syzygy do the work of launching and killing the application.
The following is a virtual computer definition for a 6 graphics pipe display, that
includes sound, and is controlled via a simulated tracker interface (the wandsimserver
descrived below).

<pre>
  wall SZG_CONF virtual true
  wall SZG_TRIGGER map smoke
  wall SZG_MASTER map SZG_SCREEN0
  wall SZG_SCREEN number_screens 6
  wall SZG_SCREEN0 map wall1/SZG_SCREEN0
  wall SZG_SCREEN0 networks wall
  wall SZG_SCREEN1 map wall2/SZG_SCREEN0
  wall SZG_SCREEN1 networks wall
  wall SZG_SCREEN2 map wall3/SZG_SCREEN0
  wall SZG_SCREEN2 networks wall
  wall SZG_SCREEN3 map wall4/SZG_SCREEN0
  wall SZG_SCREEN3 networks wall
  wall SZG_SCREEN4 map wall5/SZG_SCREEN0
  wall SZG_SCREEN4 networks wall
  wall SZG_SCREEN5 map wall6/SZG_SCREEN0
  wall SZG_SCREEN5 networks wall
  wall SZG_INPUT0 map smoke/wandsimserver
  wall SZG_INPUT0 networks internet
  wall SZG_SOUND map sound
  wall SZG_SOUND networks internet
</pre>

<p>The computers in the cluster are smoke, wall1, wall2, wall3, wall4, wall5,
wall6, and sound. The name of the virtual computer is wall. By setting
SZG_CONF/virtual to true, the system understands that wall has been designated
as a virtual computer. If this value does not appear in the database, Syzygy
will not allow wall to be used as a virtual computer. The virtual computer name 
must not occur as the name of a physical computer in the distributed system.

<p>The virtual computer has one special node that must be determined by the
user. These is the trigger node, which is set via the
database values of SZG_TRIGGER/map. When executing
an application on the virtual computer, the executable first runs on the trigger
node. This "trigger instance" then scans the virtual computer and determines which
running services are incompatible with the new application. These are terminated.
For instance, any application already running on the virtual computer
is forced to exit. Next, the trigger
instance begins launching needed application components. When this is done, the
trigger instance behaves differently if it belongs to a distributed scene graph
application or if it belongs to a master/slave application. In the former case,
it actually begins to run the application. In the later case, it only launches the
other application components. In either case, the 
trigger instance waits for a kill message and, when it receives such, 
shuts down its launched components.  

<p>While the trigger node has meaning for both master/slave and
distributed scene graph applications, the "master" (as determined by 
SZG_MASTER/map) does not. This designates the screen that will run the master
instance of the application for a master/slave program. In the example above,
the master instance will run on wall1 and will be the instance associated with
SZG_SCREEN0 (on wall1). Note that there may be more than one screen associated
to a given cluster node.

<p>The virtual computer needs several rendering screens to be defined. First,
the value of SZG_SCREEN/number_screens tells how many graphics pipes are part
of the virtual computer. For each screen, two values need to be set. One determines
the location where the component that produces its graphics will run. The second
determines the networks the graphics component will use to communicate. The above
example shows a virtual computer with two distinct networks, the public internet
and an internal private network designated "wall". To increase the efficiency of
the graphics data transfer, we force the graphics communication to occur via the
private network only and have the other communication (sound and input) occur
via the internet. 

<p>The user also needs to map an input device to run applications on the 
virtual computer. The value of SZG_INPUT0/map is of the format:

<pre>
  AAA(0)/BBB(0)/AAA(1)/BBB(1)/.../AAA(n)/BBB(n)
</pre>

The "AAA" entries are all computer names which designate the locations upon which
the corresponding "BBB" components will be launched. A sequence of components
can be launched because some "virtual" input devices can require the cooperation
of several components running on multiple machines for their operation. The
first component in this list is the one that will communication directly with the
application. The other components will funnel their data to this one.

<p>The value of SZG_INPUT0/networks determines the communications path the
input devices will use.

<p>SZG_SOUND/map gives the the computer upon which SoundRender will run.
SZG_SOUND/networks gives the communications path it will use.

<p>To launch an application on a virtual computer, you will need a copy of
szgd running on every "mapped" node (i.e. any node whose name appears as
the value of a "map" database value). Once this is done, to launch hspace on
virtual computer wall, use the command:

<pre>
  dex wall hspace
</pre>

<p>There are two ways to kill an application running on the virtual computer. You
can directly kill the trigger instance. In our case, that would entail the following:

<pre>
  dkill smoke hspace
</pre>

<p>Or you can:

<pre>
  killalldemo wall
</pre>

<A NAME="Advanced">
<p><font size=+2>Advanced Configuration and Demo Information</font>
</a>

<p>See the <a href="ConfigurationExamples.html">configuration
examples</a> chapter for complete examples of how to configure a 6-walled
CAVE and how to configure a 3x2 video wall. This section also includes
more information about how to manage virtual computers, as described
<A HREF="#VirtualComputer">above</a>. Also, for information about the
included demos, including how to navigate them, see the
<a href="Demos.html">demos</a> chapter.

<A NAME="TrackingSim">
<p><font size=+2>Using the Tracking Simulator Interface</font>
</a>

<p>Since we are a VR installation, syzygy works best with a VR-style
interface, namely 6DOF head tracking and some kind of joystick type input
device with another 6DOF sensor attached. Since this could very easily be
unavailable, the software includes support for a simulator (wandsimserver)
that can operate the included programs from a desktop.

<p>This program can be run either from the command line or via

<pre>
    dex XXX wandsimserver
</pre>

<p>While executing, wandsimserver opens a window showing a view from behind into
a 10-foot cubical space (remarkably reminiscent of the inside our CUBE). A wireframe
sphere in the center represents the subject's head (initially facing away from us).
The other visible object represents a wand with three buttons. wandsimserver sends
data to the application specifying the position and orientation of
the head and of the wand and the state of the wand's buttons.

<p>When using the simulator, there are several modes, selected by the keys
1-7. 
<p><ol>
<li>Move the head. Mousing with the left button down moves head in the screen plane.
   Mouse with the middle button down moves head into/ out of the screen.
<li>Rotate head. Mousing with the left button down rotates head around the y axis.
   Mouse with the middle button down rotates the head around the x axis.
<li>Translate wand: Mousing with the left button down translates the wand in the
   screen plane. Mouse with the middle button down translates the wand into
   and out of the screen. 
<li>Translate wand & use buttons: Mouse movement translates the wand in the
   x-y plane. Pressing mouse buttons activates the device buttons.
<li>Rotate the wand & use buttons: Mouse movement causes the wand to rotate.
   Pressing buttons activates the mouse buttons. 
<li>Use the joystick: While a mouse button is pressed,
   mousing moves the joystick.
<li>Rotate the world: When a mouse button is pressed, the view rotates around
   the y axis.
<li>The wandsimserver program emulates the use of a wand with 6 buttons.
    By pressing the space bar, you can change the mapping of the mouse buttons
    from wand buttons 1-3 to wand button 4-6 and back again.
</ol>

</body>
</html>
