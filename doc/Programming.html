<html>
<head>
  <title>Introduction to Syzygy Programming</title>
</head>
<body style="background-color: rgb(255, 255, 255);">
<a href="index.html">Documentation Index</a> <font size="+2"></font>
<p><font size="+2">Introduction to Syzygy Programming</font>

<p>This chapter describes the broad programming styles supported by Syzygy:
the master/slave framework and the distributed scene graph framework. 
The master/slave style gives the programmer greater flexiblity, like the
ability to use OpenGL directly in code, but requires care to produce an
application that displays consistently on all cluster render nodes. On the
other hand, distributed scene graph applications are guaranteed to display
consistently across cluster nodes, but require the programmer to utilize the
Syzygy scene graph <a href="SceneGraph.html">API</a>.

<p>We also show how to leverage the existing Syzygy build structure to
create portable build structures for your own projects, using a provided
project template.

<p><ul>
<li><a href="#CommonFeatures">Common Features of Both Framworks</a>
<li><a href="#MasterSlave">Master/Slave Framework</a>
<li><a href="#SceneGraph">Distributed Scene Graph Framework</a>
</ul>

<p>Syzygy VR programming is accomplished by using a framework object
that manages the many components of the networked VR application. The
framework object is responsble for application launching and shutdown.
It also handles communications, synchronization, graphics, sound, and
input device. Most importantly, these objects isolate the programmer from
lower levels of the Syzygy library, making it more practical to evolve
those APIs while leaving the high-level programmer API constant.

<p>Syzygy presents two paradigms for programming VR applications. The
first is encapsulated in the arMasterSlaveFramework object. This
framework is suited to coding cluster graphics applications where
multiple copies of the application will run, one on each render node. We
refer to such applications as master/slave, since one instance of the
application, the master, controls the operation of the others, the
slaves. The second paradigm is contained in the
arDistSceneGraphFramework. Here, a single copy of the application runs,
producing graphics by manipulating a scene graph database. This database
is automatically synchronized with databases present on the cluster's
render nodes, where a special application, szgrender, handles the
drawing. Both of these frameworks are subclasses of arSZGAppFramework,
which contains the common aspects of the two frameworks.

<p>The distributed scene graph framework provides provably synchronized
graphics on the render nodes, regardless of the nature of the
application. This comes at a price, however. The application developer
can only express herself by means of the scene graph API, which contains
primitives for constructing some simple geometric objects. Applications
that only require objects supported by the scene graph API may be easier
to construct using this framework. On the other hand, applications built
upon the master/slave framework can make use of the standard OpenGL API.
The master/slave framework thus offers an easy migration path for
existing applications to cluster-based operation; two of the included <a
 href="ExampleCode.html">sample applications</a>, 
<em>atlantis</em> and <em>coaster</em>,
were easily ported to Syzygy from the standard GLUT distribution using
the master/slave framework. But this flexibility means it is possible to
write unsynchronized applications.

<p>Samples of both programming styles can be found under szg/src/demo.
Please see the <a href="ExampleCode.html">examples</a> chapter of this
documentation for more information.<br>

<a name="CommonFeatures">
<p><font size="+2">Common Features of Both Frameworks</font>
</a>

<p>Both frameworks have routines for setting the user's interocular
separation, near and far clipping planes, and the unit conversion
factors for both rendering and sound production:<br>
</p>
<pre>void arSZGAppFramework::setEyeSpacing( float feet );<br><br>void arSZGAppFramework::setClipPlanes( float near, float far );<br><br>virtual arSZGAppFramework::void setUnitConversion( float feet_to_program_units );<br><br>virtual arSZGAppFramework::void setUnitSoundConversion( float feet_to_program_units );<br><br></pre>
<p>Note that, if used, the unit conversion factors should be set <span
 style="font-style: italic;">before</span> the framework's init() method
is called (because database parameters are read in the init(), and some
of them may require the unit conversion factors), whereas the eye
spacing and clipping planes should be set <span
 style="font-style: italic;">after</span> init() (because otherwise they
may be overridden). 

<p>Both frameworks have a routine for accessing the Syzygy data
path, stored on each machine in SZG_DATA/path:

<pre>
  const string arSZGAppFramework::getDataPath()
</pre>

<p>Input. The frameworks provide methods for polling the current state
of the various <a href="InputDevices.html">input events</a>:</p>
<pre>int arSZGAppFramework::getButton( unsigned int index );<br>  Returns the value (0 or 1) of the named button. Button numbering starts<br>  at 0.<br><br>float arSZGAppFramework::getAxis( unsigned int index );<br>  Returns the value of the named axis. Axis numbering starts at 0.<br><br>arMatrix4 arSZGAppFramework::getMatrix( unsigned int index );<br>  Returns the value of the named matrix. Matrix numbering starts at 0.<br>  Note that in our applications the "head matrix" is currently hard-coded as matrix 0<br>  and the "wand matrix" is currently hard-coded as matrix 1. Information<br>  about the arMatrix4 object can be found by examining szg/src/math/arMath.h.<br></pre>
<p>Many of the included Syzygy sample applications expect a standard CAVE-style input
device: 3 buttons, 2 axes, 2 matrices (which <a
 href="InputDevices-Drivers.html">wandsimserver</a> can simulate).
However, both frameworks are capable of handling unlimited event
indices, and also have methods for determining the number of event
indices available:<br>
</p>
<pre>unsigned int arSZGAppFramework::getNumberButtons(); <br><br>unsigned int arSZGAppFramework::getNumberAxes();<br><br>unsigned int arSZGAppFramework::getNumberMatrices();<br></pre>
<p>Both frameworks provide a pointer to the current input state, for
more efficient access to input events:<br>
</p>
<pre>const arInputState* getInputState();<br></pre>
<p>Both frameworks support the <a
 href="Navigation.html">Syzygy navigation utilities</a>.
Although the interface is the same, the way it is used is slightly
different under the two frameworks, so we'll discuss that below.<br>
</p>

<a name="MasterSlave">
<p><font size="+2">Master/Slave Framework</font>
</a>

<p>The master/slave framework can be used to construct cluster-based
applications with a dynamically connecting/ disconnecting set of render
nodes. Communication across different machine architectures is supported
so, for instance, the cluster could be composed of both big-endian and
little-endian machines. </p>
<p>The assumption is that, at each stage, a master application sends
enough information to its connected slave applications to enable them to
reconstruct the rendering state. For a large class of applications, this
information is minimal in size. Slave applications can connect or
disconnect from the master at any time. This means that it is possible
to reconfigure displays on the fly, even to move a running program to an
entirely new virtual environment. Note that one cannot currently write a
master/slave application that runs on exactly N nodes and requires each
node to start in unison. </p>
<p> Please note that, while the arMasterSlaveFramework is currently
based on GLUT, this dependency will be going away, so it is unwise to
include GLUT calls in your application code. Furthermore, calls such as
glutPostRedisplay() are known to cause problems with the synchronization
methods used. </p>
<p>Now, we briefly explain the master/slave framework API. To use this
framework, you will need to define several callbacks and define your
usage of the distributed shared memory. First, let's outline the methods
used to set the various callbacks. This also outlines the required
signatures for the callbacks themselves. Note that each callback
includes an argument for a framework reference, which will be filled on
call with a reference to the owning framework object. The start
callback also receives a reference to the framework's arSZGClient,
allowing the callback to, for instance, query the parameter database.

<pre>
  void arMasterSlaveFramework::setStartCallback     
    (bool (*startCallback)(arMasterSlaveFramework&amp; fw, 
                           arSZGClient&amp; client))
    
  void arMasterSlaveFramework::setPreExchangeCallback
    (void (*preExchange)(arMasterSlaveFramework&amp; fw))
    
  void arMasterSlaveFramework::setPostExchangeCallback
    (void (*postExchange)(arMasterSlaveFramework&amp; fw))
    
  void arMasterSlaveFramework::setDrawCallback
    (void (*draw)(arMasterSlaveFramework&amp; fw))
    
  void arMasterSlaveFramework::setPlayCallback
    (void (*play)(arMasterSlaveFramework&amp; fw))
</pre>

<p>An arMasterSlaveFramework application begins by calling the init
method, passing in the command line parameters: </p>
<pre>if (!framework.init(argc,argv))<br>  return 1;<br></pre>
<p>The application should quit if init fails (returns false). </p>
<p>Next, the various callbacks are set, including the important start
callback where shared memory is registered. Other application-specific
initialization can also occur at this time, and this callback is guaranteed
to be called after the graphics window has been initialized, allowing various
OpenGL-related commands to be used. 

<p>Finally, the start() method
sets the application in motion by first executing the user-defined 
startCallback(...). If this callback returns false, the
start() method returns false. Otherwise, it begins
running an event loop defined by the other callbacks.  As with
init(...), if start() returns false then the application should
terminate. </p>
<pre>if (!framework.start())<br>  return 1;<br></pre>
<p>We now detail the event loop: </p>
<ol>
  <li>Poll input devices: The master application instance is connected
to input devices. Here, it copies the current values into memory so they
can be exported via the getButton(...), getAxis(...), and getMatrix(...)
methods. The use of these cached values ensures coherency in
applications that depend on input device state in the event loop stages
occuring after shared-memory export. </li>
  <li>Call the user-defined <em>preExchange()</em> callback: Take an
action before shared memory is exported from the master application
instance to the slave instances. </li>
  <li>Shared memory export: Shared memory is exported from the master
application instance to the slave application instances. This includes
both user-defined blocks of shared-memory and some system level
infomation. The system material includes the current time (milliseconds
elapsed since initialization on the master) and the time needed to
execute the last event loop. It also includes a navigation matrix and
the cached input device values. </li>
  <li>Call the user-defined <em>postExchange()</em> callback: Take
whatever action the user specified. Note that it is safe to query input
device values here. </li>
  <li>Call the user-defined sound (<em>play()</em>) callback: Play
sounds. See the <a href="Sound.html">Sound API</a> documentation for
examples of how to make sounds. </li>
  <li>Call the user-defined <em>draw()</em> callback: Setup the matrix
stack using the current head position and information about the screen
configuration attached to this pipe. Then execute the user-defined draw
callback. </li>
  <li>Synchronization: All connected application instances pause here
until each has reached the barrier. A graphics buffer swap then occurs.</li>
</ol>
<p>Now, we examine the API in more depth, starting with the way the
programmer registers shared memory. In the user-defined <em>initCallback(...)</em>,
the programmer should register shared memory. This is done using the
following method of the arMasterSlaveFramework object: </p>
<pre>bool arMasterSlaveFramework::addTransferField(string fieldName,<br>                                              void* memoryPtr,<br>                                              arDataType theType,<br>                                              int segmentDimension) <br></pre>
<p>The parameter "fieldName" gives the memory a descriptive name. You
pass in an already allocated pointer "memoryPtr" to a block of memory of
type given by "theType" and of dimension "segmentDimension". The data
type needs to be one of AR_INT, AR_FLOAT, AR_DOUBLE, or AR_CHAR. Note
that registering memory is done both in the master instance and the
slave instances of the application. Once memory has been registered, the
programmer uses the pointer normally, with awareness that the contents
of the memory block are transfered from the master to the slaves in step
3 of the event loop. </p>
<p>As an example, the following statement registers a block of 16
floats: </p>
<pre>framework.addTransferField("manipulation matrix", void* floatPtr,<br>                           AR_FLOAT, 16);<br></pre>
<p>The arMasterSlaveFramework objects also maintain consistent time
across nodes. This can be consistently accessed after the shared-memory
exchange step of the event loop. </p>
<pre>double arMasterSlaveFramework::getTime()<br>  Returns the time in milliseconds that have elapsed on the master since<br>  completion of initialization.<br><br>double arMasterSlaveFramework::getLastFrameTime()<br>  Returns the time in milliseconds for the last iteration of the event loop.<br>  measured from one "poll input devices" step tp the next.<br></pre>
<p>Sometimes it is necessary to determine if one is the master node or
not. This is done by the following API call: </p>
<pre>bool arMasterSlaveFramework::getMaster()<br>  Returns whether or not this is the master application instance.<br></pre>
<p>As mentioned above, this framework supports the <a
 href="Navigation.html">navigation utilities</a>. Any of the routines
that modify this navigation may be used, but <span
 style="font-style: italic;">they should only be called on the master
in the preExchange() callback</span>. The framework automatically copies
this matrix from the master to each of the slaves. As mentioned in the
doc chapter on <a href="Navigation.html">navigation</a>, the frameworks
have two navigation-related methods: </p>
<pre>void arMasterSlaveFramework::navUpdate()<br> <br>void arMasterSlaveFramework::loadNavMatrix()<br> </pre>
<p>navUpdate(), like other navigation-matrix modifying routines, should
only be called on the master in preExchange(). &nbsp;loadNavMatrix(),
which loads the current navigation matrix onto the OpenGL matrix stack,
should be called on all instances at the beginning of the drawCallback().<br>
</p>

<p>Finally, the arMasterSlaveFramework object includes an internal
graphics database that uses the same API as that used in writing
distributed scene graph applications. However, in this case, the scene
graph database is not distributed. Each instance of the application has
its own independent database. This functionality is included so that
programmers can make use of arGraphicsDatabase features, like import
filters for OBJ objects. Manipulation of the database can be done using
the API outlined in the <a href="SceneGraph.html">scene graph</a>
documentation chapter. Please note that the "dgSetGraphicsDatabase"
command is not necessary in this context. This is automatically done by
the framework object. Finally, we outline the one arMasterSlaveFramework
method specifically tailored to this: </p>
<pre>void arMasterSlaveFramework:draw()<br>  Draw the internal graphics database.<br></pre>
<p>Finally, it should be possible to integrate master/slave
applications with other libraries that themselves seek to control the
event loop or on based on graphics system other than OpenGL. To make
this possible, the programmer needs to issue the following call instead
of start(): </p>
<pre>bool arMasterSlaveFramework::startWithoutGLUT()<br></pre>
<p>As before, the program should abort if this call returns false. The
programmer now has responsibility for calling (or causing to be called)
a preDraw() method before each frame is drawn and a postDraw() method
after each frame is drawn (but before the buffer swap command has been
issued). Methods for retrieving the framework's computed projection and
modelview matrices are also provided. This enables the programmer to
directly manipulate the viewing API with which he is working. </p>
<pre>void arMasterSlaveFramework::preDraw()<br>  Executes those parts of the event loop that occur before drawing.<br>  <br>void arMasterSlaveFramework::postDraw()<br>  Executes those parts of the event loop that occur after drawing but<br>  before buffer swap (really just synchronization).<br>  <br>arMatrix4 arMasterSlaveFramework::getProjectionMatrix()<br>  Returns the projection matrix calculated by the framework based on<br>  screen characteristics, head position, and head orientation.<br>  <br>arMatrix4 arMasterSlaveFramework::getModelviewMatrix()<br>  Returns the modelview matrix calculated by the framework based on<br>  screen characteristics, head position, and head orientation.<br></pre>

<a name="SceneGraph">
<p><font size="+2">Distributed Scene Graph Framework</font>
</a>

<p>Syzygy facilitates programming VR applications using the distributed
scene graph paradigm with the arDistSceneGraphFramework object. This
object manages connections to the render nodes, sound sources, and input
devices. The programmer manipulates the scene graph using the API
outlined in the <a href="SceneGraph.html">Scene Graph</a> chapter. Note
that there is no need to use the "dgSetGraphicsDatabase" method as that
detail is handled internally by the framework object. </p>
<p>As with the arMasterSlaveFramework, the first thing a distributed
scene graph application should do is initialize its
arDistSceneGraphFramework object, passing it the command line arguments.
Note that the app should quit if this method returns false. </p>
<pre>if (!framework.init(argc, argv))<br>  return 1;<br></pre>
<p>After the program has successfully called init(), it can perform
application-specific initializations like populating the database with
an initial scene.</p>
<p>A distributed scene graph program can operate in two ways. In the
default way, the framework object itself decides when frames will end,
so the programmer directly alters the scene graph. This way is best
when, like in the timetunnel or cubes sample applications, many alterations of roughly
equal importance occur to the database at each frame. In the other way,
the programmer explicitly declares when a frame ends. This is useful
when a few large alterations occur per frame or, generally, when the
programmer wants full control over the contents of successive frames.
The methods to control this behavior follow: </p>
<pre>void arDistSceneGraphFramework::setAutoBufferSwap(bool state)<br>  Sets whether or not buffer swap is automatic. If "true", then buffer<br>  swap occurs automatically. If "false", the buffer swap must be<br>  manually triggered.<br>void arDistSceneGraphFramework::swapBuffers()<br>  Tells the framework to swap buffers.<br></pre>
<p>After application-specific initialization is done, start the
framework. This launches various services like the built-in sound and
graphics servers and the connection to an input device. The application
should quit if start() fails. </p>
<pre>if (!framework.start())<br>  return 1;<br></pre>
<p>Now, you are free to conduct your application's business.  Since
arDistSceneGraphFramework has no event loop, you must explicitly tell it
when to sample and set head position information from the viewer, as is
necessary for correct calculation of the viewing frustum and sound
spatialization. Also, if you are using framework-mediated <a
 href="Navigation.html">navigation</a>, you should call the relevant
routines &nbsp;at this time: </p>
<pre>void arDistSceneGraphFramework::navUpdate();<br><br>  Polls the input device and updates the navigation matrix appropriately.<br><br><br>void arDistSceneGraphFramework::loadNavMatrix();<br><br>  Updates the navigation matrix in the graphics database.<br><br><br>void arDistSceneGraphFramework::setViewer()<br><br>  Polls the input device and sets the viewing transform accordingly.<br><br><br>void arDistSceneGraphFramework::setPlayer()<br><br>  Polls the input device and sets the play transform accordingly (for spatialized sound).<br><br></pre>
<p>A final note about navigation: if you're using framework-mediated
navigation with this framework, then you must use the following routine
to get the name of the navigation matrix node in the <a
 href="SceneGraph.html">scene graph</a> and attach any nodes (objects,
matrices, whatever) that you create to it:<br>
</p>
<pre>string arDistSceneGraphFramework::getNavNodeName();<br></pre>
<hr>

</body>
</html>
