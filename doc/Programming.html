<html>
<head>
  <title>Introduction to Syzygy Programming</title>
</head>
<body style="background-color: rgb(255, 255, 255);">
<a href="index.html">Documentation Index</a> <font size="+2"></font>
<p><font size="+2">Introduction to Syzygy Programming</font>

<p>This chapter describes the broad programming styles supported by Syzygy:
the master/slave framework and the distributed scene graph framework. 
The master/slave style gives the programmer greater flexiblity, like the
ability to use OpenGL directly in code, but requires care to produce an
application that displays consistently on all cluster render nodes. On the
other hand, distributed scene graph applications are guaranteed to display
consistently across cluster nodes, but require the programmer to utilize the
Syzygy scene graph <a href="SceneGraph.html">API</a>.

<p>We also show how to leverage the existing Syzygy build structure to
create portable build structures for your own projects, using a provided
project template.

<p><ul>
<li><a href="#CommonFeatures">Common Features of Both Framworks</a>
<li><a href="#MasterSlave">Master/Slave Framework</a>
<li><a href="#SceneGraph">Distributed Scene Graph Framework</a>
<li><a href="#HowToCompile">Compiling Syzygy C++ Applications</a>
</ul>

<p>Syzygy VR programming is accomplished by using a framework object
that manages the many components of the networked VR application. The
framework object is responsble for application launching and shutdown.
It also handles communications, synchronization, graphics, sound, and
input device. Most importantly, these objects isolate the programmer from
lower levels of the Syzygy library, making it more practical to evolve
those APIs while leaving the high-level programmer API constant.

<p>Syzygy presents two paradigms for programming VR applications. The
first is encapsulated in the arMasterSlaveFramework object. This
framework is suited to coding cluster graphics applications where
multiple copies of the application will run, one on each render node. We
refer to such applications as master/slave, since one instance of the
application, the master, controls the operation of the others, the
slaves. The second paradigm is contained in the
arDistSceneGraphFramework. Here, a single copy of the application runs,
producing graphics by manipulating a scene graph database. This database
is automatically synchronized with databases present on the cluster's
render nodes, where a special application, szgrender, handles the
drawing. Both of these frameworks are subclasses of arSZGAppFramework,
which contains the common aspects of the two frameworks.

<p>The distributed scene graph framework provides provably synchronized
graphics on the render nodes, regardless of the nature of the
application. This comes at a price, however. The application developer
can only express herself by means of the scene graph API, which contains
primitives for constructing some simple geometric objects. Applications
that only require objects supported by the scene graph API may be easier
to construct using this framework. On the other hand, applications built
upon the master/slave framework can make use of the standard OpenGL API.
The master/slave framework thus offers an easy migration path for
existing applications to cluster-based operation; two of the included <a
 href="ExampleCode.html">sample applications</a>, 
<em>atlantis</em> and <em>coaster</em>,
were easily ported to Syzygy from the standard GLUT distribution using
the master/slave framework. But this flexibility means it is possible to
write unsynchronized applications.

<p>Samples of both programming styles can be found under szg/src/demo.
Please see the <a href="ExampleCode.html">examples</a> chapter of this
documentation for more information.<br>

<a name="CommonFeatures">
<p><font size="+2">Common Features of Both Frameworks</font>
</a>

<p>Both frameworks have routines for setting the user's interocular
separation, near and far clipping planes, and the unit conversion
factors for both rendering and sound production:<br>
</p>
<pre>void arSZGAppFramework::setEyeSpacing( float feet );<br><br>void arSZGAppFramework::setClipPlanes( float near, float far );<br><br>virtual arSZGAppFramework::void setUnitConversion( float feet_to_program_units );<br><br>virtual arSZGAppFramework::void setUnitSoundConversion( float feet_to_program_units );<br><br></pre>
<p>Note that, if used, the unit conversion factors should be set <span
 style="font-style: italic;">before</span> the framework's init() method
is called (because database parameters are read in the init(), and some
of them may require the unit conversion factors), whereas the eye
spacing and clipping planes should be set <span
 style="font-style: italic;">after</span> init() (because otherwise they
may be overridden). Both have routines for accessing the Syzygy data
path, stored on each machine in SZG_DATA/path:<br>
</p>
<pre>const string arSZGAppFramework::getDataPath()<br><br></pre>
<p>Input. The frameworks provide methods for polling the current state
of the various <a href="InputDevices.html">input events</a>:</p>
<pre>int arSZGAppFramework::getButton( unsigned int index );<br>  Returns the value (0 or 1) of the named button. Button numbering starts<br>  at 0.<br><br>float arSZGAppFramework::getAxis( unsigned int index );<br>  Returns the value of the named axis. Axis numbering starts at 0.<br><br>arMatrix4 arSZGAppFramework::getMatrix( unsigned int index );<br>  Returns the value of the named matrix. Matrix numbering starts at 0.<br>  Note that in our applications the "head matrix" is currently hard-coded as matrix 0<br>  and the "wand matrix" is currently hard-coded as matrix 1. Information<br>  about the arMatrix4 object can be found by examining szg/src/math/arMath.h.<br></pre>
<p>Many of the included Syzygy sample applications expect a standard CAVE-style input
device: 3 buttons, 2 axes, 2 matrices (which <a
 href="InputDevices-Drivers.html">wandsimserver</a> can simulate).
However, both frameworks are capable of handling unlimited event
indices, and also have methods for determining the number of event
indices available:<br>
</p>
<pre>unsigned int arSZGAppFramework::getNumberButtons(); <br><br>unsigned int arSZGAppFramework::getNumberAxes();<br><br>unsigned int arSZGAppFramework::getNumberMatrices();<br></pre>
<p>Both frameworks provide a pointer to the current input state, for
more efficient access to input events:<br>
</p>
<pre>const arInputState* getInputState();<br></pre>
<p>Both frameworks support the <a
 href="Navigation.html">Syzygy navigation utilities</a>.
Although the interface is the same, the way it is used is slightly
different under the two frameworks, so we'll discuss that below.<br>
</p>

<a name="MasterSlave">
<p><font size="+2">Master/Slave Framework</font>
</a>

<p>The master/slave framework can be used to construct cluster-based
applications with a dynamically connecting/ disconnecting set of render
nodes. Communication across different machine architectures is supported
so, for instance, the cluster could be composed of both big-endian and
little-endian machines. </p>
<p>The assumption is that, at each stage, a master application sends
enough information to its connected slave applications to enable them to
reconstruct the rendering state. For a large class of applications, this
information is minimal in size. Slave applications can connect or
disconnect from the master at any time. This means that it is possible
to reconfigure displays on the fly, even to move a running program to an
entirely new virtual environment. Note that one cannot currently write a
master/slave application that runs on exactly N nodes and requires each
node to start in unison. </p>
<p> Please note that, while the arMasterSlaveFramework is currently
based on GLUT, this dependency will be going away, so it is unwise to
include GLUT calls in your application code. Furthermore, calls such as
glutPostRedisplay() are known to cause problems with the synchronization
methods used. </p>
<p>Now, we briefly explain the master/slave framework API. To use this
framework, you will need to define several callbacks and define your
usage of the distributed shared memory. First, let's outline the methods
used to set the various callbacks. This also outlines the required
signatures for the callbacks themselves. Note that each callback
includes an argument for a framework reference, which will be filled on
call with a reference to the owning framework object. The initialization
callback also receives a reference to the framework's arSZGClient,
allowing the callback to, for instance, query the parameter database. </p>
<pre>void arMasterSlaveFramework::setInitCallback<br>      (bool (*initCallback)(arMasterSlaveFramework&amp; fw,<br>                            arSZGClient&amp; client))<br><br>void arMasterSlaveFramework::setPreExchangeCallback<br>       (void (*preExchange)(arMasterSlaveFramework&amp; fw))<br><br>void arMasterSlaveFramework::setPostExchangeCallback<br>       (bool (*postExchange)(arMasterSlaveFramework&amp; fw))<br><br>void arMasterSlaveFramework::setDrawCallback<br>       (void (*draw)(arMasterSlaveFramework&amp; fw))<br><br>void arMasterSlaveFramework::setPlayCallback<br>       (void (*play)(arMasterSlaveFramework&amp; fw))<br></pre>
<p>An arMasterSlaveFramework application begins by calling the init
method, passing in the command line parameters: </p>
<pre>if (!framework.init(argc,argv))<br>  return 1;<br></pre>
<p>The application should quit if init fails (returns false). </p>
<p>Next, the various callbacks are set, including the important init
callback where shared memory is registered. Other application-specific
initialization can also occur at this time. Finally, the start() method
sets the application in motion. It first executes the user-defined <em>initCallback(...)</em>
and then runs an event loop defined by the other callbacks.  As with
initCallback(...), if start() returns false then the application should
terminate. </p>
<pre>if (!framework.start())<br>  return 1;<br></pre>
<p>We now detail the event loop: </p>
<ol>
  <li>Poll input devices: The master application instance is connected
to input devices. Here, it copies the current values into memory so they
can be exported via the getButton(...), getAxis(...), and getMatrix(...)
methods. The use of these cached values ensures coherency in
applications that depend on input device state in the event loop stages
occuring after shared-memory export. </li>
  <li>Call the user-defined <em>preExchange()</em> callback: Take an
action before shared memory is exported from the master application
instance to the slave instances. </li>
  <li>Shared memory export: Shared memory is exported from the master
application instance to the slave application instances. This includes
both user-defined blocks of shared-memory and some system level
infomation. The system material includes the current time (milliseconds
elapsed since initialization on the master) and the time needed to
execute the last event loop. It also includes a navigation matrix and
the cached input device values. </li>
  <li>Call the user-defined <em>postExchange()</em> callback: Take
whatever action the user specified. Note that it is safe to query input
device values here. </li>
  <li>Call the user-defined sound (<em>play()</em>) callback: Play
sounds. See the <a href="Sound.html">Sound API</a> documentation for
examples of how to make sounds. </li>
  <li>Call the user-defined <em>draw()</em> callback: Setup the matrix
stack using the current head position and information about the screen
configuration attached to this pipe. Then execute the user-defined draw
callback. </li>
  <li>Synchronization: All connected application instances pause here
until each has reached the barrier. A graphics buffer swap then occurs.</li>
</ol>
<p>Now, we examine the API in more depth, starting with the way the
programmer registers shared memory. In the user-defined <em>initCallback(...)</em>,
the programmer should register shared memory. This is done using the
following method of the arMasterSlaveFramework object: </p>
<pre>bool arMasterSlaveFramework::addTransferField(string fieldName,<br>                                              void* memoryPtr,<br>                                              arDataType theType,<br>                                              int segmentDimension) <br></pre>
<p>The parameter "fieldName" gives the memory a descriptive name. You
pass in an already allocated pointer "memoryPtr" to a block of memory of
type given by "theType" and of dimension "segmentDimension". The data
type needs to be one of AR_INT, AR_FLOAT, AR_DOUBLE, or AR_CHAR. Note
that registering memory is done both in the master instance and the
slave instances of the application. Once memory has been registered, the
programmer uses the pointer normally, with awareness that the contents
of the memory block are transfered from the master to the slaves in step
3 of the event loop. </p>
<p>As an example, the following statement registers a block of 16
floats: </p>
<pre>framework.addTransferField("manipulation matrix", void* floatPtr,<br>                           AR_FLOAT, 16);<br></pre>
<p>The arMasterSlaveFramework objects also maintain consistent time
across nodes. This can be consistently accessed after the shared-memory
exchange step of the event loop. </p>
<pre>double arMasterSlaveFramework::getTime()<br>  Returns the time in milliseconds that have elapsed on the master since<br>  completion of initialization.<br><br>double arMasterSlaveFramework::getLastFrameTime()<br>  Returns the time in milliseconds for the last iteration of the event loop.<br>  measured from one "poll input devices" step tp the next.<br></pre>
<p>Sometimes it is necessary to determine if one is the master node or
not. This is done by the following API call: </p>
<pre>bool arMasterSlaveFramework::getMaster()<br>  Returns whether or not this is the master application instance.<br></pre>
<p>As mentioned above, this framework supports the <a
 href="Navigation.html">navigation utilities</a>. Any of the routines
that modify this navigation may be used, but <span
 style="font-style: italic;">they should only be called on the master
in the preExchange() callback</span>. The framework automatically copies
this matrix from the master to each of the slaves. As mentioned in the
doc chapter on <a href="Navigation.html">navigation</a>, the frameworks
have two navigation-related methods: </p>
<pre>void arMasterSlaveFramework::navUpdate()<br> <br>void arMasterSlaveFramework::loadNavMatrix()<br> </pre>
<p>navUpdate(), like other navigation-matrix modifying routines, should
only be called on the master in preExchange(). &nbsp;loadNavMatrix(),
which loads the current navigation matrix onto the OpenGL matrix stack,
should be called on all instances at the beginning of the drawCallback().<br>
</p>
<p>The master/slave framework also includes a facility for generating
parallel sequences of pseudorandom numbers on the various computers in a
cluster. Use of this facility requires a modest amount of care, so it is
separately documented in <a href="RandomNumbers.html">RandomNumbers.html</a>.</p>
<p>Finally, the arMasterSlaveFramework object includes an internal
graphics database that uses the same API as that used in writing
distributed scene graph applications. However, in this case, the scene
graph database is not distributed. Each instance of the application has
its own independent database. This functionality is included so that
programmers can make use of arGraphicsDatabase features, like import
filters for OBJ objects. Manipulation of the database can be done using
the API outlined in the <a href="SceneGraph.html">scene graph</a>
documentation chapter. Please note that the "dgSetGraphicsDatabase"
command is not necessary in this context. This is automatically done by
the framework object. Finally, we outline the one arMasterSlaveFramework
method specifically tailored to this: </p>
<pre>void arMasterSlaveFramework:draw()<br>  Draw the internal graphics database.<br></pre>
<p>Finally, it should be possible to integrate master/slave
applications with other libraries that themselves seek to control the
event loop or on based on graphics system other than OpenGL. To make
this possible, the programmer needs to issue the following call instead
of start(): </p>
<pre>bool arMasterSlaveFramework::startWithoutGLUT()<br></pre>
<p>As before, the program should abort if this call returns false. The
programmer now has responsibility for calling (or causing to be called)
a preDraw() method before each frame is drawn and a postDraw() method
after each frame is drawn (but before the buffer swap command has been
issued). Methods for retrieving the framework's computed projection and
modelview matrices are also provided. This enables the programmer to
directly manipulate the viewing API with which he is working. </p>
<pre>void arMasterSlaveFramework::preDraw()<br>  Executes those parts of the event loop that occur before drawing.<br>  <br>void arMasterSlaveFramework::postDraw()<br>  Executes those parts of the event loop that occur after drawing but<br>  before buffer swap (really just synchronization).<br>  <br>arMatrix4 arMasterSlaveFramework::getProjectionMatrix()<br>  Returns the projection matrix calculated by the framework based on<br>  screen characteristics, head position, and head orientation.<br>  <br>arMatrix4 arMasterSlaveFramework::getModelviewMatrix()<br>  Returns the modelview matrix calculated by the framework based on<br>  screen characteristics, head position, and head orientation.<br></pre>

<a name="SceneGraph">
<p><font size="+2">Distributed Scene Graph Framework</font>
</a>

<p>Syzygy facilitates programming VR applications using the distributed
scene graph paradigm with the arDistSceneGraphFramework object. This
object manages connections to the render nodes, sound sources, and input
devices. The programmer manipulates the scene graph using the API
outlined in the <a href="SceneGraph.html">Scene Graph</a> chapter. Note
that there is no need to use the "dgSetGraphicsDatabase" method as that
detail is handled internally by the framework object. </p>
<p>As with the arMasterSlaveFramework, the first thing a distributed
scene graph application should do is initialize its
arDistSceneGraphFramework object, passing it the command line arguments.
Note that the app should quit if this method returns false. </p>
<pre>if (!framework.init(argc, argv))<br>  return 1;<br></pre>
<p>After the program has successfully called init(), it can perform
application-specific initializations like populating the database with
an initial scene.</p>
<p>A distributed scene graph program can operate in two ways. In the
default way, the framework object itself decides when frames will end,
so the programmer directly alters the scene graph. This way is best
when, like in the timetunnel or cubes sample applications, many alterations of roughly
equal importance occur to the database at each frame. In the other way,
the programmer explicitly declares when a frame ends. This is useful
when a few large alterations occur per frame or, generally, when the
programmer wants full control over the contents of successive frames.
The methods to control this behavior follow: </p>
<pre>void arDistSceneGraphFramework::setAutoBufferSwap(bool state)<br>  Sets whether or not buffer swap is automatic. If "true", then buffer<br>  swap occurs automatically. If "false", the buffer swap must be<br>  manually triggered.<br>void arDistSceneGraphFramework::swapBuffers()<br>  Tells the framework to swap buffers.<br></pre>
<p>After application-specific initialization is done, start the
framework. This launches various services like the built-in sound and
graphics servers and the connection to an input device. The application
should quit if start() fails. </p>
<pre>if (!framework.start())<br>  return 1;<br></pre>
<p>Now, you are free to conduct your application's business.  Since
arDistSceneGraphFramework has no event loop, you must explicitly tell it
when to sample and set head position information from the viewer, as is
necessary for correct calculation of the viewing frustum and sound
spatialization. Also, if you are using framework-mediated <a
 href="Navigation.html">navigation</a>, you should call the relevant
routines &nbsp;at this time: </p>
<pre>void arDistSceneGraphFramework::navUpdate();<br><br>  Polls the input device and updates the navigation matrix appropriately.<br><br><br>void arDistSceneGraphFramework::loadNavMatrix();<br><br>  Updates the navigation matrix in the graphics database.<br><br><br>void arDistSceneGraphFramework::setViewer()<br><br>  Polls the input device and sets the viewing transform accordingly.<br><br><br>void arDistSceneGraphFramework::setPlayer()<br><br>  Polls the input device and sets the play transform accordingly (for spatialized sound).<br><br></pre>
<p>A final note about navigation: if you're using framework-mediated
navigation with this framework, then you must use the following routine
to get the name of the navigation matrix node in the <a
 href="SceneGraph.html">scene graph</a> and attach any nodes (objects,
matrices, whatever) that you create to it:<br>
</p>
<pre>string arDistSceneGraphFramework::getNavNodeName();<br></pre>

<a name="HowToCompile">
<p><font size="+2">Compiling Syzygy C++ Applications</font>
</a>

<p>There are two ways to build Syzygy applications, depending upon how you
have obtained the software. If you want to use software you have built 
yourself, you will use the "developer" method, which is the default. If
you want to use a precompiled Syzygy SDK, then you will use the "easy"
method, in which case your SZG_DEVELOPER_STYLE environment variable
must be set to "EASY". In either case, your SZGHOME environment variable
must be set to the top level of your Syzygy distribution for proper operation.

<p>Syzygy has a build system designed for writing cross-platform applications,
hiding the differences from the programmer. A motivating example of
its design is: if your build directory is simultaneously mounted on different 
platforms, you can compile both versions of your code at once. The build
system can be leveraged for your own applications and a template is contained
in szg_app_template-X.X.tar.gz, which is available with the rest of the 
Syzygy software.

<p>After obtaining the template, unpack it to a directory szg_app_template. If
desired, you can rename it, though we continue using the generic name below
for simplicity. If your each file of your source code produces an 
executable, you can create your Syzygy project by simply modifying one
line (ALL) and then creating a target for each executable, as outlined below.
It is also simple to, for instance, modify the Makefile template to produce
executables from multiple .cpp files (using the OBJS line). 

<p>Once you have modified szg_app_template to create your project, you can
build it by typing "make" in the top-level directory or clean it, removing
built executables and objects, by typing "make clean" in the same location.
All built executables (defined by ALL below) will be copied into your
Syzygy executables directory. This is determined like so:

<p><ol>
<li>If $SZGBIN is defined, then this is used as the directory for Syzygy
executables.
<li>If $SZGBIN is not defined, there are two possibilities, depending upon
whether or not the developer style is "EASY".
  <ul>
  <li>If SZG_DEVELOPER_STYLE=EASY, then your executables will be placed
      in $(SZGHOME)/bin. 
  <li>Otherwise, you are assumed to have a "developer" version of Syzygy
      and your executables will be placed in $(SZGHOME)/bin/$(MACHINE_DIR),
      where $(MACHINE_DIR) is one of darwin, linux, mips4, or win32.
  </ul>
</ol>

<p>PLEASE NOTE: if you are compiling using cygwin on Windows then there can 
be a problem. The Visual Studio linker is called "link" and some installs of
cygwin mayn also install a "link" program. If, during your build, you see
an error message like:

<pre>
  link error: too many arguments
</pre>

You will know you are getting the cygwin "link" program by mistake. You can
solve this problem by typing "which link", seeing where the cygwin "link"
resides, and removing it, or you can make sure your $PATH environment
variable has the Visual Studio program in it first (as explained
<a href="VisualStudioBuildVars.html">here</a>).

<p>With that warning given, we now examine the contents of szg_app_template, 
explaining each one.

<p><ul>
<li>szg_app_template/Makefile: The overall Makefile for the template project.
Scans the host to determine the platform and then executes the appropriate
machine-specific Makefile.
<li>szg_app_template/src: Your source code goes here, after removing the
sample piece of source code, szglorenz.cpp.
<li>szg_app_template/build/makefiles/Makefile.my_app: This is the fill you will
edit to create your project. Its important features are explained below as
well as via comments in the file itself.
<li>szg_app_template/build/darwin: The Mac OS X-specific Makefile is located
here and OS X objects are built here. The machine-specific Makefile really just
sets the machine type and then includes Makefile.my_app, the cross-platform
piece.
<li>szg_app_template/build/linux: The Linux objects are built here.
<li>szg_app_template/build/mips4: The SGI objects are built here.
<li>szg_app_template/build/win32: The Windows objects are built here.
</ul>

<p>By now, you have placed your source code in szg_app_template/src. The
functional lines in Makefile.my_app, along with how to edit them will now be 
explained.

<pre>
  VPATH=../../src
</pre>

<p>This should not be changed. It gives the relative path from each
machine-specific Makefile, like szg_app_template/build/linux/Makefile,
to your source directory.

<pre>
  include $(SZGHOME)/build/make/Makefile.vars
</pre>

<p>This should not be changed. The Syzygy SDK has a file, Makefile.vars,
that defines the specific compilation and linking methods for each platform
in a modular fashion. This line is one reason you must define $SZGHOME to
use the Syzygy SDK.

<pre>
  ALL := szglorenz$(EXE)
</pre> 

<p>Here, you should replace szglorenz$(EXE) with a list of executables
you want built. For cross-platform builds to work, each name must end in
$(EXE), which accounts for the fact that Windows executables must have the
postfix .EXE whereas Unix executables do not.

<pre>
  include $(SZGHOME)/build/make/Makefile.rules
</pre>

<p>This should not be changed. The Syzygy SDK has a file, Makefile.rules,
that defines the various standard rules, like "clean" or "create-install",
which should be in every project. This file is seperated from Makefile.vars
to create flexibility: make is particular about the order in which rules
appear.

<pre>
  OBJS := 
</pre>

<p>If your executable uses code contained in files my_obj_1.cpp and 
my_obj_2.cpp, you'll need to edit this line. Do not forget the $(OBJ_SUFFIX)
ending, since this accounts for the different object file endings on Windows
(.obj) and Unix (.o). There is a make rule in Makefile.rules that governs
converting .cpp files into object files.

<pre>
  OBJS := my_obj_1$(OBJ_SUFFIX) my_obj_2$(OBJ_SUFFIX)
</pre>

<p>If your project needs additional compile flags, you can include them like
so:

<pre>
  COMPILE_FLAGS += -DMY_COMPILE_FLAG1 -DMY_COMPILE_FLAG2
</pre>

<p>If your project needs additional include directories, you can add them like
so:

<pre>
  SZG_INCLUDE += -I$(MY_INCLUDE_DIRECTORY1)
</pre>

<p>If your project needs additional libraries, you can add them like so:

<pre>
  SZG_OPTIONAL_LIBS += $(MY_NEW_LIBRARY)
</pre>

<p>Finally, you'll need a target for each of your executables. If your
executables, as listed above in ALL, have names my_exe_1$(EXE) and
my_exe_2$(EXE) and they link with the OBJS you've defined above, then the
targets will look like:

<pre>
  my_exe_1$(EXE): my_exe_1$(OBJ_SUFFIX) $(OBJS) $(SZG_LIBRARY_DEPS)
        $(SZG_USR_FIRST) my_exe_1$(OBJ_SUFFIX) $(OBJS) $(SZG_USR_SECOND)
        $(COPY)

  my_exe_2$(EXE): my_exe_2$(OBJ_SUFFIX) $(OBJS) $(SZG_LIBRARY_DEPS)
        $(SZG_USR_FIRST) my_exe_2$(OBJ_SUFFIX) $(OBJS) $(SZG_USR_SECOND)
        $(COPY)

</pre>

<p>The variable $(SZG_USR_FIRST) contains the linker name, linker options
and link libraries, if the platform is Windows. If the platform is Unix-based,
it does not contain the link libraries, which instead appear in 
$(SZG_USR_SECOND), which is blank in the Windows case.
The $(COPY) line copies the built executable into your $SZGBIN directory
where all of your Syzygy-related executables are stored.
</body>
</html>
