#**************************************************************
# This file sets compiler flag definitions based on MACHINE
# (as determined by Makefile.os) and further modifies these
# based on Makefile.libscan, which figures out which optional
# libraries have been installed.
#**************************************************************

#**************************************************************
# The environment variables that affect the build are:
#  SZGHOME: REQUIRED. The top-level directory of the szg.
#  SZGBIN: Optional. If defined, this is where the executables
#          and shared libraries are placed. Otherwise, they
#          are placed in $(SZGHOME)/bin/$(MACHINE_DIR).
#          NOTE: This MUST be set for targets like "install-shared"
#          to work.
#  SZGEXTERNAL: Optional. This is where external libraries get
#               placed (in a defined directory structure) if
#               they are to be used by the library. However,
#               if SZG_DEVELOPER_STYLE=EASY, then SZGEXTERNAL
#               is *ignored* and the build process searches 
#               for the external libraries in 
#               $(SZGHOME)/external.
#  SZGDEBUG: Optional. If defined and equal to TRUE, the
#            libraries, executables, and plugins are built 
#            debug.
#  SZG_DEVELOPER_STYLE: Optional. If defined and equal to EASY,
#                       a special build process is used for
#                       external executables (which is suited
#                       to using prebuilt libraries).
#  SZG_STLPORT: Optional. This is only respected on the windows
#               side. Present since Visual Studio 6 did not 
#               have a good enough implementation of the STL
#               to use with our dll approach in szg-0.7 and 
#               later. If this is set to TRUE, a *windows* 
#               build will attempt to use STLport as the
#               c++ standard lib.
#  SZG_USE_PCH: Optional. Only has meaning on the Windows side.
#               If SZG_DEVELOPER_STYLE is not EASY, then setting
#               this to FALSE over-rides the default (in the
#               DEVELOPER build style it is to use them) and
#               the build will NOT use precompiled headers.
#  SZG_MULTITEX: Some platforms do not seem to support the 
#                multitexturing extension tricks of the q33
#                demo (some versions of OS X and RedHat 9).
#                Set this to FALSE, and q33 will compile on
#                those platforms.
#  SZG_LINKING: Optional. If this is set to STATIC, the szg
#               libraries will be built as static objects and
#               execuatbles will statically link them.
#**************************************************************

#**************************************************************
#                             LINUX
#**************************************************************

ifeq ($(strip $(MACHINE)),LINUX)
  MACHINE_DIR = linux
  # NOTE: Each time an executable or shared library gets built, it is
  # automatically copied. Do NOT use "cp -u" here (the only-copy-for-update
  # is vulnerable to clock misalignment (i.e. "why isn't my new executable
  # running?")
  CP = cp

# The suffixes unique to the platform.
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  PLUGIN_SUFFIX=.so
  STATIC_SUFFIX=.a
  EXE = 

# General info regarding compiling such as flags for the various build styles.
# NOTE: since we are building DLL's, need POSITION INDEPENDENT code
  COMPILER = g++
  COMPILE_FLAGS_NDEBUG = -DAR_USE_LINUX -c -fPIC -O2 -Wall -W \
    -Wpointer-arith -march=i686 $(SZG_OPT_FLAGS)
  COMPILE_FLAGS_DEBUG = -DAR_USE_LINUX -c -fPIC -g -Wall -W \
    -Wpointer-arith -march=i686 $(SZG_OPT_FLAGS)
  # Do NOT use ":=" in defining COMPILE_FLAGS, since this allows more
  # flexibility in where SZG_OPT_FLAGS is defined.
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS = $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS = $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED = $(COMPILE_FLAGS)

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# This covers up the fact that precompiled headers are not needed on the
# Unix side.  
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

# General settings regarding linking, such as flags and libraries.
  LINKER = g++
  STATIC_LINKER = ar -r
  LINK_PREFIX = 
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG = $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  LINK_FLAGS_PLUGIN = -shared -o
  GENERAL_LIBS = -ldl -lpthread -lm
  # NOTE: glut does not appear below but is instead dealt with in
  # Makefile.libscan (we might not want to install a glut, but instead
  # use one from SZGEXTERNAL)
  GRAPHICS_LIBS = -lGLU -lGL -L/usr/X11R6/lib -lX11 -lXext -lXmu \
    -lXt -lXi -lSM -lICE
  GAMEPAD_LIBS =

# The flags for library search vary based on whether or not our build style
# is EASY. If so, in addition to changing the compile-time search location,
# do not add a runtime path. Because the built-in runtime search paths will
# be unhelpful (libarPhleet.so will search for libarLanguage.so on its
# location for the developer who compiled the libraries), it is no extra
# burden to make the user set LD_LIBRARY_PATH.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(SZG_BINDIR) -Wl,-rpath,$(SZG_BINDIR)
  endif

  # These link the libs (i.e. libarLanguage$(DLL_SUFFIX), etc.)
  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  # These link the exe's that only depend on intermediate stages of the build.
  # (for instance szgserver, szgrender, etc.). Since these are built out
  # of an "intermediate" Makefile, then must link with the lib built
  # via that Makefile (given by SZG_CURRENT_LIB_MOD_NAME) AND the
  # cumulative libs that it depends upon.
  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_MOD_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  # These link the exe's that utilize the full range of szg shared libraries.
  # This is the link line that an end user would employ to link his 
  # application, hence "USR"
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage$(SZG_STATIC_MOD)
  PHLEET_LIB_STRING = -larPhleet$(SZG_STATIC_MOD)
  BARRIER_LIB_STRING = -larBarrier$(SZG_STATIC_MOD)
  MATH_LIB_STRING = -larMath$(SZG_STATIC_MOD)
  DRIVERS_LIB_STRING = -larDrivers$(SZG_STATIC_MOD)
  GRAPHICS_LIB_STRING = -larGraphics$(SZG_STATIC_MOD)
  SOUND_LIB_STRING = -larSound$(SZG_STATIC_MOD)
  OBJECT_LIB_STRING = -larObject$(SZG_STATIC_MOD)
  INTERACT_LIB_STRING = -larInteraction$(SZG_STATIC_MOD)
  FRAMEWORK_LIB_STRING = -larFramework$(SZG_STATIC_MOD)

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = touch
endif

#*************************************************************
#                             OS X
#*************************************************************

ifeq ($(strip $(MACHINE)),DARWIN)
  MACHINE_DIR = darwin
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.dylib
  LIB_SUFFIX=.dylib
  PLUGIN_SUFFIX=.so
  STATIC_SUFFIX=.a
  EXE =

# compilation
  COMPILER = c++
  COMPILE_FLAGS_NDEBUG = -DAR_BIG_ENDIAN -DAR_USE_DARWIN $(SZG_OPT_FLAGS) \
    -fno-common -fPIC -O2 -c
  COMPILE_FLAGS_DEBUG = -DAR_BIG_ENDIAN -DAR_USE_DARWIN $(SZG_OPT_FLAGS) \
    -fno-common -fPIC -c -g
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS = $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS = $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED=$(COMPILE_FLAGS)

  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif
  
# linking
  LINKER = c++
  STATIC_LINKER = ar -r
  LINK_PREFIX =
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG = $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -dynamiclib -flat_namespace -undefined suppress -o
  LINK_FLAGS_PLUGIN = -bundle -flat_namespace -undefined suppress -o
  
  GENERAL_LIBS = -lm -lpthread -lcurses -lobjc
  GRAPHICS_LIBS = -L/usr/X11R6/lib -lX11 -lXext -lGL -framework OpenGL -framework GLUT -framework COCOA
  GAMEPAD_LIBS = 

# OS X needs an outside library to support dlopen.
  SZG_DLL_LIB = $(SZGHOME)/contrib/dlcompat/libdl.a
  SZG_DLL_INCLUDE = -I$(SZGHOME)/contrib/dlcompat

# OS X needs to explicitly set the location of glx.h
# Yes, this IS misnamed... But it fits it with what is already around!
  SZG_INCLUDE_GLUT = -I/usr/X11R6/include
 
# The flags for library search vary based on whether or not our build style
# is EASY. Since OS X allows relative runtime paths, things are a little
# easier than the other Unixes because it won't be strictly necessary to 
# set DYLD_LIBRARY_PATH (the equivalent of LD_LIBRARY_PATH for Darwin)
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(SZG_BINDIR)
  endif

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS) -install_name @executable_path/$(SZG_CURRENT_LIB)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_MOD_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage$(SZG_STATIC_MOD)
  PHLEET_LIB_STRING = -larPhleet$(SZG_STATIC_MOD)
  BARRIER_LIB_STRING = -larBarrier$(SZG_STATIC_MOD)
  MATH_LIB_STRING = -larMath$(SZG_STATIC_MOD)
  DRIVERS_LIB_STRING = -larDrivers$(SZG_STATIC_MOD)
  GRAPHICS_LIB_STRING = -larGraphics$(SZG_STATIC_MOD)
  SOUND_LIB_STRING = -larSound$(SZG_STATIC_MOD)
  OBJECT_LIB_STRING = -larObject$(SZG_STATIC_MOD)
  INTERACT_LIB_STRING = -larInteraction$(SZG_STATIC_MOD)
  FRAMEWORK_LIB_STRING = -larFramework$(SZG_STATIC_MOD)


# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = ranlib

endif

#*************************************************************
#                             SGI
#*************************************************************


# Handle mips3/mips4 architecture on SGI.
ifeq ($(strip $(MACHINE)),MIPS3)
  MACHINE_DIR = mips3
  MACHINE = SGI
endif
ifeq ($(strip $(MACHINE)),MIPS4)
  MACHINE_DIR = mips4
  MACHINE = SGI
endif

ifeq ($(strip $(MACHINE)),SGI)
# At one time, the SGI compiler CC did not emit thread-safe code 
# when using STL. This seems to have changed sometime late in the
# Irix 6.5 series. Consequently, use CC (we did some experimentation
# with g++ in the past, but this wasn't so helpful since g++ seemed to
# use the native libc, and inherited the thread-safety problems).

# Finally, it seems like the modern SGI compilers, when properly
# set-up, emit code that is thread-safe vis-a-vis STL without
# as many flags (the real test is the STL-thread-safety hammer that
# is contained in the TestLanguage unit test). For the sake of
# history, the additional flags are reproduced here (they might never
# have done any good). They were passed to both the compiler and the 
# linker.
# -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE
 
# DO NOT use "cp -u" since it is vulnerable to clock misalignment
# (i.e. "Why hasn't my new executable copied over?")
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  PLUGIN_SUFFIX=.so
  STATIC_SUFFIX=.a
  EXE = 

# compilation
  COMPILER = CC
# -LANG:std is necessary to allow the use of the new-style C++ headers
# (i.e. <iostream> vs. <iostream.h>)
# Without -ptused there are problems with template code.
# NOTE: position independent code is generated by default by the
# CC compiler, consequently we do not need any special flags!
# In fact, recent versions of the compiler COMPLAIN if we, in fact,
# use the -kPIC flag (saying it isn't supported anymore).
  COMPILE_FLAGS_NDEBUG =  $(SZG_OPT_FLAGS) -DAR_USE_SGI -LANG:std -n32 \
    -ptused -c
  COMPILE_FLAGS_DEBUG = $(SZG_OPT_FLAGS) -DAR_USE_SGI -LANG:std -n32 -ptused \
    -c -g
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS = $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS = $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED = $(COMPILE_FLAGS)

  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# linking
  LINKER = CC
  STATIC_LINKER = ar -r
# Without -no_prelink, there are problems with template code.
  LINK_FLAGS = -LANG:std -n32 -no_prelink -o
  LINK_PREFIX = 
  LINK_FLAGS_DEBUG = $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  LINK_FLAGS_PLUGIN = $(LINK_FLAGS_SHARED)

  GENERAL_LIBS = -lpthread -lcurses -lm
  # Let GLUT be dealt with in Makefile.libscan. This makes it easier to
  # put it in SZGEXTERNAL instead of installing it.
  GRAPHICS_LIBS = -lGLU -lGL \
    -L/usr/X11R6/lib -lX11 -lXext -lXmu -lXt -lXi -lSM -lICE
  GAMEPAD_LIBS =

# The flags for library search vary based on whether or not our build style
# is EASY. If so, in addition to changing the compile-time search location,
# do not add a runtime path. Because the built-in runtime search paths will
# be unhelpful (libarPhleet.so will search for libarLanguage.so on its
# location for the developer who compiled the libraries), it is no extra
# burden to make the user set N32_LIBRARY_PATH.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(SZG_BINDIR) -Wl,-rpath,$(SZG_BINDIR)
  endif

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_MOD_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage$(SZG_STATIC_MOD)
  PHLEET_LIB_STRING = -larPhleet$(SZG_STATIC_MOD)
  BARRIER_LIB_STRING = -larBarrier$(SZG_STATIC_MOD)
  MATH_LIB_STRING = -larMath$(SZG_STATIC_MOD)
  DRIVERS_LIB_STRING = -larDrivers$(SZG_STATIC_MOD)
  GRAPHICS_LIB_STRING = -larGraphics$(SZG_STATIC_MOD)
  SOUND_LIB_STRING = -larSound$(SZG_STATIC_MOD)
  OBJECT_LIB_STRING = -larObject$(SZG_STATIC_MOD)
  INTERACT_LIB_STRING = -larInteraction$(SZG_STATIC_MOD)
  FRAMEWORK_LIB_STRING = -larFramework$(SZG_STATIC_MOD)

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = touch
endif

#*************************************************************
#                             WINDOWS
#*************************************************************

ifeq ($(strip $(MACHINE)),WIN32)
  MACHINE_DIR = win32
  # NOTE: The copy-to-bin-directory now occurs either automatically when
  # an executable (or the library) is recompiled (for each such individually).
  # It can also occur upon a manually given copy request (in which case
  # everything is rebuilt (if necessary as determined by make) then copied.
  CP = cp

# suffixes
  OBJ_SUFFIX = .obj
  DLL_SUFFIX = .dll
  LIB_SUFFIX = .lib
  PLUGIN_SUFFIX = .dll
  STATIC_SUFFIX=.lib
  EXE = .exe

# compilation
  COMPILER = cl
  COMMON_COMPILE_FLAGS = -nologo -c -w -W0 -G6 -GX -D "_MBCS" \
   -D "AR_USE_WIN_32" $(SZG_OPT_FLAGS)
# If we are using STLport (to overcome the inadequate standard c++ lib 
# that ships with Visual Studio 6), we have to let the library know we're
# using multiple threads.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    COMMON_COMPILE_FLAGS+= -D "_REENTRANT"
  endif

# The location of the precompiled header. Using this speeds up windows builds
# by a substantial margin. This is another place where we assume SZGHOME
# has been defined. NOTE: It is, indeed, possible to use precompiled
# headers with your "EASY" projects.
  ifneq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    PRECOMPILED_HEADER_USAGE = -YuarPrecompiled.h \
      -Fp$(SZGHOME)/build/win32/language/arPrecompiled.pch
  else
    PRECOMPILED_HEADER_USAGE = -YuarPrecompiled.h \
      -Fp$(SZGHOME)/build/pch/arPrecompiled.pch
  endif

# The default.
  PRECOMPILED_HEADER_FLAGS = $(PRECOMPILED_HEADER_USAGE)

# Sometimes we want to NOT have precompiled headers! (For instance, if
# we need to compile against a library built with a *slightly* different
# compiler (i.e. just a patch level away) OR if we need to compile 
# something debug while linking it with object files compiled nondebug.
  PRECOMPILED_HEADER_DISABLE = -YX

# If SZG_DEVELOPER_STYLE is EASY, then we will compile WITHOUT using
# precompiled headers.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    PRECOMPILED_HEADER_FLAGS = $(PRECOMPILED_HEADER_DISABLE)
  endif

# It is possible to over-ride the defaults by setting SZG_USE_PCH
  ifeq ($(strip $(SZG_USE_PCH)),TRUE)
    PRECOMPILED_HEADER_FLAGS = $(PRECOMPILED_HEADER_USAGE)
  else
  ifeq ($(strip $(SZG_USE_PCH)),FALSE)
    PRECOMPILED_HEADER_FLAGS = $(PRECOMPILED_HEADER_DISABLE)
  endif
  endif

# We are using the "dll" libc. This is essential vis-a-vis because of szg's
# dll-centricity. NOTE: AR_USED_SHARED must be defined to get the 
# __declspec(dllexport) that builds the export libraries.
# NOTE: Windows requires the compiler receive information about 
# linker when creating object files. Hence, the "HYBRID_FLAGS" moniker...
ifeq ($(strip $(SZG_LINKING)), STATIC) 
  HYBRID_FLAGS_DEBUG = -MTd
  HYBRID_FLAGS_NDEBUG = -MT
else
  HYBRID_FLAGS_DEBUG = -MDd -D "AR_USE_SHARED"
  HYBRID_FLAGS_NDEBUG = -MD -D "AR_USE_SHARED"
endif
  OPT_FLAGS_DEBUG = -D "_CONSOLE" -O1 -D "_DEBUG" $(HYBRID_FLAGS_DEBUG)
  OPT_FLAGS_NDEBUG = -D "_CONSOLE" -O2 -D "NDEBUG" $(HYBRID_FLAGS_NDEBUG)
# If we are using STLport, this include must come first to override the
# standard Visual C++ includes.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    OPT_FLAGS_DEBUG += -I$(SZGEXTERNAL)/win32/STLport/stlport
    OPT_FLAGS_NDEBUG += -I$(SZGEXTERNAL)/win32/STLport/stlport
  endif

# NOTE: The default set of OPT_FLAGS
  ifeq ($(strip $(SZGDEBUG)),TRUE)
    OPT_FLAGS = $(OPT_FLAGS_DEBUG)
  else
    OPT_FLAGS = $(OPT_FLAGS_NDEBUG)
  endif

# How the precompiled header is produced. This is different for "EASY"
# and "DEVELOPER" styles of packaging the code.
  ifneq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    PRECOMPILED_HEADER_LINE = $(COMPILER) $(COMMON_COMPILE_FLAGS) \
      $(OPT_FLAGS) \
      -Yc -FparPrecompiled.pch \
      ../../../src/language/arPrecompiled.cpp 
  else
    PRECOMPILED_HEADER_LINE = $(COMPILER) $(COMMON_COMPILE_FLAGS) \
      $(OPT_FLAGS) \
      -Yc -FparPrecompiled.pch pch/arPrecompiled.cpp 
  endif

# These are explicitly defined since sometimes we want something besides
# the default.
  COMPILE_FLAGS_DEBUG =  $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_DEBUG) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NDEBUG = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_NDEBUG) $(PRECOMPILED_HEADER_FLAGS)
  
# Here is the standard set of compile flags that will be used in compiling
# the objects for the library.
  COMPILE_FLAGS = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS) \
   $(PRECOMPILED_HEADER_FLAGS)

  COMPILE_FLAGS_SHARED = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS)

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O2
  else
    OPTIMIZE_FLAG = 
  endif

# The flags and other definitions pertaining to linking.
  LINKER = link
  STATIC_LINKER = LIB
  LINK_PREFIX = -out:
# There are several categories of libraries.
  GENERAL_LIBS = advapi32.lib kernel32.lib user32.lib gdi32.lib Ws2_32.lib
  # NOTE: glut is now added in Makefile.libscan, so that we can do without
  # installing it (and make use of such in SZGEXTERNAL) if such is desired.
  GRAPHICS_LIBS = opengl32.lib glu32.lib
  GAMEPAD_LIBS = dinput.lib dxguid.lib
  # We want to be able to NOT do a console-based app if necessary
  SZG_SUBSYSTEM = -subsystem:console
ifeq ($(strip $(SZG_LINKING)), STATIC) 
  SZG_NO_DEFAULT_LIB = -NODEFAULTLIB:MSVCRT.LIB -NODEFAULTLIB:MSVCRTD.LIB
  SZG_NO_DEFAULT_LIB_DEBUG = -NODEFAULTLIB:LIBCMT.LIB
  SZG_NO_DEFAULT_LIB_NDEBUG = -NODEFAULTLIB:LIBCMTD.LIB 
else
  SZG_NO_DEFAULT_LIB = -NODEFAULTLIB:LIBCMT.LIB -NODEFAULTLIB:LIBCMTD.LIB
  SZG_NO_DEFAULT_LIB_DEBUG = -NODEFAULTLIB:MSVCRT.LIB
  SZG_NO_DEFAULT_LIB_NDEBUG = -NODEFAULTLIB:MSVCRTD.LIB 
endif
  LINK_FLAGS_BASE = -nologo $(SZG_SUBSYSTEM) -incremental:no \
   $(SZG_NO_DEFAULT_LIB)
  LINK_FLAGS_SHARED_BASE = -nologo -incremental:no -dll \
   $(SZG_NO_DEFAULT_LIB)
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    LINK_FLAGS_BASE += /libpath:$(SZGEXTERNAL)/win32/STLport/lib
    LINK_FLAGS_SHARED_BASE += /libpath:$(SZGEXTERNAL)/win32/STLport/lib
  endif
  LINK_FLAGS_DEBUG = $(LINK_FLAGS_BASE) $(SZG_NO_DEFAULT_LIB_DEBUG) \
   -debug 
  LINK_FLAGS_SHARED_DEBUG = $(LINK_FLAGS_SHARED_BASE) \
   $(SZG_NO_DEFAULT_LIB_DEBUG) -debug
# The default is no debugging
  LINK_FLAGS = $(LINK_FLAGS_BASE) $(SZG_NO_DEFAULT_LIB_NDEBUG)
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_BASE) $(SZG_NO_DEFAULT_LIB_NDEBUG)
ifeq ($(strip $(SZGDEBUG)),TRUE)
  LINK_FLAGS = $(LINK_FLAGS_DEBUG)
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_DEBUG)
endif
  LINK_FLAGS_PLUGIN = $(LINK_FLAGS_SHARED)

  PRE_LINK_LINE_LIB=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_LIB=

  PRE_LINK_LINE_EXE=$(SZG_CURRENT_LIB) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_EXE =

  PRE_LINK_LINE_USR=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_USR=

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. On the Win32 side, we actually
# need to reference the libs directly. Whereas on Unix, we need to reference
# things INDIRECTLY (i.e. -larLanguage).
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LANGUAGE_LIB_STRING=$(SZGHOME)/lib/libarLanguage$(SZG_STATIC_MOD).lib
    PHLEET_LIB_STRING=$(SZGHOME)/lib/libarPhleet$(SZG_STATIC_MOD).lib
    BARRIER_LIB_STRING=$(SZGHOME)/lib/libarBarrier$(SZG_STATIC_MOD).lib
    MATH_LIB_STRING=$(SZGHOME)/lib/libarMath$(SZG_STATIC_MOD).lib
    DRIVERS_LIB_STRING=$(SZGHOME)/lib/libarDrivers$(SZG_STATIC_MOD).lib
    GRAPHICS_LIB_STRING=$(SZGHOME)/lib/libarGraphics$(SZG_STATIC_MOD).lib
    SOUND_LIB_STRING=$(SZGHOME)/lib/libarSound$(SZG_STATIC_MOD).lib
    OBJECT_LIB_STRING=$(SZGHOME)/lib/libarObject$(SZG_STATIC_MOD).lib
    INTERACT_LIB_STRING=$(SZGHOME)/lib/libarInteraction$(SZG_STATIC_MOD).lib
    FRAMEWORK_LIB_STRING=$(SZGHOME)/lib/libarFramework$(SZG_STATIC_MOD).lib
  else
    LANGUAGE_LIB_STRING=$(SZGHOME)/build/win32/language/libarLanguage$(SZG_STATIC_MOD).lib
    PHLEET_LIB_STRING=$(SZGHOME)/build/win32/phleet/libarPhleet$(SZG_STATIC_MOD).lib
    BARRIER_LIB_STRING=$(SZGHOME)/build/win32/barrier/libarBarrier$(SZG_STATIC_MOD).lib
    MATH_LIB_STRING=$(SZGHOME)/build/win32/math/libarMath$(SZG_STATIC_MOD).lib
    DRIVERS_LIB_STRING=$(SZGHOME)/build/win32/drivers/libarDrivers$(SZG_STATIC_MOD).lib
    GRAPHICS_LIB_STRING=$(SZGHOME)/build/win32/graphics/libarGraphics$(SZG_STATIC_MOD).lib
    SOUND_LIB_STRING=$(SZGHOME)/build/win32/sound/libarSound$(SZG_STATIC_MOD).lib
    OBJECT_LIB_STRING=$(SZGHOME)/build/win32/obj/libarObject$(SZG_STATIC_MOD).lib
    INTERACT_LIB_STRING=$(SZGHOME)/build/win32/interaction/libarInteraction$(SZG_STATIC_MOD).lib
    FRAMEWORK_LIB_STRING=$(SZGHOME)/build/win32/framework/libarFramework$(SZG_STATIC_MOD).lib
  endif

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = @echo
endif

#***************************************************************************
# We go ahead and scan for the libraries here... in addition to setting
# compiler flags and linker flags, as appropriate.
#
# Needs to be an absolute path since we may be calling this from a demo build
# directory.
#
# This needs to go down here (opposed to at the top) for a really lame
# reason. Specifically, MACHINE needs to be set first, and that gets done
# earlier in the file!
#***************************************************************************

include $(SZGHOME)/build/make/Makefile.libscan

#***************************************************************************
# Various miscellaneous definitions go here.
#***************************************************************************

# A few variables need to be defined for compilation and linking.
#   SZG_INCLUDE: The szg include directories.
#   SZG_LIBRARY_LIBS: The szg shared libraries to be used. Either all
#    of them (the default) or a subset of them (as might be used
#    in the intermediate makefiles).
#   SZG_OPTIONAL_LIBS: The external libraries found by the lib-scanning
#    procedure (or manually put together by the makefile from those
#    found in that process).
#   SZG_LINK_LIBS: The system libraries szg executables need. These are
#    given by $(DEVICE_LIBS) $(GRAPHICS_LIBS) $(GENERAL_LIBS).
#
# NOTE: In many of the internal makefiles, we defined things manually
# (so that fewer include directories or few libraries can be used in the
# linking). However, for demos, a standard set of includes and libraries is
# used.

# Do NOT make these definitions if we are engaged in the INTERNAL build
# process. In that case, the definitions are made in the internal makefiles.
ifneq ($(strip $(SZG_INCLUDE_STYLE)),INTERNAL)

# The "EASY" library style is provided to allow external application 
# developers to take a nicely packaged version of the headers and libraries
# as compiled for a particular platform and just run with it.
# On the other hand, if you are working on the library itself, it will be
# better to use the traditional style.
ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)

  # Bizarrely, the SZG_INCLUDE_GLUT directly below is really only useful on
  # Mac OS X to deal with the X11 includes.
  SZG_INCLUDE = -I$(SZGHOME)/include \
	$(SZG_OPT_INCLUDE_FULL) \
        $(SZG_INCLUDE_GLUT)
  
  # If we using statically linked szg libraries, then the library
  # dependencies are different.
  ifeq ($(strip $(SZG_LINKING)), STATIC) 
    LANGUAGE_DEP_STRING = \
      $(SZGHOME)/lib/libarLanguage_static$(STATIC_SUFFIX)
    PHLEET_DEP_STRING = \
      $(SZGHOME)/lib/libarPhleet_static$(STATIC_SUFFIX)
    BARRIER_DEP_STRING = \
      $(SZGHOME)/lib/libarBarrier_static$(STATIC_SUFFIX)
    MATH_DEP_STRING = \
      $(SZGHOME)/lib/libarMath_static$(STATIC_SUFFIX)
    DRIVERS_DEP_STRING = \
      $(SZGHOME)/lib/libarDrivers_static$(STATIC_SUFFIX)
    GRAPHICS_DEP_STRING = \
      $(SZGHOME)/lib/libarGraphics_static$(STATIC_SUFFIX)
    SOUND_DEP_STRING = \
      $(SZGHOME)/lib/libarSound_static$(STATIC_SUFFIX)
    OBJECT_DEP_STRING = \
      $(SZGHOME)/lib/libarObject_static$(STATIC_SUFFIX)
    INTERACT_DEP_STRING = \
      $(SZGHOME)/lib/libarInteraction_static$(STATIC_SUFFIX)
    FRAMEWORK_DEP_STRING = \
      $(SZGHOME)/lib/libarFramework_static$(STATIC_SUFFIX)
  else 
    LANGUAGE_DEP_STRING = \
      $(SZGHOME)/bin/libarLanguage$(DLL_SUFFIX)
    PHLEET_DEP_STRING = \
      $(SZGHOME)/bin/libarPhleet$(DLL_SUFFIX)
    BARRIER_DEP_STRING = \
      $(SZGHOME)/bin/libarBarrier$(DLL_SUFFIX)
    MATH_DEP_STRING = \
      $(SZGHOME)/bin/libarMath$(DLL_SUFFIX)
    DRIVERS_DEP_STRING = \
      $(SZGHOME)/bin/libarDrivers$(DLL_SUFFIX)
    GRAPHICS_DEP_STRING = \
      $(SZGHOME)/bin/libarGraphics$(DLL_SUFFIX)
    SOUND_DEP_STRING = \
      $(SZGHOME)/bin/libarSound$(DLL_SUFFIX)
    OBJECT_DEP_STRING = \
      $(SZGHOME)/bin/libarObject$(DLL_SUFFIX)
    INTERACT_DEP_STRING = \
      $(SZGHOME)/bin/libarInteraction$(DLL_SUFFIX)
    FRAMEWORK_DEP_STRING = \
      $(SZGHOME)/bin/libarFramework$(DLL_SUFFIX)
  endif

else

# Bizarrely, the SZG_INCLUDE_GLUT below is really only necessary for the
# X11 headers on Mac OS X.
SZG_INCLUDE = \
	-I$(SZGHOME)/src/language \
        -I$(SZGHOME)/src/math \
        -I$(SZGHOME)/src/phleet \
	-I$(SZGHOME)/src/barrier \
	-I$(SZGHOME)/src/drivers \
	-I$(SZGHOME)/src/graphics \
	-I$(SZGHOME)/src/obj \
	-I$(SZGHOME)/src/sound \
	-I$(SZGHOME)/src/interaction \
	-I$(SZGHOME)/src/framework \
        $(SZG_OPT_INCLUDE_FULL) \
        $(SZG_INCLUDE_GLUT)

  # If we using statically linked szg libraries, then the library
  # dependencies are different.
  ifeq ($(strip $(SZG_LINKING)), STATIC) 
    LANGUAGE_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/language/libarLanguage_static$(STATIC_SUFFIX)
    PHLEET_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/phleet/libarPhleet_static$(STATIC_SUFFIX)
    BARRIER_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/barrier/libarBarrier_static$(STATIC_SUFFIX)
    MATH_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/math/libarMath_static$(STATIC_SUFFIX)
    DRIVERS_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/drivers/libarDrivers_static$(STATIC_SUFFIX)
    GRAPHICS_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/graphics/libarGraphics_static$(STATIC_SUFFIX)
    SOUND_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/sound/libarSound_static$(STATIC_SUFFIX)
    OBJECT_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/obj/libarObject_static$(STATIC_SUFFIX)
    INTERACT_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/interaction/libarInteraction_static$(STATIC_SUFFIX)
    FRAMEWORK_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/framework/libarFramework_static$(STATIC_SUFFIX)
  else
    LANGUAGE_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/language/libarLanguage$(DLL_SUFFIX)
    PHLEET_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/phleet/libarPhleet$(DLL_SUFFIX)
    BARRIER_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/barrier/libarBarrier$(DLL_SUFFIX)
    MATH_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/math/libarMath$(DLL_SUFFIX)
    DRIVERS_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/drivers/libarDrivers$(DLL_SUFFIX)
    GRAPHICS_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/graphics/libarGraphics$(DLL_SUFFIX)
    SOUND_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/sound/libarSound$(DLL_SUFFIX)
    OBJECT_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/obj/libarObject$(DLL_SUFFIX)
    INTERACT_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/interaction/libarInteraction$(DLL_SUFFIX)
    FRAMEWORK_DEP_STRING = \
      $(SZGHOME)/build/$(MACHINE_DIR)/framework/libarFramework$(DLL_SUFFIX)
  endif

endif # end of the check to see if we are using the "EASY" build style

# These variables must be set (either for "EASY" or "DEVELOPER" build styles)
# assuming we are compiling from outside of the szg internal Makefiles...
# Note that we list libraries from highest level to lowest level. This reflects
# the static linking style demanded by Unix.

# DO NOT use := HERE. The strings can change because of a variable that will
# be set LATER (SZG_STATIC_MOD).
SZG_LIBRARY_LIBS = \
	$(FRAMEWORK_LIB_STRING) \
	$(INTERACT_LIB_STRING) \
	$(OBJECT_LIB_STRING) \
	$(SOUND_LIB_STRING) \
	$(GRAPHICS_LIB_STRING) \
	$(DRIVERS_LIB_STRING) \
	$(MATH_LIB_STRING) \
	$(BARRIER_LIB_STRING) \
	$(PHLEET_LIB_STRING) \
	$(LANGUAGE_LIB_STRING)

# The dependencies might be different from the libs. For instance, on
# Unix platforms, we DO NOT want to have absolute paths to the shared
# libraries, but our dependencies for the make MUST have absolute paths.
# On Windows, the situation is easier since we link with .lib files, which 
# are NOT the files that the executable runtime links with.

# DO NOT use := HERE. The strings can change because of a variable that will
# be set LATER (SZG_STATIC_MOD)
SZG_LIBRARY_DEPS = \
	$(LANGUAGE_DEP_STRING) \
        $(PHLEET_DEP_STRING) \
        $(BARRIER_DEP_STRING) \
        $(MATH_DEP_STRING) \
        $(DRIVERS_DEP_STRING) \
        $(GRAPHICS_DEP_STRING) \
	$(SOUND_DEP_STRING) \
        $(OBJECT_DEP_STRING) \
        $(INTERACT_DEP_STRING) \
        $(FRAMEWORK_DEP_STRING)

SZG_CURRENT_LIB_SHORT_NAME =
# This seems just a little bit redundant, having SZG_OPTIONAL_LIBS
# set by SZG_OPT_LIBS_FULL, but it actually makes sense. Makefile.libscan
# sets SZG_OPT_LIBS_FULL (the list of everything that comes from SZGEXTERNAL).
# However, individual Makefiles, like Makefile.obj, might set SZG_OPTIONAL_LIBS
# using just selected optional variables, like SZG_LINK_3DS.
# Consequently, SZG_OPTIONAL_LIBS has a different usage than SZG_OPT_LIBS_FULL.
SZG_OPTIONAL_LIBS = $(SZG_OPT_LIBS_FULL)
SZG_LINK_LIBS = $(GRAPHICS_LIBS) $(GENERAL_LIBS)

endif # end of the check to see if we are using the "internal" include style

# VPATH is defined in each Makefile.whatever file. SRCDIR is used in the
# *clean* option (allowing us to get rid of certain editor files)
SRCDIR=$(VPATH)

# Sets INSTALLDIR and SZG_BINDIR.
include $(SZGHOME)/build/make/Makefile.globals

# An individual project might want to use external libraries. When installing
# the resulting executables, we should install these shared libraries 
# in the same spot. These variables let us do that in a standard way.
# Please note that the Makefile fragments assume that SZG_SHARED_COPY_LOCAL
# will be non-empty. Consequently, a small placeholder file always gets
# copied.
SZG_SHARED_COPY_LOCAL = $(SZGHOME)/build/make/blessing.txt
SZG_SHARED_COPY_ACTION_LOCAL =

# Variables relevent to the link commands. The libraries are treated
# differently in case of static linking than they are for dynamic linking.
# The different base names (libarLangage.* vs. libarLanguage_static.*)
# are necessary to disambiguate on the Windows side between the dll's export
# library and the code-bearing static library. 
ifeq ($(strip $(SZG_LINKING)), STATIC) 
  SZG_STATIC_MOD=_static
  SZG_CURRENT_LIB_MOD_NAME = $(SZG_CURRENT_LIB_SHORT_NAME)$(SZG_STATIC_MOD)
  SZG_CURRENT_LIB_NAME = lib$(SZG_CURRENT_LIB_MOD_NAME)
  SZG_CURRENT_LIB = $(SZG_CURRENT_LIB_NAME)$(LIB_SUFFIX)
  SZG_CURRENT_DLL = $(SZG_CURRENT_LIB_NAME)$(STATIC_SUFFIX)
else
  SZG_STATIC_MOD=
  SZG_CURRENT_LIB_MOD_NAME=$(SZG_CURRENT_LIB_SHORT_NAME)
  SZG_CURRENT_LIB_NAME = lib$(SZG_CURRENT_LIB_SHORT_NAME)
  SZG_CURRENT_LIB = $(SZG_CURRENT_LIB_NAME)$(LIB_SUFFIX)
  SZG_CURRENT_DLL = $(SZG_CURRENT_LIB_NAME)$(DLL_SUFFIX)
endif

# On Win32, for our "create-install", it is necessary to put our .lib file
# in a special "lib" directory. This is because Visual Studio makes a 
# distinction between what you compile against and what you link with.
ifeq ($(strip $(MACHINE)),WIN32)
  # Only some projects produce a library that needs to be copied into the
  # install's lib directory.
  ifeq ($(strip $(SZG_COPY_LIB)),TRUE)
    SZG_LIB_COPY_LINE = $(CP) $(SZG_CURRENT_LIB) $(INSTALLDIR)/lib
  endif
endif

# Copy the stuff into the bin directory. We can't use SZGBIN since that isn't
# required to be defined. If just SZGHOME is defined, then a directory based
# on that will be the SZG_BINDIR.
COPY = $(CP) $@ $(SZG_BINDIR)

# For linking the exe's that are built with the library. Here we are dealing
# with the issue that: windows and unix put libraries at DIFFERENT places in
# the link line.
SZG_EXE_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_EXE_SECOND = $(POST_LINK_LINE_EXE)
SZG_USR_FIRST = $(LINKER) $(PRE_LINK_LINE_USR) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_USR_SECOND = $(POST_LINK_LINE_USR)

ifeq ($(strip $(SZG_LINKING)), STATIC) 
  # Used for creating *static* libraries.
  LINK_SZG_LIB = $(STATIC_LINKER) $(LINK_PREFIX)$(SZG_CURRENT_DLL) $(OBJS)
else
  # Used for linking the shared syzygy libraries. 
  # NOTE: we have to go through some special contortions to deal with the 
  # different library placement in the link line on Windows and Unix.
  LINK_SZG_LIB = $(LINKER) $(PRE_LINK_LINE_LIB) $(LINK_FLAGS_SHARED) \
     $(LINK_PREFIX)$(SZG_CURRENT_DLL) $(OBJS) $(POST_LINK_LINE_LIB)
endif

# Useful for linking Syzygy loadable shared objects.
SZG_PLUGIN_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS_PLUGIN) \
$(LINK_PREFIX)$@

