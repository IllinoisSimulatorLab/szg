#**************************************************************
# This file sets compiler flag definitions based on MACHINE
# (as determined by Makefile.os) and further modifies these
# based on Makefile.libscan, which figures out which optional
# libraries have been installed.
#**************************************************************

#**************************************************************
# The environment variables that affect the build are:
#  SZGHOME: REQUIRED. The top-level directory of the szg.
#  SZGBIN: Optional. If defined, this is where the executables
#          and shared libraries are placed. Otherwise, they
#          are placed in $(SZGHOME)/bin/$(MACHINE_DIR)
#  SZGDEBUG: Optional. If defined and equal to TRUE, the
#            library and executables are built debug.
#  SZG_DEVELOPER_STYLE: Optional. If defined and equal to EASY,
#                       a special build process is used for
#                       external executables (which is suited
#                       to using prebuilt libraries).
#  SZGEXTERNAL: Optional. This is where external libraries get
#               placed (in a defined directory structure) if
#               they are to be used by the library. However,
#               if SZG_DEVELOPER_STYLE=EASY, then SZGEXTERNAL
#               is *ignored* and the build process searches 
#               for the external libraries in 
#               $(SZGHOME)/external.
#**************************************************************



#**************************************************************
#                             LINUX
#**************************************************************

ifeq ($(strip $(MACHINE)),LINUX)
  MACHINE_DIR = linux
  # NOTE: Each time an executable or shared library gets built, it is
  # automatically copied. Do NOT use "cp -u" here (the only-copy-for-update
  # is vulnerable to clock misalignment (i.e. "why isn't my new executable
  # running?")
  CP = cp

# The suffixes unique to the platform.
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE = 

# General info regarding compiling such as flags for the various build styles.
  COMPILER = g++
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS := -DAR_USE_LINUX -c -O2 -Wall -W -Wpointer-arith -march=i686
  else
    COMPILE_FLAGS := -DAR_USE_LINUX -c -g -Wall -W -Wpointer-arith -march=i686 
  endif
  COMPILE_FLAGS_SHARED := $(COMPILE_FLAGS)
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS)
  ifneq ($(strip $(SZGDEBUG)),NORMAL)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# This covers up the fact that precompiled headers are not needed on the
# Unix side.  
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

# General settings regarding linking, such as flags and libraries.
  LINKER = g++
  LINK_PREFIX = 
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  GENERAL_LIBS = -ldl -lpthread -lm
  GRAPHICS_LIBS = -lglut -lGLU -lGL -L/usr/X11R6/lib -lX11 -lXext -lXmu \
    -lXt -lXi -lSM -lICE
  DEVICE_LIBS =

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= -L$(BINDIR) -Wl,-rpath,$(BINDIR) \
    -l$(SZG_CURRENT_LIB_SHORT_NAME) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  RANLIB = touch
endif

#*************************************************************
#                             OS X
#*************************************************************

ifeq ($(strip $(MACHINE)),DARWIN)
  MACHINE_DIR = darwin
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE =

# compilation
  COMPILER = c++
  COMPILE_FLAGS := -DAR_BIG_ENDIAN -DAR_USE_DARWIN \
    -fno-common -c \
    #-g -O2
  COMPILE_FLAGS_SHARED:=$(COMPILE_FLAGS)
  PRECOMPILED_HEADER_LOCATION_NORMAL := 
  PRECOMPILED_HEADER_LOCATION_DEMO := 
  PRECOMPILED_HEADER_LOCATION_ABSOLUTE := 
  PRECOMPILED_HEADER_LOCATION := 
  PRECOMPILED_HEADER_DISABLE :=
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS)
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  INC_GL = -I./
  OPTIMIZE_FLAG = -O3
  
# linking
  LINKER = c++
  LINK_PREFIX =
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -bundle -flat_namespace -undefined suppress -o
  GL_LIBS = -framework OpenGL -framework GLUT \
	-framework COCOA
  MATH_LIB = -lm
  GRAPHICS_LIBS = $(GL_LIBS) $(X_LIBS)
  JOYSTICK_LIBS =
  TRACKER_LIBS =
  GENERAL_LIBS = $(MATH_LIB) $(SZGHOME)/contrib/dlcompat-20020709/libdl.a \
    -lpthread -lcurses -lobjc $(JOYSTICK_LIBS)
  LIBS = $(GENERAL_LIBS) $(GRAPHICS_LIBS)
  X_LIBS =
# creating executables
  RANLIB = ranlib
endif

#*************************************************************
#                             SGI
#*************************************************************


# Handle mips3/mips4 architecture on SGI.
ifeq ($(strip $(MACHINE)),MIPS3)
  MACHINE_DIR = mips3
  MACHINE = SGI
endif
ifeq ($(strip $(MACHINE)),MIPS4)
  MACHINE_DIR = mips4
  MACHINE = SGI
endif

ifeq ($(strip $(MACHINE)),SGI)
# which compiler are we going to use?
USE_SGI_COMPILER = CC
ifeq ($(strip $(USE_SGI_COMPILER)),g++)
  COMPILER = g++
  COMPILE_FLAGS := -DAR_USE_SGI -D_REENTRANT -D_SGI_MP_SOURCE -D_POSIX1C=1 -D_NO_ANSIMODE -c
  LINKER = g++
  LINK_FLAGS := -o
else
  COMPILER = CC
  COMPILE_FLAGS := -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE -DAR_USE_SGI -LANG:std -n32 \
-ptused -c
  LINKER = CC
  LINK_FLAGS := -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE -LANG:std -n32 -no_prelink -o
endif
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE = 

# compilation
  PRECOMPILED_HEADER_LOCATION_NORMAL := 
  PRECOMPILED_HEADER_LOCATION_DEMO := 
  PRECOMPILED_HEADER_LOCATION_ABSOLUTE := 
  PRECOMPILED_HEADER_LOCATION := 
  PRECOMPILED_HEADER_DISABLE :=
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS) 
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  INC_GL = -I/usr/local/isl/SGI/glut
  OPTIMIZE_FLAG = -O3

# linking
  LINK_PREFIX = 
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  GL_LIBS = -L/usr/local/isl/SGI/glut -lglut -lGLU -lGL 
  X_LIBS = -L/usr/X11R6/lib -lX11 -lXext -lXmu -lXt -lXi -lSM -lICE
  MATH_LIB = -lm
  GENERAL_LIBS = -lpthread -lcurses $(MATH_LIB)
  GRAPHICS_LIBS = $(GL_LIBS) $(X_LIBS)
  JOYSTICK_LIBS =
  TRACKER_LIBS = /usr/local/CAVE/trackd/TRACKD_API/lib/libtrackdAPI_n32.a
  LIBS = $(GRAPHICS_LIBS) $(GENERAL_LIBS)
  RANLIB = touch
#creating executables
endif

#*************************************************************
#                             WINDOWS
#*************************************************************

ifeq ($(strip $(MACHINE)),WIN32)
  MACHINE_DIR = win32
  # NOTE: The copy-to-bin-directory now occurs either automatically when
  # an executable (or the library) is recompiled (for each such individually).
  # It can also occur upon a manually given copy request (in which case
  # everything is rebuilt (if necessary as determined by make) then copied.
  CP = cp

# suffixes
  OBJ_SUFFIX = .obj
  DLL_SUFFIX = .dll
  LIB_SUFFIX = .lib
  EXE = .exe

# compilation
  COMPILER = cl
  COMMON_COMPILE_FLAGS = -nologo -c -w -W0 -G6 -GX -D "_MBCS" \
   -D "AR_USE_WIN_32"

# Depending upon where we are building the exe, we need a different path
# to the precompiled header. NORMAL is for the library, DEMO is for the
# base demos. ABSOLUTE is for szgdemo. HMMMM... WHY NOT JUST GO AHEAD
# AND JUST USE PRECOMPILED_HEADER_LOCATION_ABSOLUTE? IT'S ASSUMED THAT
# SZGHOME WILL BE DEFINED ANYWAY...
  PRECOMPILED_HEADER_LOCATION_NORMAL = ../language/arPrecompiled.pch
  PRECOMPILED_HEADER_LOCATION_DEMO = ../../language/arPrecompiled.pch
  PRECOMPILED_HEADER_LOCATION_ABSOLUTE = \
    $(SZGHOME)/build/win32/language/arPrecompiled.pch
# the default location is for the library
  PRECOMPILED_HEADER_LOCATION = $(PRECOMPILED_HEADER_LOCATION_NORMAL)
  PRECOMPILED_HEADER_FLAGS = -YuarPrecompiled.h -Fp$(PRECOMPILED_HEADER_LOCATION)

# Sometimes we want to NOT have precompiled headers!
  PRECOMPILED_HEADER_DISABLE = -YX

#***********************************************************
# EXPERIMENT EXPERIMENT EXPERIMENT EXPERIMENT EXPERIMENT
#
# Trying to see if using the dll libc will work or not
#***********************************************************
  OPT_FLAGS_DEBUG_NONSHARED = -D "_CONSOLE" -MDd -O1 -D "_DEBUG"
  OPT_FLAGS_NDEBUG_NONSHARED = -D "_CONSOLE" -MD -O2 -D "NDEBUG"
  OPT_FLAGS_DEBUG = $(OPT_FLAGS_DEBUG_NONSHARED) -D "AR_USE_SHARED"
  OPT_FLAGS_NDEBUG = $(OPT_FLAGS_NDEBUG_NONSHARED) -D "AR_USE_SHARED"
# NOTE: We must be consistent through out in how we link groups of 
# objects together. These flags are used for the PySZG dll.
  OPT_FLAGS_SHARED = -MD -O2 -D "NDEBUG"
#  OPT_FLAGS_SHARED = -D "_USRDLL" -MT -O2 -D "NDEBUG"
ifeq ($(strip $(SZGDEBUG)),TRUE)
  OPT_FLAGS = $(OPT_FLAGS_DEBUG)
  OPT_FLAGS_NONSHARED = $(OPT_FLAGS_DEBUG_NONSHARED)
else
  OPT_FLAGS = $(OPT_FLAGS_NDEBUG)
  OPT_FLAGS_NONSHARED = $(OPT_FLAGS_NDEBUG_NONSHARED)
endif

# Sometimes we must compile an application in debug or normal mode,
# regardless of the way the whole library is compiled!
# Some compile flags are for *shared* objects (such as will go into the
# dlls) and some are for *nonshared* objects (such as for executables).
# Essentially the only difference is adding a definition (defined in
# arCallingConventions.h) that makes the windows link build a .lib file.
# We only want objects going into the dlls to build a .lib file
# and NOT objects going into the various executables, which, while not harming
# anything, produces and annoying number of useless .lib and .exp files
# (for each executable so built)

  COMPILE_FLAGS_DEBUG_NONSHARED = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_DEBUG_NONSHARED) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NORMAL_NONSHARED = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_NDEBUG_NONSHARED) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_DEBUG =  $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_DEBUG) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NDEBUG = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_NDEBUG) $(PRECOMPILED_HEADER_FLAGS)
  
# Here is the standard set of compile flags that will be used in compiling
# the objects for the library.
  COMPILE_FLAGS = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS) \
   $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NONSHARED = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS_NONSHARED) \
   $(PRECOMPILED_HEADER_FLAGS)



#######################################################################
# EXPERIMENT EXPERIMENT EXPERIMENT EXPERIMENT EXPERIMENT EXPERIMENT
#
# Trying to change things to see if dll's will work!
#######################################################################

  COMPILE_FLAGS_SHARED = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS_SHARED)

  PRECOMPILED_HEADER_LINE = $(COMPILER) $(COMMON_COMPILE_FLAGS) \
    $(OPT_FLAGS) \
    -Yc -FparPrecompiled.pch \
    ../../../src/language/arPrecompiled.cpp

  INC_GL = -I./
  OPTIMIZE_FLAG = -O2

# linking
  LINKER = link
  LINK_PREFIX = -out:
# NOTE: We used to put the joystick-related windows libs in
# the JOYSTICK_LIBS instead of LINK_LIBS variable. BUT... it seems
# that the linker will sometimes produce WEIRD errors (LNK1000) if this
# is true (very machine dependant).
# ALSO: we need to (in Makefile.libscan) add to LINK_LIBS instead of LIBS.
# This is because of the funny order in which Visual C++ puts libs on the
# link line. Consequently, the LINK_FLAGS* variables MUST NOT have := but
# instead = (LINK_LIBS will be changing later)

# There are several categories of libraries.
# 
  GENERAL_LIBS = advapi32.lib kernel32.lib user32.lib gdi32.lib Ws2_32.lib
  GRAPHICS_LIBS = opengl32.lib glu32.lib glut32.lib
  DEVICE_LIBS = dinput.lib dxguid.lib
  LINK_FLAGS_BASE = -nologo -subsystem:console -incremental:no
  LINK_FLAGS_DEBUG = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMT.LIB -debug 
  LINK_FLAGS_SHARED_BASE = -nologo -incremental:no -dll
  LINK_FLAGS_SHARED_DEBUG = $(LINK_FLAGS_SHARED_BASE) -NODEFAULTLIB:LIBCMT.LIB -debug
# The default for no debugging
  LINK_FLAGS = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMTD
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_BASE) -NODEFAULTLIB:LIBCMTD
ifeq ($(strip $(SZGDEBUG)),TRUE)
  LINK_FLAGS = $(LINK_FLAGS_DEBUG)
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_DEBUG)
endif

  PRE_LINK_LINE_LIB=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_LIB=

  PRE_LINK_LINE_EXE=$(SZG_CURRENT_LIB) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_EXE =

# It is only necessary to run the created library through ranlib on the
# darwin side, not any other spot.
  RANLIB = @echo
endif

#***************************************************************************
# We go ahead and scan for the libraries here... in addition to setting
# compiler flags and linker flags, as appropriate.
#
# Needs to be an absolute path since we may be calling this from a demo build
# directory.
#***************************************************************************

include $(SZGHOME)/build/make/Makefile.libscan

#***************************************************************************
# Various miscellaneous definitions go here.
#***************************************************************************

# A few variables need to be defined for compilation and linking.
#   SZG_INCLUDE: The szg include directories.
#   SZG_LIBRARY_LIBS: The szg shared libraries to be used. Either all
#    of them (the default) or a subset of them (as might be used
#    in the intermediate makefiles).
#   SZG_OPTIONAL_LIBS: The external libraries found by the lib-scanning
#    procedure (or manually put together by the makefile from those
#    found in that process).
#   SZG_LINK_LIBS: The system libraries szg executables need. These are
#    given by $(DEVICE_LIBS) $(GRAPHICS_LIBS) $(GENERAL_LIBS).
#
# NOTE: In many of the internal makefiles, we defined things manually
# (so that fewer include directories or few libraries can be used in the
# linking). However, for demos, a standard set of includes and libraries is
# used.

# Do NOT make these definitions if we are engaged in the INTERNAL build
# process. In that case, the definitions are made in the internal makefiles.
ifneq ($(strip $(SZG_INCLUDE_STYLE)),INTERNAL)

# The "EASY" library style is provided to allow external application 
# developers to take a nicely packaged version of the headers and libraries
# as compiled for a particular platform and just run with it.
# On the other hand, if you are working on the library itself, it will be
# better to use the traditional style.
ifeq ($(strip $(SZG_LIBRARY_STYLE)),EASY)

SZG_INCLUDE := -I$(SZGHOME)/include
# BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
# This will certainly have to change...
# As a general note, part of the "create-install" process should involve
# drawing the relevant stuff from SZGEXTERNAL into the install image.
# (i.e. there will be a little copy of SZGEXTERNAL in there, which will be
#  used preferentially if SZG_BUILD_STYLE is set to EASY)
# Also, we want to be able to pull stuff from SZGEXTERNAL (the dll's)
# and put them into the binary directory automatically (for a development
# thing even, it's a good idea to put all dll's into a local copy)
SZG_LIBS := $(SZGHOME)/lib/libszg.a

else

SZG_INCLUDE := \
	-I$(SZGHOME)/src/language \
        -I$(SZGHOME)/src/math \
        -I$(SZGHOME)/src/phleet \
	-I$(SZGHOME)/src/barrier \
	-I$(SZGHOME)/src/drivers \
	-I$(SZGHOME)/src/graphics \
	-I$(SZGHOME)/src/obj \
	-I$(SZGHOME)/src/sound \
	-I$(SZGHOME)/src/interaction \
	-I$(SZGHOME)/src/demo \
	$(SZG_DLL_INCLUDE)

# BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
# These names will have to change...
SZG_LIBS := \
	$(BINDIR)/libarFramework$(DLL_SUFFIX) \
        $(BINDIR)/libarInteract$(DLL_SUFFIX) \
        $(BINDIR)/libarSound$(DLL_SUFFIX) \
        $(BINDIR)/libarObjects$(DLL_SUFFIX) \
        $(BINDIR)/libarGraphics$(DLL_SUFFIX) \
        $(BINSIR)/libarDrivers$(DLL_SUFFIX) \
	$(BINDIR)/libarMath$(DLL_SUFFIX) \
        $(BINDIR)/libarBarrier$(DLL_SUFFIX) \
        $(BINDIR)/libarPhleet$(DLL_SUFFIX) \
        $(BINDIR)/libarLanguage$(DLL_SUFFIX)

endif # end of the check to see if we are using the "EASY" build style

endif # end of the check to see if we are using the "internal" include style

# VPATH is defined in each Makefile.whatever file. SRDCIR is used in the
# *clean* option (allowing us to get rid of certain editor files)
SRCDIR=$(VPATH)

# If the SZGBIN environment variable is set, go ahead and use that. 
# Otherwise, use a standard directory based on SZGHOME.
ifeq ($(strip $(SZGBIN)),)
  BINDIR=$(SZGHOME)/bin/$(strip $(MACHINE_DIR))
else
  BINDIR=$(SZGBIN)
endif

# Link-related commands.
# Variables relevent to the link commands.
SZG_CURRENT_LIB_NAME = lib$(SZG_CURRENT_LIB_SHORT_NAME)
SZG_CURRENT_LIB = $(SZG_CURRENT_LIB_NAME)$(LIB_SUFFIX)
SZG_CURRENT_DLL = $(SZG_CURRENT_LIB_NAME)$(DLL_SUFFIX)

# Copy the stuff into the bin directory. We can't use SZGBIN since that isn't
# required to be defined. If just SZGHOME is defined, then a directory based
# on that will be the BINDIR.
COPY = $(CP) $@ $(BINDIR)

# For linking the exe's that are built with the library. Here we are dealing
# with the issue that: windows and unix put libraries at DIFFERENT places in
# the link line.
SZG_EXE_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_EXE_SECOND = $(POST_LINK_LINE_EXE)

# Used for linking the syzygy libraries. NOTE: we have to go through some
# special contortions to deal with the different library placement in the
# link line on Windows and Unix.
LINK_SZG_LIB = $(LINKER) $(PRE_LINK_LINE_LIB) $(LINK_FLAGS_SHARED) \
   $(LINK_PREFIX)$(SZG_CURRENT_DLL) $(OBJS) $(POST_LINK_LINE_LIB)

