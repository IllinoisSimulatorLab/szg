#**************************************************************
# This file sets compiler flag definitions based on MACHINE
# (as determined by Makefile.os) and further modifies these
# based on Makefile.libscan, which figures out which optional
# libraries have been installed.
#**************************************************************

#**************************************************************
# The environment variables that affect the build are:
#  SZGHOME: REQUIRED. The top-level directory of the szg.
#  SZGBIN: Optional. If defined, this is where the executables
#          and shared libraries are placed. Otherwise, they
#          are placed in $(SZGHOME)/bin/$(MACHINE_DIR)
#  SZGDEBUG: Optional. If defined and equal to TRUE, the
#            library and executables are built debug.
#  SZG_DEVELOPER_STYLE: Optional. If defined and equal to EASY,
#                       a special build process is used for
#                       external executables (which is suited
#                       to using prebuilt libraries).
#  SZGEXTERNAL: Optional. This is where external libraries get
#               placed (in a defined directory structure) if
#               they are to be used by the library. However,
#               if SZG_DEVELOPER_STYLE=EASY, then SZGEXTERNAL
#               is *ignored* and the build process searches 
#               for the external libraries in 
#               $(SZGHOME)/external.
#  SZG_STLPORT: Optional. This is only respected on the windows
#               side. Present since Visual Studio 6 did not 
#               have a good enough implementation of the STL
#               to use with our dll approach in szg-0.7 and 
#               later. If this is set to TRUE, a *windows* 
#               build will attempt to use STLport as the
#               c++ standard lib.
#**************************************************************

#**************************************************************
#                             LINUX
#**************************************************************

ifeq ($(strip $(MACHINE)),LINUX)
  MACHINE_DIR = linux
  # NOTE: Each time an executable or shared library gets built, it is
  # automatically copied. Do NOT use "cp -u" here (the only-copy-for-update
  # is vulnerable to clock misalignment (i.e. "why isn't my new executable
  # running?")
  CP = cp

# The suffixes unique to the platform.
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE = 

# General info regarding compiling such as flags for the various build styles.
  COMPILER = g++
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS := -DAR_USE_LINUX -c -O2 -Wall -W -Wpointer-arith -march=i686
  else
    COMPILE_FLAGS := -DAR_USE_LINUX -c -g -Wall -W -Wpointer-arith -march=i686 
  endif
  COMPILE_FLAGS_SHARED := $(COMPILE_FLAGS)
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS)
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# This covers up the fact that precompiled headers are not needed on the
# Unix side.  
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

# General settings regarding linking, such as flags and libraries.
  LINKER = g++
  LINK_PREFIX = 
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  GENERAL_LIBS = -ldl -lpthread -lm
  GRAPHICS_LIBS = -lglut -lGLU -lGL -L/usr/X11R6/lib -lX11 -lXext -lXmu \
    -lXt -lXi -lSM -lICE
  GAMEPAD_LIBS =

  LIB_SEARCH_FLAGS=-L$(BINDIR) -Wl,-rpath,$(BINDIR)

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_SHORT_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage
  PHLEET_LIB_STRING = -larPhleet
  BARRIER_LIB_STRING = -larBarrier
  MATH_LIB_STRING = -larMath
  DRIVERS_LIB_STRING = -larDrivers
  GRAPHICS_LIB_STRING = -larGraphics
  SOUND_LIB_STRING = -larSound
  OBJECT_LIB_STRING = -larObject
  INTERACT_LIB_STRING = -larInteraction
  FRAMEWORK_LIB_STRING = -larFramework

  RANLIB = touch
endif

#*************************************************************
#                             OS X
#*************************************************************

ifeq ($(strip $(MACHINE)),DARWIN)
  MACHINE_DIR = darwin
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE =

# compilation
  COMPILER = c++
  COMPILE_FLAGS := -DAR_BIG_ENDIAN -DAR_USE_DARWIN \
    -fno-common -c \
    #-g -O2
  COMPILE_FLAGS_SHARED:=$(COMPILE_FLAGS)
  PRECOMPILED_HEADER_LOCATION_NORMAL := 
  PRECOMPILED_HEADER_LOCATION_DEMO := 
  PRECOMPILED_HEADER_LOCATION_ABSOLUTE := 
  PRECOMPILED_HEADER_LOCATION := 
  PRECOMPILED_HEADER_DISABLE :=
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS)
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  INC_GL = -I./
  OPTIMIZE_FLAG = -O3
  
# linking
  LINKER = c++
  LINK_PREFIX =
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -bundle -flat_namespace -undefined suppress -o
  GL_LIBS = -framework OpenGL -framework GLUT \
	-framework COCOA
  MATH_LIB = -lm
  GRAPHICS_LIBS = $(GL_LIBS) $(X_LIBS)
  JOYSTICK_LIBS =
  TRACKER_LIBS =
  GENERAL_LIBS = $(MATH_LIB) $(SZGHOME)/contrib/dlcompat-20020709/libdl.a \
    -lpthread -lcurses -lobjc $(JOYSTICK_LIBS)
  LIBS = $(GENERAL_LIBS) $(GRAPHICS_LIBS)
  X_LIBS =
# creating executables
  RANLIB = ranlib
endif

#*************************************************************
#                             SGI
#*************************************************************


# Handle mips3/mips4 architecture on SGI.
ifeq ($(strip $(MACHINE)),MIPS3)
  MACHINE_DIR = mips3
  MACHINE = SGI
endif
ifeq ($(strip $(MACHINE)),MIPS4)
  MACHINE_DIR = mips4
  MACHINE = SGI
endif

ifeq ($(strip $(MACHINE)),SGI)
# which compiler are we going to use?
USE_SGI_COMPILER = CC
ifeq ($(strip $(USE_SGI_COMPILER)),g++)
  COMPILER = g++
  COMPILE_FLAGS := -DAR_USE_SGI -D_REENTRANT -D_SGI_MP_SOURCE -D_POSIX1C=1 -D_NO_ANSIMODE -c
  LINKER = g++
  LINK_FLAGS := -o
else
  COMPILER = CC
  COMPILE_FLAGS := -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE -DAR_USE_SGI -LANG:std -n32 \
-ptused -c
  LINKER = CC
  LINK_FLAGS := -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE -LANG:std -n32 -no_prelink -o
endif
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  EXE = 

# compilation
  PRECOMPILED_HEADER_LOCATION_NORMAL := 
  PRECOMPILED_HEADER_LOCATION_DEMO := 
  PRECOMPILED_HEADER_LOCATION_ABSOLUTE := 
  PRECOMPILED_HEADER_LOCATION := 
  PRECOMPILED_HEADER_DISABLE :=
  COMPILE_FLAGS_DEBUG := $(COMPILE_FLAGS)
  COMPILE_FLAGS_NORMAL := $(COMPILE_FLAGS) 
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  INC_GL = -I/usr/local/isl/SGI/glut
  OPTIMIZE_FLAG = -O3

# linking
  LINK_PREFIX = 
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  GL_LIBS = -L/usr/local/isl/SGI/glut -lglut -lGLU -lGL 
  X_LIBS = -L/usr/X11R6/lib -lX11 -lXext -lXmu -lXt -lXi -lSM -lICE
  MATH_LIB = -lm
  GENERAL_LIBS = -lpthread -lcurses $(MATH_LIB)
  GRAPHICS_LIBS = $(GL_LIBS) $(X_LIBS)
  JOYSTICK_LIBS =
  TRACKER_LIBS = /usr/local/CAVE/trackd/TRACKD_API/lib/libtrackdAPI_n32.a
  LIBS = $(GRAPHICS_LIBS) $(GENERAL_LIBS)
  RANLIB = touch
#creating executables
endif

#*************************************************************
#                             WINDOWS
#*************************************************************

ifeq ($(strip $(MACHINE)),WIN32)
  MACHINE_DIR = win32
  # NOTE: The copy-to-bin-directory now occurs either automatically when
  # an executable (or the library) is recompiled (for each such individually).
  # It can also occur upon a manually given copy request (in which case
  # everything is rebuilt (if necessary as determined by make) then copied.
  CP = cp

# suffixes
  OBJ_SUFFIX = .obj
  DLL_SUFFIX = .dll
  LIB_SUFFIX = .lib
  EXE = .exe

# compilation
  COMPILER = cl
  COMMON_COMPILE_FLAGS = -nologo -c -w -W0 -G6 -GX -D "_MBCS" \
   -D "AR_USE_WIN_32"
# If we are using STLport (to overcome the inadequate standard c++ lib 
# that ships with Visual Studio 6), we have to let the library know we're
# using multiple threads.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    COMMON_COMPILE_FLAGS+= -D "_REENTRANT"
  endif

# The location of the precompiled header. Using this speeds up windows builds
# by a substantial margin. This is another place where we assume SZGHOME
# has been defined.
  PRECOMPILED_HEADER_LOCATION = \
    $(SZGHOME)/build/win32/language/arPrecompiled.pch
  PRECOMPILED_HEADER_FLAGS = -YuarPrecompiled.h \
    -Fp$(PRECOMPILED_HEADER_LOCATION)

# Sometimes we want to NOT have precompiled headers! (For instance, if
# we need to compile against a library built with a *slightly* different
# compiler (i.e. just a patch level away) OR if we need to compile 
# something debug while linking it with object files compiled nondebug.
  PRECOMPILED_HEADER_DISABLE = -YX

# We are using the "dll" libc. This is essential vis-a-vis because of szg's
# dll-centricity. NOTE: AR_USED_SHARED must be defined to get the 
# __declspec(dllexport) that builds the export libraries.
  OPT_FLAGS_DEBUG = -D "_CONSOLE" -MDd -O1 -D "_DEBUG" -D "AR_USE_SHARED"
  OPT_FLAGS_NDEBUG = -D "_CONSOLE" -MD -O2 -D "NDEBUG" -D "AR_USE_SHARED"
# If we are using STLport, this include must come first to override the
# standard Visual C++ includes.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    OPT_FLAGS_DEBUG += -I$(SZGEXTERNAL)/lib/STLport/win32/stlport
    OPT_FLAGS_NDEBUG += -I$(SZGEXTERNAL)/lib/STLport/win32/stlport
  endif

# NOTE: The default set of OPT_FLAGS
ifeq ($(strip $(SZGDEBUG)),TRUE)
  OPT_FLAGS = $(OPT_FLAGS_DEBUG)
else
  OPT_FLAGS = $(OPT_FLAGS_NDEBUG)
endif

# These are explicitly defined since sometimes we want something besides
# the default.
  COMPILE_FLAGS_DEBUG =  $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_DEBUG) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NDEBUG = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_NDEBUG) $(PRECOMPILED_HEADER_FLAGS)
  
# Here is the standard set of compile flags that will be used in compiling
# the objects for the library.
  COMPILE_FLAGS = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS) \
   $(PRECOMPILED_HEADER_FLAGS)

  COMPILE_FLAGS_SHARED = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS)

  PRECOMPILED_HEADER_LINE = $(COMPILER) $(COMMON_COMPILE_FLAGS) \
    $(OPT_FLAGS) \
    -Yc -FparPrecompiled.pch \
    ../../../src/language/arPrecompiled.cpp

  OPTIMIZE_FLAG = -O2

# The flags and other definitions pertaining to linking.
  LINKER = link
  LINK_PREFIX = -out:
# There are several categories of libraries.
  GENERAL_LIBS = advapi32.lib kernel32.lib user32.lib gdi32.lib Ws2_32.lib
  GRAPHICS_LIBS = opengl32.lib glu32.lib glut32.lib
  GAMEPAD_LIBS = dinput.lib dxguid.lib
  LINK_FLAGS_BASE = -nologo -subsystem:console -incremental:no
  LINK_FLAGS_SHARED_BASE = -nologo -incremental:no -dll
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    LINK_FLAGS_BASE += /libpath:$(SZGEXTERNAL)/lib/STLport/win32/lib
    LINK_FLAGS_SHARED_BASE += /libpath:$(SZGEXTERNAL)/lib/STLport/win32/lib
  endif
  LINK_FLAGS_DEBUG = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMT.LIB -debug 
  LINK_FLAGS_SHARED_DEBUG = $(LINK_FLAGS_SHARED_BASE) \
   -NODEFAULTLIB:LIBCMT.LIB -debug
# The default is no debugging
  LINK_FLAGS = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMTD
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_BASE) -NODEFAULTLIB:LIBCMTD
ifeq ($(strip $(SZGDEBUG)),TRUE)
  LINK_FLAGS = $(LINK_FLAGS_DEBUG)
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_DEBUG)
endif

  PRE_LINK_LINE_LIB=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_LIB=

  PRE_LINK_LINE_EXE=$(SZG_CURRENT_LIB) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_EXE =

  PRE_LINK_LINE_USR=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_USR=

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = $(SZGHOME)/build/win32/language/libarLanguage.lib
  PHLEET_LIB_STRING = $(SZGHOME)/build/win32/phleet/libarPhleet.lib
  BARRIER_LIB_STRING = $(SZGHOME)/build/win32/barrier/libarBarrier.lib
  MATH_LIB_STRING = $(SZGHOME)/build/win32/math/libarMath.lib
  DRIVERS_LIB_STRING = $(SZGHOME)/build/win32/drivers/libarDrivers.lib
  GRAPHICS_LIB_STRING = $(SZGHOME)/build/win32/graphics/libarGraphics.lib
  SOUND_LIB_STRING = $(SZGHOME)/build/win32/sound/libarSound.lib
  OBJECT_LIB_STRING = $(SZGHOME)/build/win32/obj/libarObject.lib
  INTERACT_LIB_STRING = $(SZGHOME)/build/win32/interaction/libarInteraction.lib
  FRAMEWORK_LIB_STRING = $(SZGHOME)/build/win32/framework/libarFramework.lib

# It is only necessary to run the created library through ranlib on the
# darwin side, not any other spot.
  RANLIB = @echo
endif

#***************************************************************************
# We go ahead and scan for the libraries here... in addition to setting
# compiler flags and linker flags, as appropriate.
#
# Needs to be an absolute path since we may be calling this from a demo build
# directory.
#***************************************************************************

include $(SZGHOME)/build/make/Makefile.libscan

#***************************************************************************
# Various miscellaneous definitions go here.
#***************************************************************************

# A few variables need to be defined for compilation and linking.
#   SZG_INCLUDE: The szg include directories.
#   SZG_LIBRARY_LIBS: The szg shared libraries to be used. Either all
#    of them (the default) or a subset of them (as might be used
#    in the intermediate makefiles).
#   SZG_OPTIONAL_LIBS: The external libraries found by the lib-scanning
#    procedure (or manually put together by the makefile from those
#    found in that process).
#   SZG_LINK_LIBS: The system libraries szg executables need. These are
#    given by $(DEVICE_LIBS) $(GRAPHICS_LIBS) $(GENERAL_LIBS).
#
# NOTE: In many of the internal makefiles, we defined things manually
# (so that fewer include directories or few libraries can be used in the
# linking). However, for demos, a standard set of includes and libraries is
# used.

# Do NOT make these definitions if we are engaged in the INTERNAL build
# process. In that case, the definitions are made in the internal makefiles.
ifneq ($(strip $(SZG_INCLUDE_STYLE)),INTERNAL)

# The "EASY" library style is provided to allow external application 
# developers to take a nicely packaged version of the headers and libraries
# as compiled for a particular platform and just run with it.
# On the other hand, if you are working on the library itself, it will be
# better to use the traditional style.
ifeq ($(strip $(SZG_LIBRARY_STYLE)),EASY)

SZG_INCLUDE := -I$(SZGHOME)/include
# BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
# This will certainly have to change...
# As a general note, part of the "create-install" process should involve
# drawing the relevant stuff from SZGEXTERNAL into the install image.
# (i.e. there will be a little copy of SZGEXTERNAL in there, which will be
#  used preferentially if SZG_BUILD_STYLE is set to EASY)
# Also, we want to be able to pull stuff from SZGEXTERNAL (the dll's)
# and put them into the binary directory automatically (for a development
# thing even, it's a good idea to put all dll's into a local copy)
SZG_LIBS := $(SZGHOME)/lib/libszg.a

else



# These are the defaults for building executables.

SZG_CURRENT_LIB_SHORT_NAME =

SZG_INCLUDE := \
	-I$(SZGHOME)/src/language \
        -I$(SZGHOME)/src/math \
        -I$(SZGHOME)/src/phleet \
	-I$(SZGHOME)/src/barrier \
	-I$(SZGHOME)/src/drivers \
	-I$(SZGHOME)/src/graphics \
	-I$(SZGHOME)/src/obj \
	-I$(SZGHOME)/src/sound \
	-I$(SZGHOME)/src/interaction \
	-I$(SZGHOME)/src/framework \
	$(SZG_DLL_INCLUDE) \
        $(SZG_OPT_INCLUDE_FULL)

SZG_LIBRARY_LIBS := \
	$(LANGUAGE_LIB_STRING) \
        $(PHLEET_LIB_STRING) \
        $(BARRIER_LIB_STRING) \
        $(MATH_LIB_STRING) \
        $(DRIVERS_LIB_STRING) \
        $(GRAPHICS_LIB_STRING) \
	$(SOUND_LIB_STRING) \
        $(OBJECT_LIB_STRING) \
        $(INTERACT_LIB_STRING) \
        $(FRAMEWORK_LIB_STRING)

SZG_LIBRARY_DEPS := \
	$(LANGUAGE_DEP_STRING) \
        $(PHLEET_DEP_STRING) \
        $(BARRIER_DEP_STRING) \
        $(MATH_DEP_STRING) \
        $(DRIVERS_DEP_STRING) \
        $(GRAPHICS_DEP_STRING) \
	$(SOUND_DEP_STRING) \
        $(OBJECT_DEP_STRING) \
        $(INTERACT_DEP_STRING) \
        $(FRAMEWORK_DEP_STRING)

SZG_OPTIONAL_LIBS = $(SZG_OPT_LIBS_FULL)

SZG_LINK_LIBS = $(GRAPHICS_LIBS) $(GENERAL_LIBS)

endif # end of the check to see if we are using the "EASY" build style

endif # end of the check to see if we are using the "internal" include style

# VPATH is defined in each Makefile.whatever file. SRDCIR is used in the
# *clean* option (allowing us to get rid of certain editor files)
SRCDIR=$(VPATH)

# If the SZGBIN environment variable is set, go ahead and use that. 
# Otherwise, use a standard directory based on SZGHOME.
ifeq ($(strip $(SZGBIN)),)
  BINDIR=$(SZGHOME)/bin/$(strip $(MACHINE_DIR))
else
  BINDIR=$(SZGBIN)
endif

# Link-related commands.
# Variables relevent to the link commands.
SZG_CURRENT_LIB_NAME = lib$(SZG_CURRENT_LIB_SHORT_NAME)
SZG_CURRENT_LIB = $(SZG_CURRENT_LIB_NAME)$(LIB_SUFFIX)
SZG_CURRENT_DLL = $(SZG_CURRENT_LIB_NAME)$(DLL_SUFFIX)

# The library dependencies. NOTE: These are different than what we link
# against.
LANGUAGE_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/language/libarLanguage$(DLL_SUFFIX)
PHLEET_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/phleet/libarPhleet$(DLL_SUFFIX)
BARRIER_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/barrier/libarBarrier$(DLL_SUFFIX)
MATH_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/math/libarMath$(DLL_SUFFIX)
DRIVERS_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/drivers/libarDrivers$(DLL_SUFFIX)
GRAPHICS_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/graphics/libarGraphics$(DLL_SUFFIX)
SOUND_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/sound/libarSound$(DLL_SUFFIX)
OBJECT_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/obj/libarObject$(DLL_SUFFIX)
INTERACT_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/interaction/libarInteraction$(DLL_SUFFIX)
FRAMEWORK_DEP_STRING = \
  $(SZGHOME)/build/$(MACHINE_DIR)/framework/libarFramework$(DLL_SUFFIX)

# Copy the stuff into the bin directory. We can't use SZGBIN since that isn't
# required to be defined. If just SZGHOME is defined, then a directory based
# on that will be the BINDIR.
COPY = $(CP) $@ $(BINDIR)

# For linking the exe's that are built with the library. Here we are dealing
# with the issue that: windows and unix put libraries at DIFFERENT places in
# the link line.
SZG_EXE_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_EXE_SECOND = $(POST_LINK_LINE_EXE)
SZG_USR_FIRST = $(LINKER) $(PRE_LINK_LINE_USR) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_USR_SECOND = $(POST_LINK_LINE_USR)

# Used for linking the syzygy libraries. NOTE: we have to go through some
# special contortions to deal with the different library placement in the
# link line on Windows and Unix.
LINK_SZG_LIB = $(LINKER) $(PRE_LINK_LINE_LIB) $(LINK_FLAGS_SHARED) \
   $(LINK_PREFIX)$(SZG_CURRENT_DLL) $(OBJS) $(POST_LINK_LINE_LIB)

# Useful for linking Syzygy loadable shared objects.
SZG_SHARED_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS_SHARED) \
$(LINK_PREFIX)$@

