#**************************************************************
# This file sets compiler flag definitions based on MACHINE
# (as determined by Makefile.os) and further modifies these
# based on Makefile.libscan, which figures out which optional
# libraries have been installed.
#**************************************************************

#**************************************************************
# The environment variables that affect the build are:
#  SZGHOME: REQUIRED. The top-level directory of the szg.
#  SZGBIN: Optional. If defined, this is where the executables
#          and shared libraries are placed. Otherwise, they
#          are placed in $(SZGHOME)/bin/$(MACHINE_DIR)
#  SZGDEBUG: Optional. If defined and equal to TRUE, the
#            libraries, executables, and plugins are built 
#            debug.
#  SZG_DEVELOPER_STYLE: Optional. If defined and equal to EASY,
#                       a special build process is used for
#                       external executables (which is suited
#                       to using prebuilt libraries).
#  SZGEXTERNAL: Optional. This is where external libraries get
#               placed (in a defined directory structure) if
#               they are to be used by the library. However,
#               if SZG_DEVELOPER_STYLE=EASY, then SZGEXTERNAL
#               is *ignored* and the build process searches 
#               for the external libraries in 
#               $(SZGHOME)/external.
#  SZG_STLPORT: Optional. This is only respected on the windows
#               side. Present since Visual Studio 6 did not 
#               have a good enough implementation of the STL
#               to use with our dll approach in szg-0.7 and 
#               later. If this is set to TRUE, a *windows* 
#               build will attempt to use STLport as the
#               c++ standard lib.
#  SZG_HAVE_DL: Optional. Only meaningful on the Mac OS X side.
#               Later versions of the Apple OS include the
#               dlopen, etc. that dlcompat provides for earlier
#               versions. Set this to TRUE to use the Apple
#               version if such exists on your system.
#  SZG_MULTITEX: Some platforms do not seem to support the 
#                multitexturing extension tricks of the q33
#                demo (some versions of OS X and RedHat 9).
#                Set this to FALSE, and q33 will compile on
#                those platforms.
#**************************************************************

#**************************************************************
#                             LINUX
#**************************************************************

ifeq ($(strip $(MACHINE)),LINUX)
  MACHINE_DIR = linux
  # NOTE: Each time an executable or shared library gets built, it is
  # automatically copied. Do NOT use "cp -u" here (the only-copy-for-update
  # is vulnerable to clock misalignment (i.e. "why isn't my new executable
  # running?")
  CP = cp

# The suffixes unique to the platform.
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  PLUGIN_SUFFIX=.so
  EXE = 

# General info regarding compiling such as flags for the various build styles.
# NOTE: since we are building DLL's, need POSITION INDEPENDENT code
  COMPILER = g++
  COMPILE_FLAGS_NDEBUG = -DAR_USE_LINUX -c -fPIC -O2 -Wall -W \
    -Wpointer-arith -march=i686 $(SZG_OPT_FLAGS)
  COMPILE_FLAGS_DEBUG = -DAR_USE_LINUX -c -fPIC -g -Wall -W \
    -Wpointer-arith -march=i686 $(SZG_OPT_FLAGS)
  # Do NOT use ":=" in defining COMPILE_FLAGS, since this allows more
  # flexibility in where SZG_OPT_FLAGS is defined.
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS = $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS = $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED = $(COMPILE_FLAGS)

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# This covers up the fact that precompiled headers are not needed on the
# Unix side.  
  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

# General settings regarding linking, such as flags and libraries.
  LINKER = g++
  LINK_PREFIX = 
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  LINK_FLAGS_PLUGIN = -shared -o
  GENERAL_LIBS = -ldl -lpthread -lm
  GRAPHICS_LIBS = -lglut -lGLU -lGL -L/usr/X11R6/lib -lX11 -lXext -lXmu \
    -lXt -lXi -lSM -lICE
  GAMEPAD_LIBS =

# The flags for library search vary based on whether or not our build style
# is EASY. If so, in addition to changing the compile-time search location,
# do not add a runtime path. Because the built-in runtime search paths will
# be unhelpful (libarPhleet.so will search for libarLanguage.so on its
# location for the developer who compiled the libraries), it is no extra
# burden to make the user set LD_LIBRARY_PATH.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(BINDIR) -Wl,-rpath,$(BINDIR)
  endif

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_SHORT_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage
  PHLEET_LIB_STRING = -larPhleet
  BARRIER_LIB_STRING = -larBarrier
  MATH_LIB_STRING = -larMath
  DRIVERS_LIB_STRING = -larDrivers
  GRAPHICS_LIB_STRING = -larGraphics
  SOUND_LIB_STRING = -larSound
  OBJECT_LIB_STRING = -larObject
  INTERACT_LIB_STRING = -larInteraction
  FRAMEWORK_LIB_STRING = -larFramework

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = touch
endif

#*************************************************************
#                             OS X
#*************************************************************

ifeq ($(strip $(MACHINE)),DARWIN)
  MACHINE_DIR = darwin
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.dylib
  LIB_SUFFIX=.dylib
  PLUGIN_SUFFIX=.so
  EXE =

# compilation
  COMPILER = c++
  COMPILE_FLAGS_NDEBUG = -DAR_BIG_ENDIAN -DAR_USE_DARWIN -fno-common -fPIC \
    -O2 -c
  COMPILE_FLAGS_DEBUG = -DAR_BIG_ENDIAN -DAR_USE_DARWIN -fno-common -fPIC \
    -c -g
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS := $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS := $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED:=$(COMPILE_FLAGS)

  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)
  
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif
  
# linking
  LINKER = c++
  LINK_PREFIX =
  LINK_FLAGS = -o
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -dynamiclib -flat_namespace -undefined suppress -o
  LINK_FLAGS_PLUGIN = -bundle -flat_namespace -undefined suppress -o
  
  GENERAL_LIBS = -lm -lpthread -lcurses -lobjc
  GRAPHICS_LIBS = -framework OpenGL -framework GLUT -framework COCOA
  GAMEPAD_LIBS = 

# If our version of the Mac OS has dlopen, then do not use dlcompat
# (however, using dlcompat is the default since it seems to work in all
# cases. HMMM... it seems like there are compilation problems on the Darwin
# side for 10.2 that run deeper than not having dlopen. If we decide that
# 10.3 will no longer be supported, then this should just be purged!
  ifneq ($(strip $(SZG_HAVE_DL)),TRUE)
    GENERAL_LIBS += $(SZGHOME)/contrib/dlcompat/libdl.a
    SZG_DLL_INCLUDE = -I$(SZGHOME)/contrib/dlcompat
  endif 

# The flags for library search vary based on whether or not our build style
# is EASY. Since OS X allows relative runtime paths, things are a little
# easier than the other Unixes because it won't be strictly necessary to 
# set DYLD_LIBRARY_PATH (the equivalent of LD_LIBRARY_PATH for Darwin)
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(BINDIR)
  endif

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS) -install_name @executable_path/$(SZG_CURRENT_LIB)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_SHORT_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage
  PHLEET_LIB_STRING = -larPhleet
  BARRIER_LIB_STRING = -larBarrier
  MATH_LIB_STRING = -larMath
  DRIVERS_LIB_STRING = -larDrivers
  GRAPHICS_LIB_STRING = -larGraphics
  SOUND_LIB_STRING = -larSound
  OBJECT_LIB_STRING = -larObject
  INTERACT_LIB_STRING = -larInteraction
  FRAMEWORK_LIB_STRING = -larFramework


# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = ranlib

endif

#*************************************************************
#                             SGI
#*************************************************************


# Handle mips3/mips4 architecture on SGI.
ifeq ($(strip $(MACHINE)),MIPS3)
  MACHINE_DIR = mips3
  MACHINE = SGI
endif
ifeq ($(strip $(MACHINE)),MIPS4)
  MACHINE_DIR = mips4
  MACHINE = SGI
endif

ifeq ($(strip $(MACHINE)),SGI)
# At one time, the SGI compiler CC did not emit thread-safe code 
# when using STL. This seems to have changed sometime late in the
# Irix 6.5 series. Consequently, use CC (we did some experimentation
# with g++ in the past, but this wasn't so helpful since g++ seemed to
# use the native libc, and inherited the thread-safety problems).

# Finally, it seems like the modern SGI compilers, when properly
# set-up, emit code that is thread-safe vis-a-vis STL without
# as many flags (the real test is the STL-thread-safety hammer that
# is contained in the TestLanguage unit test). For the sake of
# history, the additional flags are reproduced here (they might never
# have done any good). They were passed to both the compiler and the 
# linker.
# -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE
 
# DO NOT use "cp -u" since it is vulnerable to clock misalignment
# (i.e. "Why hasn't my new executable copied over?")
  CP = cp

# suffixes
  OBJ_SUFFIX = .o
  DLL_SUFFIX=.so
  LIB_SUFFIX=.so
  PLUGIN_SUFFIX=.so
  EXE = 

# compilation
  COMPILER = CC
# -LANG:std is necessary to allow the use of the new-style C++ headers
# (i.e. <iostream> vs. <iostream.h>)
# Without -ptused there are problems with template code.
# NOTE: position independent code is generated by default by the
# CC compiler, consequently we do not need any special flags!
# In fact, recent versions of the compiler COMPLAIN if we, in fact,
# use the -kPIC flag (saying it isn't supported anymore).
  COMPILE_FLAGS_NDEBUG :=  -DAR_USE_SGI -LANG:std -n32 -ptused -c
  COMPILE_FLAGS_DEBUG := -DAR_USE_SGI -LANG:std -n32 -ptused -c -g
  ifneq ($(strip $(SZGDEBUG)),TRUE)
    COMPILE_FLAGS := $(COMPILE_FLAGS_NDEBUG)
  else
    COMPILE_FLAGS := $(COMPILE_FLAGS_DEBUG)
  endif
  COMPILE_FLAGS_SHARED:=$(COMPILE_FLAGS)

  PRECOMPILED_HEADER_LINE := \
    $(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O3
  else
    OPTIMIZE_FLAG = 
  endif

# linking
  LINKER = CC
# Without -no_prelink, there are problems with template code.
  LINK_FLAGS := -LANG:std -n32 -no_prelink -o
  LINK_PREFIX = 
  LINK_FLAGS_DEBUG := $(LINK_FLAGS)
  LINK_FLAGS_SHARED = -shared -o
  LINK_FLAGS_PLUGIN = $(LINK_FLAGS_SHARED)

  GENERAL_LIBS = -lpthread -lcurses -lm
  GRAPHICS_LIBS = -lglut -lGLU -lGL \
    -L/usr/X11R6/lib -lX11 -lXext -lXmu -lXt -lXi -lSM -lICE
  GAMEPAD_LIBS =

# The flags for library search vary based on whether or not our build style
# is EASY. If so, in addition to changing the compile-time search location,
# do not add a runtime path. Because the built-in runtime search paths will
# be unhelpful (libarPhleet.so will search for libarLanguage.so on its
# location for the developer who compiled the libraries), it is no extra
# burden to make the user set N32_LIBRARY_PATH.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
  else
    LIB_SEARCH_FLAGS=-L$(BINDIR) -Wl,-rpath,$(BINDIR)
  endif

  PRE_LINK_LINE_LIB= 
  POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

  PRE_LINK_LINE_EXE= 
  POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_SHORT_NAME) \
    $(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  
  PRE_LINK_LINE_USR= 
  POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
  LANGUAGE_LIB_STRING = -larLanguage
  PHLEET_LIB_STRING = -larPhleet
  BARRIER_LIB_STRING = -larBarrier
  MATH_LIB_STRING = -larMath
  DRIVERS_LIB_STRING = -larDrivers
  GRAPHICS_LIB_STRING = -larGraphics
  SOUND_LIB_STRING = -larSound
  OBJECT_LIB_STRING = -larObject
  INTERACT_LIB_STRING = -larInteraction
  FRAMEWORK_LIB_STRING = -larFramework

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = touch
endif

#*************************************************************
#                             WINDOWS
#*************************************************************

ifeq ($(strip $(MACHINE)),WIN32)
  MACHINE_DIR = win32
  # NOTE: The copy-to-bin-directory now occurs either automatically when
  # an executable (or the library) is recompiled (for each such individually).
  # It can also occur upon a manually given copy request (in which case
  # everything is rebuilt (if necessary as determined by make) then copied.
  CP = cp

# suffixes
  OBJ_SUFFIX = .obj
  DLL_SUFFIX = .dll
  LIB_SUFFIX = .lib
  PLUGIN_SUFFIX = .dll
  EXE = .exe

# compilation
  COMPILER = cl
  COMMON_COMPILE_FLAGS = -nologo -c -w -W0 -G6 -GX -D "_MBCS" \
   -D "AR_USE_WIN_32" $(SZG_OPT_FLAGS)
# If we are using STLport (to overcome the inadequate standard c++ lib 
# that ships with Visual Studio 6), we have to let the library know we're
# using multiple threads.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    COMMON_COMPILE_FLAGS+= -D "_REENTRANT"
  endif

# The location of the precompiled header. Using this speeds up windows builds
# by a substantial margin. This is another place where we assume SZGHOME
# has been defined.
  PRECOMPILED_HEADER_LOCATION = \
    $(SZGHOME)/build/win32/language/arPrecompiled.pch
  PRECOMPILED_HEADER_FLAGS = -YuarPrecompiled.h \
    -Fp$(PRECOMPILED_HEADER_LOCATION)

# Sometimes we want to NOT have precompiled headers! (For instance, if
# we need to compile against a library built with a *slightly* different
# compiler (i.e. just a patch level away) OR if we need to compile 
# something debug while linking it with object files compiled nondebug.
  PRECOMPILED_HEADER_DISABLE = -YX

# If SZG_DEVELOPER_STYLE is EASY, then we will compile WITHOUT using
# precompiled headers.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    PRECOMPILED_HEADER_FLAGS = $(PRECOMPILED_HEADER_DISABLE)
  endif

# We are using the "dll" libc. This is essential vis-a-vis because of szg's
# dll-centricity. NOTE: AR_USED_SHARED must be defined to get the 
# __declspec(dllexport) that builds the export libraries.
  OPT_FLAGS_DEBUG = -D "_CONSOLE" -MDd -O1 -D "_DEBUG" -D "AR_USE_SHARED"
  OPT_FLAGS_NDEBUG = -D "_CONSOLE" -MD -O2 -D "NDEBUG" -D "AR_USE_SHARED"
# If we are using STLport, this include must come first to override the
# standard Visual C++ includes.
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    OPT_FLAGS_DEBUG += -I$(SZGEXTERNAL)/win32/STLport/stlport
    OPT_FLAGS_NDEBUG += -I$(SZGEXTERNAL)/win32/STLport/stlport
  endif

# NOTE: The default set of OPT_FLAGS
ifeq ($(strip $(SZGDEBUG)),TRUE)
  OPT_FLAGS = $(OPT_FLAGS_DEBUG)
else
  OPT_FLAGS = $(OPT_FLAGS_NDEBUG)
endif

# These are explicitly defined since sometimes we want something besides
# the default.
  COMPILE_FLAGS_DEBUG =  $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_DEBUG) $(PRECOMPILED_HEADER_FLAGS)
  COMPILE_FLAGS_NDEBUG = $(COMMON_COMPILE_FLAGS) \
   $(OPT_FLAGS_NDEBUG) $(PRECOMPILED_HEADER_FLAGS)
  
# Here is the standard set of compile flags that will be used in compiling
# the objects for the library.
  COMPILE_FLAGS = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS) \
   $(PRECOMPILED_HEADER_FLAGS)

  COMPILE_FLAGS_SHARED = $(COMMON_COMPILE_FLAGS) $(OPT_FLAGS)

  PRECOMPILED_HEADER_LINE = $(COMPILER) $(COMMON_COMPILE_FLAGS) \
    $(OPT_FLAGS) \
    -Yc -FparPrecompiled.pch \
    ../../../src/language/arPrecompiled.cpp

  ifneq ($(strip $(SZGDEBUG)),TRUE)
    OPTIMIZE_FLAG = -O2
  else
    OPTIMIZE_FLAG = 
  endif

# The flags and other definitions pertaining to linking.
  LINKER = link
  LINK_PREFIX = -out:
# There are several categories of libraries.
  GENERAL_LIBS = advapi32.lib kernel32.lib user32.lib gdi32.lib Ws2_32.lib
  GRAPHICS_LIBS = opengl32.lib glu32.lib glut32.lib
  GAMEPAD_LIBS = dinput.lib dxguid.lib
  LINK_FLAGS_BASE = -nologo -subsystem:console -incremental:no
  LINK_FLAGS_SHARED_BASE = -nologo -incremental:no -dll
  ifeq ($(strip $(SZG_STLPORT)),TRUE)
    LINK_FLAGS_BASE += /libpath:$(SZGEXTERNAL)/win32/STLport/lib
    LINK_FLAGS_SHARED_BASE += /libpath:$(SZGEXTERNAL)/win32/STLport/lib
  endif
  LINK_FLAGS_DEBUG = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMT.LIB -debug 
  LINK_FLAGS_SHARED_DEBUG = $(LINK_FLAGS_SHARED_BASE) \
   -NODEFAULTLIB:LIBCMT.LIB -debug
# The default is no debugging
  LINK_FLAGS = $(LINK_FLAGS_BASE) -NODEFAULTLIB:LIBCMTD
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_BASE) -NODEFAULTLIB:LIBCMTD
ifeq ($(strip $(SZGDEBUG)),TRUE)
  LINK_FLAGS = $(LINK_FLAGS_DEBUG)
  LINK_FLAGS_SHARED = $(LINK_FLAGS_SHARED_DEBUG)
endif
  LINK_FLAGS_PLUGIN = $(LINK_FLAGS_SHARED)

  PRE_LINK_LINE_LIB=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_LIB=

  PRE_LINK_LINE_EXE=$(SZG_CURRENT_LIB) $(SZG_LIBRARY_LIBS) \
    $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_EXE =

  PRE_LINK_LINE_USR=$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)
  POST_LINK_LINE_USR=

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. On the Win32 side, we actually
# need to reference the libs directly. Whereas on Unix, we need to reference
# things INDIRECTLY.
  ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
    LANGUAGE_LIB_STRING=$(SZGHOME)/lib/libarLanguage.lib
    PHLEET_LIB_STRING=$(SZGHOME)/lib/libarPhleet.lib
    BARRIER_LIB_STRING=$(SZGHOME)/lib/libarBarrier.lib
    MATH_LIB_STRING=$(SZGHOME)/lib/libarMath.lib
    DRIVERS_LIB_STRING=$(SZGHOME)/lib/libarDrivers.lib
    GRAPHICS_LIB_STRING=$(SZGHOME)/lib/libarGraphics.lib
    SOUND_LIB_STRING=$(SZGHOME)/lib/libarSound.lib
    OBJECT_LIB_STRING=$(SZGHOME)/lib/libarObject.lib
    INTERACT_LIB_STRING=$(SZGHOME)/lib/libarInteraction.lib
    FRAMEWORK_LIB_STRING=$(SZGHOME)/lib/libarFramework.lib
  else
    LANGUAGE_LIB_STRING=$(SZGHOME)/build/win32/language/libarLanguage.lib
    PHLEET_LIB_STRING=$(SZGHOME)/build/win32/phleet/libarPhleet.lib
    BARRIER_LIB_STRING=$(SZGHOME)/build/win32/barrier/libarBarrier.lib
    MATH_LIB_STRING=$(SZGHOME)/build/win32/math/libarMath.lib
    DRIVERS_LIB_STRING=$(SZGHOME)/build/win32/drivers/libarDrivers.lib
    GRAPHICS_LIB_STRING=$(SZGHOME)/build/win32/graphics/libarGraphics.lib
    SOUND_LIB_STRING=$(SZGHOME)/build/win32/sound/libarSound.lib
    OBJECT_LIB_STRING=$(SZGHOME)/build/win32/obj/libarObject.lib
    INTERACT_LIB_STRING=$(SZGHOME)/build/win32/interaction/libarInteraction.lib
    FRAMEWORK_LIB_STRING=$(SZGHOME)/build/win32/framework/libarFramework.lib
  endif

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
  RANLIB = @echo
endif

#***************************************************************************
# We go ahead and scan for the libraries here... in addition to setting
# compiler flags and linker flags, as appropriate.
#
# Needs to be an absolute path since we may be calling this from a demo build
# directory.
#
# This needs to go down here (opposed to at the top) for a really lame
# reason. Specifically, MACHINE needs to be set first, and that gets done
# earlier in the file!
#***************************************************************************

include $(SZGHOME)/build/make/Makefile.libscan

#***************************************************************************
# Various miscellaneous definitions go here.
#***************************************************************************

# A few variables need to be defined for compilation and linking.
#   SZG_INCLUDE: The szg include directories.
#   SZG_LIBRARY_LIBS: The szg shared libraries to be used. Either all
#    of them (the default) or a subset of them (as might be used
#    in the intermediate makefiles).
#   SZG_OPTIONAL_LIBS: The external libraries found by the lib-scanning
#    procedure (or manually put together by the makefile from those
#    found in that process).
#   SZG_LINK_LIBS: The system libraries szg executables need. These are
#    given by $(DEVICE_LIBS) $(GRAPHICS_LIBS) $(GENERAL_LIBS).
#
# NOTE: In many of the internal makefiles, we defined things manually
# (so that fewer include directories or few libraries can be used in the
# linking). However, for demos, a standard set of includes and libraries is
# used.

# Do NOT make these definitions if we are engaged in the INTERNAL build
# process. In that case, the definitions are made in the internal makefiles.
ifneq ($(strip $(SZG_INCLUDE_STYLE)),INTERNAL)

# The "EASY" library style is provided to allow external application 
# developers to take a nicely packaged version of the headers and libraries
# as compiled for a particular platform and just run with it.
# On the other hand, if you are working on the library itself, it will be
# better to use the traditional style.
ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)

  SZG_INCLUDE = -I$(SZGHOME)/include \
	$(SZG_DLL_INCLUDE) \
	$(SZG_OPT_INCLUDE_FULL)

  LANGUAGE_DEP_STRING = \
    $(SZGHOME)/bin/libarLanguage$(DLL_SUFFIX)
  PHLEET_DEP_STRING = \
    $(SZGHOME)/bin/libarPhleet$(DLL_SUFFIX)
  BARRIER_DEP_STRING = \
    $(SZGHOME)/bin/libarBarrier$(DLL_SUFFIX)
  MATH_DEP_STRING = \
    $(SZGHOME)/bin/libarMath$(DLL_SUFFIX)
  DRIVERS_DEP_STRING = \
    $(SZGHOME)/bin/libarDrivers$(DLL_SUFFIX)
  GRAPHICS_DEP_STRING = \
    $(SZGHOME)/bin/libarGraphics$(DLL_SUFFIX)
  SOUND_DEP_STRING = \
    $(SZGHOME)/bin/libarSound$(DLL_SUFFIX)
  OBJECT_DEP_STRING = \
    $(SZGHOME)/bin/libarObject$(DLL_SUFFIX)
  INTERACT_DEP_STRING = \
    $(SZGHOME)/bin/libarInteraction$(DLL_SUFFIX)
  FRAMEWORK_DEP_STRING = \
    $(SZGHOME)/bin/libarFramework$(DLL_SUFFIX)

else

SZG_INCLUDE = \
	-I$(SZGHOME)/src/language \
        -I$(SZGHOME)/src/math \
        -I$(SZGHOME)/src/phleet \
	-I$(SZGHOME)/src/barrier \
	-I$(SZGHOME)/src/drivers \
	-I$(SZGHOME)/src/graphics \
	-I$(SZGHOME)/src/obj \
	-I$(SZGHOME)/src/sound \
	-I$(SZGHOME)/src/interaction \
	-I$(SZGHOME)/src/framework \
	$(SZG_DLL_INCLUDE) \
        $(SZG_OPT_INCLUDE_FULL)

  LANGUAGE_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/language/libarLanguage$(DLL_SUFFIX)
  PHLEET_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/phleet/libarPhleet$(DLL_SUFFIX)
  BARRIER_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/barrier/libarBarrier$(DLL_SUFFIX)
  MATH_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/math/libarMath$(DLL_SUFFIX)
  DRIVERS_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/drivers/libarDrivers$(DLL_SUFFIX)
  GRAPHICS_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/graphics/libarGraphics$(DLL_SUFFIX)
  SOUND_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/sound/libarSound$(DLL_SUFFIX)
  OBJECT_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/obj/libarObject$(DLL_SUFFIX)
  INTERACT_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/interaction/libarInteraction$(DLL_SUFFIX)
  FRAMEWORK_DEP_STRING = \
    $(SZGHOME)/build/$(MACHINE_DIR)/framework/libarFramework$(DLL_SUFFIX)

endif # end of the check to see if we are using the "EASY" build style

# These variables must be set (either for "EASY" or "DEVELOPER" build styles)
# assuming we are compiling from outside of the szg internal Makefiles...
SZG_LIBRARY_LIBS := \
	$(LANGUAGE_LIB_STRING) \
        $(PHLEET_LIB_STRING) \
        $(BARRIER_LIB_STRING) \
        $(MATH_LIB_STRING) \
        $(DRIVERS_LIB_STRING) \
        $(GRAPHICS_LIB_STRING) \
	$(SOUND_LIB_STRING) \
        $(OBJECT_LIB_STRING) \
        $(INTERACT_LIB_STRING) \
        $(FRAMEWORK_LIB_STRING)

# The dependencies might be different from the libs. For instance, on
# Unix platforms, we DO NOT want to have absolute paths to the shared
# libraries, but our dependencies for the make MUST have absolute paths.
# On Windows, the situation is easier since we link with .lib files, which 
# are NOT the files that the executable runtime links with.

SZG_LIBRARY_DEPS := \
	$(LANGUAGE_DEP_STRING) \
        $(PHLEET_DEP_STRING) \
        $(BARRIER_DEP_STRING) \
        $(MATH_DEP_STRING) \
        $(DRIVERS_DEP_STRING) \
        $(GRAPHICS_DEP_STRING) \
	$(SOUND_DEP_STRING) \
        $(OBJECT_DEP_STRING) \
        $(INTERACT_DEP_STRING) \
        $(FRAMEWORK_DEP_STRING)

SZG_CURRENT_LIB_SHORT_NAME =
SZG_OPTIONAL_LIBS = $(SZG_OPT_LIBS_FULL)
SZG_LINK_LIBS = $(GRAPHICS_LIBS) $(GENERAL_LIBS)

endif # end of the check to see if we are using the "internal" include style

# Used for creating the "easy" install of the library.
INSTALLDIR = $(SZGHOME)/szg-install

# VPATH is defined in each Makefile.whatever file. SRCDIR is used in the
# *clean* option (allowing us to get rid of certain editor files)
SRCDIR=$(VPATH)

# If the SZGBIN environment variable is set, go ahead and use that. 
# Otherwise, use a standard directory based on SZGHOME.
ifeq ($(strip $(SZGBIN)),)
  BINDIR=$(SZGHOME)/bin/$(strip $(MACHINE_DIR))
else
  BINDIR=$(SZGBIN)
endif

# Link-related commands.
# Variables relevent to the link commands.
SZG_CURRENT_LIB_NAME = lib$(SZG_CURRENT_LIB_SHORT_NAME)
SZG_CURRENT_LIB = $(SZG_CURRENT_LIB_NAME)$(LIB_SUFFIX)
SZG_CURRENT_DLL = $(SZG_CURRENT_LIB_NAME)$(DLL_SUFFIX)

# On Win32, for our "create-install", it is necessary to put our .lib file
# in a special "lib" directory. This is because Visual Studio makes a 
# distinction between what you compile against and what you link with.
ifeq ($(strip $(MACHINE)),WIN32)
  # Only some projects produce a library that needs to be copied into the
  # install's lib directory.
  ifeq ($(strip $(SZG_COPY_LIB)),TRUE)
    SZG_LIB_COPY_LINE = $(CP) $(SZG_CURRENT_LIB) $(INSTALLDIR)/lib
  endif
endif

# Copy the stuff into the bin directory. We can't use SZGBIN since that isn't
# required to be defined. If just SZGHOME is defined, then a directory based
# on that will be the BINDIR.
COPY = $(CP) $@ $(BINDIR)

# For linking the exe's that are built with the library. Here we are dealing
# with the issue that: windows and unix put libraries at DIFFERENT places in
# the link line.
SZG_EXE_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_EXE_SECOND = $(POST_LINK_LINE_EXE)
SZG_USR_FIRST = $(LINKER) $(PRE_LINK_LINE_USR) $(LINK_FLAGS) $(LINK_PREFIX)$@
SZG_USR_SECOND = $(POST_LINK_LINE_USR)

# Used for linking the syzygy libraries. NOTE: we have to go through some
# special contortions to deal with the different library placement in the
# link line on Windows and Unix.
LINK_SZG_LIB = $(LINKER) $(PRE_LINK_LINE_LIB) $(LINK_FLAGS_SHARED) \
   $(LINK_PREFIX)$(SZG_CURRENT_DLL) $(OBJS) $(POST_LINK_LINE_LIB)

# Useful for linking Syzygy loadable shared objects.
SZG_PLUGIN_FIRST = $(LINKER) $(PRE_LINK_LINE_EXE) $(LINK_FLAGS_PLUGIN) \
$(LINK_PREFIX)$@

