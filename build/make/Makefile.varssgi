# At one time, the SGI compiler CC did not emit thread-safe code 
# when using STL. This seems to have changed sometime late in the
# Irix 6.5 series. Consequently, use CC (we did some experimentation
# with g++ in the past, but this wasn't so helpful since g++ seemed to
# use the native libc, and inherited the thread-safety problems).

# Finally, it seems like the modern SGI compilers, when properly
# set-up, emit code that is thread-safe vis-a-vis STL without
# as many flags (the real test is the STL-thread-safety hammer that
# is contained in the TestLanguage unit test). For the sake of
# history, the additional flags are reproduced here (they might never
# have done any good). They were passed to both the compiler and the 
# linker.
# -D_SGI_REENTRANT_FUNCTIONS -D_SGI_MP_SOURCE

# DO NOT use "cp -u" since it is vulnerable to clock misalignment
# (i.e. "Why hasn't my new executable copied over?")
CP = cp

# suffixes
OBJ_SUFFIX = .o
DLL_SUFFIX=.so
LIB_SUFFIX=.so
PLUGIN_SUFFIX=.so
STATIC_SUFFIX=.a
EXE = 

# compilation
COMPILER = CC
# -LANG:std is necessary to allow the use of the new-style C++ headers
# (i.e. <iostream> vs. <iostream.h>)
# Without -ptused there are problems with template code.
# NOTE: position independent code is generated by default by the
# CC compiler, consequently we do not need any special flags!
# In fact, recent versions of the compiler COMPLAIN if we, in fact,
# use the -kPIC flag (saying it isn't supported anymore).
COMPILE_FLAGS_NDEBUG =  $(SZG_OPT_FLAGS) -DAR_USE_SGI -LANG:std -n32 \
	-ptused -c
COMPILE_FLAGS_DEBUG = $(SZG_OPT_FLAGS) -DAR_USE_SGI -LANG:std -n32 -ptused \
	-c -g
ifneq ($(strip $(SZGDEBUG)),TRUE)
	COMPILE_FLAGS = $(COMPILE_FLAGS_NDEBUG)
else
	COMPILE_FLAGS = $(COMPILE_FLAGS_DEBUG)
endif

COMPILE_FLAGS_SHARED = $(COMPILE_FLAGS)

PRECOMPILED_HEADER_LINE := \
	$(CP) ../../../src/language/arPrecompiled.cpp arPrecompiled$(OBJ_SUFFIX)

ifneq ($(strip $(SZGDEBUG)),TRUE)
	OPTIMIZE_FLAG = -O3
else
	OPTIMIZE_FLAG = 
endif

# linking
LINKER = CC
STATIC_LINKER = ar -r
# Without -no_prelink, there are problems with template code.
LINK_FLAGS = -LANG:std -n32 -no_prelink -o
LINK_PREFIX = 
LINK_FLAGS_DEBUG = $(LINK_FLAGS)
LINK_FLAGS_SHARED = -shared -o
LINK_FLAGS_PLUGIN = $(LINK_FLAGS_SHARED)

GENERAL_LIBS = -lpthread -lcurses -lm
# Let GLUT be dealt with in Makefile.libscan. This makes it easier to
# put it in SZGEXTERNAL instead of installing it.
GRAPHICS_LIBS = -lGLU -lGL \
	-L/usr/X11R6/lib -lX11 -lXext -lXmu -lXt -lXi -lSM -lICE
GAMEPAD_LIBS =

# The flags for library search vary based on whether or not our build style
# is EASY. If so, in addition to changing the compile-time search location,
# do not add a runtime path. Because the built-in runtime search paths will
# be unhelpful (libarPhleet.so will search for libarLanguage.so on its
# location for the developer who compiled the libraries), it is no extra
# burden to make the user set N32_LIBRARY_PATH.
ifeq ($(strip $(SZG_DEVELOPER_STYLE)),EASY)
	LIB_SEARCH_FLAGS=-L$(SZGHOME)/bin
else
	LIB_SEARCH_FLAGS=-L$(SZG_BINDIR) -Wl,-rpath,$(SZG_BINDIR)
endif

PRE_LINK_LINE_LIB= 
POST_LINK_LINE_LIB=$(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
	$(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

PRE_LINK_LINE_EXE= 
POST_LINK_LINE_EXE= $(LIB_SEARCH_FLAGS) -l$(SZG_CURRENT_LIB_MOD_NAME) \
	$(SZG_LIBRARY_LIBS) $(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

PRE_LINK_LINE_USR= 
POST_LINK_LINE_USR= $(LIB_SEARCH_FLAGS) $(SZG_LIBRARY_LIBS) \
	$(SZG_OPTIONAL_LIBS) $(SZG_LINK_LIBS)

# It turns out that libraries on the Unix and Win32 sides need to be
# referenced in fundamentally different ways. 
LANGUAGE_LIB_STRING = -larLanguage$(SZG_STATIC_MOD)
PHLEET_LIB_STRING = -larPhleet$(SZG_STATIC_MOD)
BARRIER_LIB_STRING = -larBarrier$(SZG_STATIC_MOD)
MATH_LIB_STRING = -larMath$(SZG_STATIC_MOD)
DRIVERS_LIB_STRING = -larDrivers$(SZG_STATIC_MOD)
GRAPHICS_LIB_STRING = -larGraphics$(SZG_STATIC_MOD)
SOUND_LIB_STRING = -larSound$(SZG_STATIC_MOD)
OBJECT_LIB_STRING = -larObject$(SZG_STATIC_MOD)
INTERACT_LIB_STRING = -larInteraction$(SZG_STATIC_MOD)
FRAMEWORK_LIB_STRING = -larFramework$(SZG_STATIC_MOD)

# Creating static libraries. NOTE: on OS X it is necessary to run
# ranlib on a newly linked .a, but this is redundant on other Unix
# or Win32 platforms.
RANLIB = touch

